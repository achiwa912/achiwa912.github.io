<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Effective Python一人輪読会(Item 19 to 36) &mdash; Dreaming in Brookline, MA 02446</title>
  <meta name="author" content="きょうす kyos">






  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">


    <link href="/favicon.png" rel="icon">

  <link href="/theme/css/main.css" media="screen, projection"
        rel="stylesheet" type="text/css">

  <link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic"
        rel="stylesheet" type="text/css">
  <link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic"
        rel="stylesheet" type="text/css">
</head>

<body>
  <header role="banner"><hgroup>
  <h1><a href="/">Dreaming in Brookline, MA 02446</a></h1>
</hgroup></header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
</ul>


<ul class="main-navigation">
    <li><a href="pages/about.html">About me</a></li>
      <li >
        <a href="/category/blog.html">Blog</a>
      </li>
      <li >
        <a href="/category/english.html">English</a>
      </li>
      <li >
        <a href="/category/linux.html">Linux</a>
      </li>
      <li class="active">
        <a href="/category/python.html">Python</a>
      </li>
      <li >
        <a href="/category/tech.html">Tech</a>
      </li>
</ul></nav>
  <div id="main">
    <div id="content">
<div>
  <article class="hentry" role="article">
<header>
      <h1 class="entry-title">Effective Python一人輪読会(Item 19 to 36)</h1>
    <p class="meta">
<time datetime="2020-08-18T00:00:00-04:00" pubdate>Tue 18 August 2020</time>    </p>
</header>

  <div class="entry-content"><div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org94448e1">1. Chapter 3: 関数</a>
<ul>
<li><a href="#org673712f">1.1. Item 19: 関数が複数の値を返すとき、4つ以上の変数にunpackするな</a></li>
<li><a href="#orgd85c8a7">1.2. Item 20: Noneを返すくらいなら例外を上げよ</a></li>
<li><a href="#org4f63527">1.3. Item 21: Closuresが変数のスコープにどう影響するかを知っておけ</a></li>
<li><a href="#org5da6a5c">1.4. Item 22: 可変数のpositional argumentsを使って見やすくしろ</a></li>
<li><a href="#org90d4f7c">1.5. Item 23: オプションとなる挙動はキーワード引数で与えよ</a></li>
<li><a href="#org5793923">1.6. Item 24: 動的なデフォルト引数を指定するときはNoneとDocstringsを使え</a></li>
<li><a href="#orgd40661e">1.7. Item 25: キーワードオンリー引数、位置オンリー引数を使って、明確さを強制せよ</a></li>
<li><a href="#org777733c">1.8. Item 26: 関数のデコレーターをfunctools.wrapsを使って定義せよ</a></li>
</ul>
</li>
<li><a href="#orgfb1bf2c">2. Chapter 4: Comprehensionsとジェネレーター</a>
<ul>
<li><a href="#orgcd3a1a4">2.1. Item 27: mapとfilterの代わりにcomprehensionsを使え</a></li>
<li><a href="#orgd00ae44">2.2. Item 28: 3つ以上のコントロールsubexpressionsをcomprehensionsで使うな</a></li>
<li><a href="#orga29991c">2.3. Item 29: Assignment表現を使って、comprehensions内での繰り返しを避けよ</a></li>
<li><a href="#orgf5605cb">2.4. Item 30: リストを返すくらいならジェネレーターを考慮せよ</a></li>
<li><a href="#org9331f40">2.5. Item 31: 引数をたどるときには保守的になれ</a></li>
<li><a href="#org1c7459f">2.6. Item 32: 大きなリストcomprehensionsの代わりにジェネレーターexpressionsを考えよ</a></li>
<li><a href="#orgf600043">2.7. Item 33: yield fromを使って複数のジェネレーターを組み合わせよ</a></li>
<li><a href="#org1b150b7">2.8. Item 34: ジェネレーターにsendを使ってデータを送ってはいけない</a></li>
<li><a href="#org1c7e54d">2.9. Item 35: throwで例外を投げてジェネレータの状態遷移を起こすな</a></li>
<li><a href="#orge53ff4e">2.10. Item 36: Iteratorやジェネレーターを使うときにはitertoolsの使用を検討せよ</a>
<ul>
<li><a href="#orgc96fef1">2.10.1. Iteratorsをつなぐ</a></li>
<li><a href="#orgb7a0d93">2.10.2. Iteratorからアイテムをフィルタする</a></li>
<li><a href="#org6de9414">2.10.3. 複数iteratorsのアイテムを結びつける</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org94448e1" class="outline-2">
<h2 id="org94448e1"><span class="section-number-2">1</span> Chapter 3: 関数</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org673712f" class="outline-3">
<h3 id="org673712f"><span class="section-number-3">1.1</span> Item 19: 関数が複数の値を返すとき、4つ以上の変数にunpackするな</h3>
<div class="outline-text-3" id="text-1-1">
<p>
うっかり順番を間違えたりするので。catch-allの星付きexpression(eg, *others)を使うか、namedtupleを使う。
</p>

<p>
namedtupleについては<a href="https://dbader.org/blog/writing-clean-python-with-namedtuples">ここ</a>の説明がわかりやすかったです。(逆にIntroducing Pythonの説明はさっぱり。。。) 以下のように使います。
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">from</span> collections <span style="font-weight: bold;">import</span> namedtuple
<span style="font-weight: bold; font-style: italic;">Car</span> = namedtuple(<span style="font-style: italic;">'Car'</span>, <span style="font-style: italic;">'color milage'</span>)
&#12414;&#12383;&#12399;
<span style="font-weight: bold; font-style: italic;">Car</span> = namedtuple(<span style="font-style: italic;">'Car'</span>, [<span style="font-style: italic;">'color'</span>, <span style="font-style: italic;">'milage'</span>])
</pre>
</div>
<p>
前者の文字列部分(<code>'color milage'</code>)は内部で <code>split()</code> されてリストになるため、後者と等価だそうです。
</p>

<p>
メソッドの無いimmutableなクラスのように使えます。
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">my_car</span> = Car(<span style="font-style: italic;">'red'</span>, 3812.4)
</pre>
</div>
<p>
namedtupleは内部ではクラスとして表現されていますが、メモリ効率は良いそうです。
</p>


<p>
複数の値を返す関数は、それらをタプルにして返すことは知りませんでした。関数の呼び出し元が複数の変数にunpackする時にタプルから取り出します。
</p>

<p>
もう一つ。日本語ではあまり馴染みがありませんが、英語ではよく使うmaiden(中央値)。要素が偶数の場合にどうするのか知りませんでした。真ん中の二つの平均を取るのですか。
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">if</span> count % 2 == 0:
    <span style="font-weight: bold; font-style: italic;">lower</span> = sorted_numbers[middle - 1]
    <span style="font-weight: bold; font-style: italic;">upper</span> = sorted_numbers[middle]
    <span style="font-weight: bold; font-style: italic;">median</span> = (lower + upper) / 2
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd85c8a7" class="outline-3">
<h3 id="orgd85c8a7"><span class="section-number-3">1.2</span> Item 20: Noneを返すくらいなら例外を上げよ</h3>
<div class="outline-text-3" id="text-1-2">
<p>
<code>None</code> や0, 空の文字列, etc.は全て <code>False</code> と解釈されるので、if文などでの判定でうっかり間違いやすい。
</p>

<p>
適切な例外(そのままでなく)を上げて、それをドキュメントに書く。更にtype annotationsする。
</p>
<pre class="example">
def careful_divide(a: float, b: float) -&gt; float:
    """Divides a by b.

    Raises:
	ValueError: When the inputs cannot be divided.
    """"
    try:
	return a / b
    except ZeroDivisionError as e:
	raise ValueError('Invalid inputs')
</pre>
</div>
</div>

<div id="outline-container-org4f63527" class="outline-3">
<h3 id="org4f63527"><span class="section-number-3">1.3</span> Item 21: Closuresが変数のスコープにどう影響するかを知っておけ</h3>
<div class="outline-text-3" id="text-1-3">
<p>
えーっと、closuresって何でしたっけ? Introducing Pythonを読んだときに消化不良のまま終わったような気が。。
</p>

<p>
30分ほど調べてみました。<a href="https://www.programiz.com/python-programming/closure">ここ</a>の定義が一番しっくり来ました。
</p>
<ul class="org-ul">
<li>関数と、そのインナー関数がある</li>
<li>インナー関数は、外側の関数で定義された変数を参照する</li>
<li>外側の関数は、インナー関数を戻り値として返す</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">def</span> <span style="font-weight: bold;">print_msg</span>(msg):
    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">printer</span>():    <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">inner function</span>
        <span style="font-weight: bold;">print</span>(msg)    <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">msg was defined in the enclosing function</span>
    <span style="font-weight: bold;">return</span> printer    <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">return the inner function</span>
</pre>
</div>
<p>
これを使うには、
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">another</span> = print_msg(<span style="font-style: italic;">"Hello"</span>)
another()
&gt;&gt;&gt;
Hello
</pre>
</div>

<p>
メリットの説明は<a href="http://www.trytoprogram.com/python-programming/python-closures/">ここ</a>がわかりやすかったです。
</p>
<ul class="org-ul">
<li>コールバックとして定義されるため、ある意味データ隠蔽(hiding)に使える</li>
<li>ハードコードされた定数や文字列の代わりに使える</li>
<li>コードに関数が1, 2個しかないときに有効</li>
</ul>

<p>
この節では、やたらと小難しい具体例が続きますが、言っていることは単純です: インナー関数でアサインしている変数のスコープは、インナー関数で閉じる(ie, 外側の関数に届かない)。そして、もし外側の関数にスコープを広げたい場合は <code>nonlocal</code> を付けます。
</p>

<p>
この <code>nonlocal</code> の使い方にも注意が必要で、長い関数だと <code>nonlocal</code> であることがわかりづらくなります。単純な関数以外ではヘルパークラスにするのがよい、とのこと。
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">SomeClass</span>:
    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">__call__</span>(<span style="font-weight: bold;">self</span>, x, y):
<span style="font-weight: bold; font-style: italic;">sc</span> = SomeClass()
sc(5, 7)  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">__call__&#12364;&#20351;&#12431;&#12428;&#12427;</span>
</pre>
</div>
<p>
<code>__call__()</code> スペシャル関数は、クラスを関数であるかのように振る舞わせる関数。なお、この大事なところでKindle版は最後の <code>return (1, x)</code> のインデントがずれています。しかも、Click here to view code imageがここには何故か無い。どうしろと。。。
</p>
</div>
</div>

<div id="outline-container-org5da6a5c" class="outline-3">
<h3 id="org5da6a5c"><span class="section-number-3">1.4</span> Item 22: 可変数のpositional argumentsを使って見やすくしろ</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>可変長の引数(0個含む)は関数の定義def文において <code>*args</code> のようにアスタリスク付きで書くことで実現できる</li>
<li>関数の呼び出し側で、 <code>*vars</code> としてアスタリスクを付けて引数を指定することで、リスト等のシーケンスの中身を(展開して)渡せる</li>
</ul>

<p>
二つ目において、呼び出し側がgeneratorにアスタリスクを付けると、呼び出しのたびにgeneratorを全て展開してしまうため、メモリ圧迫＆クラッシュに注意、とのことです。
</p>
</div>
</div>

<div id="outline-container-org90d4f7c" class="outline-3">
<h3 id="org90d4f7c"><span class="section-number-3">1.5</span> Item 23: オプションとなる挙動はキーワード引数で与えよ</h3>
<div class="outline-text-3" id="text-1-5">
<p>
ここは特にコメントなしです。
</p>
</div>
</div>

<div id="outline-container-org5793923" class="outline-3">
<h3 id="org5793923"><span class="section-number-3">1.6</span> Item 24: 動的なデフォルト引数を指定するときはNoneとDocstringsを使え</h3>
<div class="outline-text-3" id="text-1-6">
<p>
例:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">def</span> <span style="font-weight: bold;">log</span>(message, when=<span style="font-weight: bold; text-decoration: underline;">None</span>):
    &#8220;&#8220;&#8220;Log a message <span style="font-weight: bold;">with</span> a timestamp.
    Args:
        message: Message to <span style="font-weight: bold;">print</span>.
        when: datetime of when the message occurred.
            Defaults to the present time.
    &#8221;&#8221;&#8221;
    <span style="font-weight: bold;">if</span> when <span style="font-weight: bold;">is</span> <span style="font-weight: bold; text-decoration: underline;">None</span>:
        <span style="font-weight: bold; font-style: italic;">when</span> = datetime.now()
    <span style="font-weight: bold;">print</span>(f<span style="font-style: italic;">'{when}: {message}'</span>)
</pre>
</div>

<p>
上の関数において、whenのデフォルトはNoneとしておき、関数の中で現在時刻を設定しています。def文で <code>when=datetime.now()</code> を書いても機能しないのは、 <code>datetime.now()</code> が評価されるのが関数のロード時のみだからです。同様に、 <code>{}</code> , <code>[]</code> のような動的な値を使うときにも <code>None</code> をデフォルト値として置きます。
</p>
</div>
</div>

<div id="outline-container-orgd40661e" class="outline-3">
<h3 id="orgd40661e"><span class="section-number-3">1.7</span> Item 25: キーワードオンリー引数、位置オンリー引数を使って、明確さを強制せよ</h3>
<div class="outline-text-3" id="text-1-7">
<p>
<code>float('inf')</code> は無限大を意味するそうです。
</p>

<p>
引数リストにあるアスタリスク <code>*</code> は、位置引数の終わりと、キーワードオンリー引数の始まりを強制します。また、Python 3.8より、引数リストにある <code>/</code> は、これよりも前の引数は位置オンリー引数であることを強制します。例えば、
</p>
<pre class="example">
def func(num, div, /, *, ov_flag=False, zd_flag=True):
</pre>

<p>
とあったときに、
</p>
<pre class="example">
func(10, 2, True, False)
func(num=10, div=2)
</pre>

<p>
などと呼び出すとTypeErrorとなります。
</p>

<p>
<code>/</code> と <code>*</code> に挟まれた引数は、位置引数としてもキーワード引数としてもどちらでもよいそうです。これがPythonのデフォルトです。
</p>
</div>
</div>

<div id="outline-container-org777733c" class="outline-3">
<h3 id="org777733c"><span class="section-number-3">1.8</span> Item 26: 関数のデコレーターをfunctools.wrapsを使って定義せよ</h3>
<div class="outline-text-3" id="text-1-8">
<p>
コードスニップを見ていると、見慣れない表現が。。。
</p>
<pre class="example">
{args!r}
</pre>

<p>
この <code>!r</code> は、 <code>__repr__()</code> で解釈せよ、という意味だそうです。 f'This string {name!r} is a good one' のように使います。 <code>!r</code> は検索しづらいですね。。
</p>

<p>
この項目は難しいです。ぱっと読んでも意味がよくわかりません。decoratorの問題らしいので検索してみます。<a href="https://lerner.co.il/2019/05/05/making-your-python-decorators-even-better-with-functool-wraps/">ここ</a>の説明がわかりやすかったです。なるほど、 <code>__name__</code> や <code>__doc__</code> を表示したり <code>help()</code> を使うと、wrapper関数の情報が表示されてしまうようです。
</p>

<p>
その解決策がfunctools.wrapsを使うことで、
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">from</span> functools <span style="font-weight: bold;">import</span> wraps

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">mydeco</span>(func):
    <span style="font-weight: bold; text-decoration: underline;">@wraps</span>(func)
    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">wrapper</span>(*args, *kwargs):
        <span style="font-weight: bold;">return</span> f<span style="font-style: italic;">'{func(args, **kwargs)}!!!'</span>
    <span style="font-weight: bold;">return</span> wrapper
</pre>
</div>
<p>
こうすると
</p>
<blockquote>
<p>
By applying this “wraps” decorator to our inner function, we copy over func’s name, docstring, and signature to our inner function, avoiding the issues that we had seen before:
</p>
</blockquote>
<p>
そういうことでしたか。
</p>

<p>
デコレーターについて補足します。上記code snippetは以下と等価です。
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">from</span> functools <span style="font-weight: bold;">import</span> wraps

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">mydeco</span>(func):
    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">wrapper</span>(*args, *kwargs):
        <span style="font-weight: bold;">return</span> f<span style="font-style: italic;">'{func(args, **kwargs)}!!!'</span>
    <span style="font-weight: bold;">return</span> wrapper
<span style="font-weight: bold; font-style: italic;">func</span> = mydeco(func)
</pre>
</div>
<p>
最後の行で、 <code>mydeco</code> はインナー関数 <code>wrapper</code> を返すので、以降 <code>func()</code> を呼ぶとインナー関数 <code>wrapper()</code> が呼ばれることになります。
</p>
</div>
</div>
</div>

<div id="outline-container-orgfb1bf2c" class="outline-2">
<h2 id="orgfb1bf2c"><span class="section-number-2">2</span> Chapter 4: Comprehensionsとジェネレーター</h2>
<div class="outline-text-2" id="text-2">
<p>
<a href="https://jeffknupp.com/blog/2013/04/07/improve-your-python-yield-and-generators-explained/#:~:text=A%20Python%20generator%20is%20a,as%20the%20%22generated%22%20value.">ここ</a>を参考にして、ジェネレーターについて整理します。(このリンクはかなり詳細に説明しています)
</p>
<ul class="org-ul">
<li>ジェネレーター関数は、 <code>return</code> の代わりに <code>yield</code> を持つ関数で、ジェネレーター(=ジェネレーターiterator)を作る。</li>
<li>ジェネレーターは特定のタイプのiterator。iteratorとして機能するために、ジェネレーターは <code>__next__()</code> メソッドを持つ。</li>
<li>ジェネレーターから次の値を得るには、iterators: <code>next()</code> を使う。( <code>next()</code> は <code>__next__()</code> メソッドを呼ぶ)</li>
<li>ジェネレーターは <code>next()</code> の呼び主に対して、 <code>yield</code> 文で値を返す。</li>
</ul>

<p>
ジェネレーターの使い方
</p>
<ul class="org-ul">
<li>一通りたどるとジェネレーターは <code>StopIteration</code> 例外を上げる。これは普通のiteratorと同じ挙動で、for文などでは問題視せずにサイレントに抜ける。</li>
<li>その後、もう一度ジェネレーターを呼ぶと <code>StopIteration</code> 例外を上げる。</li>
<li>ジェネレーター関数をもう一度呼んで、新たなジェネレーターを作り直すことができる。</li>
</ul>
</div>


<div id="outline-container-orgcd3a1a4" class="outline-3">
<h3 id="orgcd3a1a4"><span class="section-number-3">2.1</span> Item 27: mapとfilterの代わりにcomprehensionsを使え</h3>
<div class="outline-text-3" id="text-2-1">
<p>
<code>map()</code> ビルトイン関数は知りませんでした。<a href="https://www.geeksforgeeks.org/python-map-function/">ここ</a>によると、第二引数のiterable(例: リスト)の各アイテムに、第一引数の関数を適用して、iterableなmapオブジェクトを返す、とのこと。
</p>
<pre class="example">
mapobj = map(lambda x: x ** 2, somelist)
</pre>


<p>
<code>filter</code> ビルトイン関数も知りませんでしたが、名前から明らかです。
</p>
<pre class="example">
filter(lambda x: x % 2 == 0, somelist)
</pre>

<p>
<code>filter</code> もフィルターされたiteratorを返します。
</p>

<p>
両方とも返すのはiteratorですが、リストcomprehensionsと似てますね。
</p>

<p>
<code>map</code> と <code>filter</code> を組み合わせると読みづらいので、スッキリとかけるcomprehensionsを使え、ということでした。 <code>somelist</code> の中から2で割りきれる要素のみ2乗したいとき、
</p>
<pre class="example">
map(lambda x: x**2, filter(lambda x: x % 2 == 0, somelist))
</pre>

<p>
これが、
</p>
<pre class="example">
[x**2 for x in somelist if x % 2 == 0]
</pre>

<p>
。。。確かに。
</p>
</div>
</div>

<div id="outline-container-orgd00ae44" class="outline-3">
<h3 id="orgd00ae44"><span class="section-number-3">2.2</span> Item 28: 3つ以上のコントロールsubexpressionsをcomprehensionsで使うな</h3>
<div class="outline-text-3" id="text-2-2">
<p>
初級者的にキツい表現が出ました。やりたいことは、二次元にネストされたリストであるmatrixの中身をflattenする(一次元にする)、です。えーと、ネストされた <code>for</code> は左から解釈するらしいので、、
</p>
<pre class="example">
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flat = [x for row in matrix for x in row]
</pre>

<p>
最初の <code>for</code> で <code>matrix</code> の各アイテム= <code>row</code> を取り出して、次の <code>for</code> で <code>row</code> の中の <code>x</code> を取り出し、これを使ってリストを作る、ということでした。
</p>
<pre class="example">
print(flat)
&gt;&gt;&gt;
[1, 2, 3, 4, 5, 6, 7, 8, 9]
</pre>

<p>
これは便利そうです。
</p>

<p>
次は、先ほど <code>matrix</code> の要素を二乗する(flattenしない)場合。
</p>
<pre class="example">
squared = [[x ** 2 for x in row] for row in matrix]
print(squared)
&gt;&gt;&gt;
[[1, 4, 9], [16, 25, 36], [49, 64, 81]]
</pre>

<p>
このリストcomprehensionのリストが二重になっているので、flattenしないのですね。
</p>

<p>
お題のコントロールsubexpressionsは、 <code>for</code> によるループだけでなく、 <code>for</code> に付けられる <code>if</code> も指していました。下の例は <code>for</code> が二つと <code>if</code> があるのでアウト。
</p>
<pre class="example">
[x for wor in matrix for x in row if x % 2 == 0]
</pre>
</div>
</div>

<div id="outline-container-orga29991c" class="outline-3">
<h3 id="orga29991c"><span class="section-number-3">2.3</span> Item 29: Assignment表現を使って、comprehensions内での繰り返しを避けよ</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Assignment expressions - Walrusのやつです(<code>:=</code>)。これは便利なので、是非とも使っていきたいと思います。
</p>

<p>
次のようなストックがあって、
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">stock</span> = {
    <span style="font-style: italic;">'nails'</span>: 125,
    <span style="font-style: italic;">'screws'</span>: 35,
    <span style="font-style: italic;">'wingnuts'</span>: 8,
    <span style="font-style: italic;">'washers'</span>: 24,
}
</pre>
</div>
<p>
次のようなオーダー(8個単位とする)が来た場合について考えます。
</p>
<pre class="example">
order = ['screws', 'wingnuts', 'clips']
</pre>


<p>
ディクショナリcomprehensionを使って、次のように書くと良いです。
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">def</span> <span style="font-weight: bold;">get_batches</span>(count, size):
    <span style="font-weight: bold;">return</span> count // size

<span style="font-weight: bold; font-style: italic;">found</span> = {name: batches <span style="font-weight: bold;">for</span> name <span style="font-weight: bold;">in</span> order
    <span style="font-weight: bold;">if</span> (batches := get_batches(stock.get(name, 0), 8))}
</pre>
</div>
<p>
<code>get_batches</code> を使って、8個のセットが何セットあるかを求めています。
ポイントWalrusを使って <code>get_batches</code> の実行をif節の中で1回だけ使っているところ。
</p>
<pre class="example">
print(found)
&gt;&gt;&gt;
{'screws': 4, 'wingnuts': 1}
</pre>


<p>
知りませんでした、generator expressions。<a href="https://dbader.org/blog/python-generator-expressions">ここ</a>の説明がわかりやすかったです。まずは似たようなリストcomprehension:
</p>
<pre class="example">
listcomp = ['Hello' for i in range(3)]
</pre>

<p>
これがジェネレーターexpression:
</p>
<pre class="example">
genexpr = ('Hello' for i in range(3))
</pre>

<p>
後者が返すのはジェネレーターです。
</p>
<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; <span style="font-weight: bold;">next</span>(genexpr)
<span style="font-style: italic;">'Hello'</span>
&gt;&gt;&gt; <span style="font-weight: bold;">next</span>(genexpr)
<span style="font-style: italic;">'Hello'</span>
&gt;&gt;&gt; <span style="font-weight: bold;">next</span>(genexpr)
<span style="font-style: italic;">'Hello'</span>
&gt;&gt;&gt; <span style="font-weight: bold;">next</span>(genexpr)
<span style="font-weight: bold; text-decoration: underline;">StopIteration</span>
</pre>
</div>

<p>
先ほどの例はジェネレーターexpressionを使っても書けます。
</p>
<pre class="example">
found = ((name, batches) for name in order 
    if (batches := get_batches(stock.get(name, 0), 8)))
</pre>

<p>
もちろん、返るのはジェネレーター。
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">print</span>(<span style="font-weight: bold;">next</span>(found))
<span style="font-weight: bold;">print</span>(<span style="font-weight: bold;">next</span>(found))
&gt;&gt;&gt;
(<span style="font-style: italic;">'screws'</span>, 4)
(<span style="font-style: italic;">'wingnuts'</span>, 1)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf5605cb" class="outline-3">
<h3 id="orgf5605cb"><span class="section-number-3">2.4</span> Item 30: リストを返すくらいならジェネレーターを考慮せよ</h3>
<div class="outline-text-3" id="text-2-4">
<p>
お、なんだか今更ジェネレーターの説明がありました。どうしてジェネレーターexpressionsを説明なしで使った後にこれが来るかな。。。
</p>

<p>
この本は、どこから読んでも良いと謳っていますが、逆に、最初から読もうが途中から読もうが読みづらさは変わらない、という残念なことになっていると思います。
</p>
</div>
</div>

<div id="outline-container-org9331f40" class="outline-3">
<h3 id="org9331f40"><span class="section-number-3">2.5</span> Item 31: 引数をたどるときには保守的になれ</h3>
<div class="outline-text-3" id="text-2-5">
<p>
1カ所、どうしてもわからないところがありました。
</p>
<pre class="example">
percentages = normalize_func(lambda: read_visits(path))
</pre>

<p>
<code>read_visits()</code> はgenerator関数です。
</p>

<pre class="example">
def read_visits(data_path):
    with open(data_path) as f:
        for line in f:
            yield int(line)
</pre>


<p>
これに <code>lambda</code> が付くとどうなるのでしょう???本文には次のように書いてあります。
</p>
<blockquote>
<p>
To use normalize_func, I can pass in a lambda expression that calls the generator and produces a new iterator each time.
</p>
</blockquote>

<p>
ジェネレーター関数は呼び出すとジェネレーターiteratorを返してくるので、それを <code>lambda</code> が関数にしてくるのでしょうか。-&gt; 違うような。ジェネレーターiteratorをそのまま返して <code>normalize_func</code> に渡すのかな。-&gt;そうでした(下のコード)。どうしてlambdaが無いといけないのでしょう???
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">def</span> <span style="font-weight: bold;">normalize_func</span>(get_iter):
    <span style="font-weight: bold; font-style: italic;">total</span> = <span style="font-weight: bold;">sum</span>(get_iter())   <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">New iterator</span>
    <span style="font-weight: bold; font-style: italic;">result</span> = []
    <span style="font-weight: bold;">for</span> value <span style="font-weight: bold;">in</span> get_iter():  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">New iterator</span>
        <span style="font-weight: bold; font-style: italic;">percent</span> = 100 * value / total
        result.append(percent)
    <span style="font-weight: bold;">return</span> result
</pre>
</div>

<p>
ただ、お勧めのやり方はこれではなく、自分で <code>__iter__()</code> メソッドを書いたクラスを用意することでした。このメソッドはジェネレーターでなくてはならず、iteratorを返します。
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">ReadVisits</span>:
    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">__init__</span>(<span style="font-weight: bold;">self</span>, data_path):
        <span style="font-weight: bold;">self</span>.data_path = data_path

    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">__iter__</span>(<span style="font-weight: bold;">self</span>):
        <span style="font-weight: bold;">with</span> <span style="font-weight: bold;">open</span>(<span style="font-weight: bold;">self</span>.data_path) <span style="font-weight: bold;">as</span> f:
            <span style="font-weight: bold;">for</span> line <span style="font-weight: bold;">in</span> f:
                yeild <span style="font-weight: bold;">int</span>(line)
</pre>
</div>
<p>
iteratorを返す <code>__iter__()</code> メソッドを持つクラスを用意することで、このクラスをfor文などでiterateすることが可能です。
</p>

<p>
この節は消化不良気味なので、後でまた読まないと。。。
</p>
</div>
</div>

<div id="outline-container-org1c7459f" class="outline-3">
<h3 id="org1c7459f"><span class="section-number-3">2.6</span> Item 32: 大きなリストcomprehensionsの代わりにジェネレーターexpressionsを考えよ</h3>
<div class="outline-text-3" id="text-2-6">
<p>
(今更ですが)ジェネレーターexpressionsの説明でした。その戻り値であるiteratorを入力とした、ジェネレーターexpressionsのネスト(?)も可能。
</p>
<pre class="example">
it = (len(x) for x in open('my_file.txt'))
roots = ((x, x**0.5) for x in it)
</pre>
</div>
</div>

<div id="outline-container-orgf600043" class="outline-3">
<h3 id="orgf600043"><span class="section-number-3">2.7</span> Item 33: yield fromを使って複数のジェネレーターを組み合わせよ</h3>
<div class="outline-text-3" id="text-2-7">
<p>
<code>yield from</code> です。for文で <code>yield</code> を回すところを <code>yeild from</code> とシンプルに書ける、くらいの説明でしたが、奥が深そうです。もう少し調べてみたところ、<a href="https://lerner.co.il/2020/05/08/making-sense-of-generators-coroutines-and-yield-from-in-python/">ここ</a>の説明が非常にわかりやすかったです。
</p>

<p>
まずはcoroutinesから。これはPythonのジェネレーターにある <code>yield</code> をサポートしているサブルーチン的なもので、 <code>yield</code> 文で(自分のステートを保持したまま)呼び主に戻し、再度呼ばれたら <code>yield</code> の次から実行を再開します。
</p>

<p>
これが何を意味するかというと、coroutineを呼び出し＆そこから戻ることで、まるでスレッド間でコンテキストスイッチをしているように振る舞う、ということです。呼び出し側もcoroutineもお互いに自分のステートを忘れずに「コンテキストスイッチ」できます。ジェネレーターはcoroutine(的なもの?)で、これはなかなかすごい機能のような気がしてきました。
</p>

<p>
次に <code>send()</code> メソッドについてです。これは <code>yield</code> してから再開する際に、呼び主から引数を受け取る仕組みです。単に <code>yield x</code> のように書いていたところを
</p>
<pre class="example">
y = yield x
</pre>

<p>
のように書きます。呼び出し側も <code>next(generator)</code> でなく、
</p>
<pre class="example">
generator.send("Hello")
</pre>

<p>
と書きます。ただし、最初にジェネレーターを実行する時だけは、まだ <code>yield</code> 文に来ていないため、これまで通りnext(generator)で呼び出します。
</p>

<p>
そして、 <code>yield from</code> です。こいつの真の(裏の?)目的は、ジェネレーターから別のサブジェネレーターに機能をオフロードすることです。そしてその際に、元のジェネレーターが <code>send()</code> で受け取った引数をサブジェネレーターにそのまま渡します。
</p>
<pre class="example">
def generator():
   ...
   yield from subgenerator()
</pre>

<p>
この <code>yield</code> 文に制御がいる(実行する行がここである)際に
</p>
<pre class="example">
generator.send('hello')
</pre>

<p>
とすると、 <code>'hello'</code> が <code>subgenerator()</code> に渡ります。
</p>

<p>
うーん、奥が深い。
</p>
</div>
</div>

<div id="outline-container-org1b150b7" class="outline-3">
<h3 id="org1b150b7"><span class="section-number-3">2.8</span> Item 34: ジェネレーターにsendを使ってデータを送ってはいけない</h3>
<div class="outline-text-3" id="text-2-8">
<p>
えー、前の項目で何とか理解したばかりだというのに、 <code>send()</code> を使うなと言っています。初心者にわかりづらいのと、 <code>yield from</code> を使って初回に <code>None</code> が返るケースでびっくりすることがあるため。
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">def</span> <span style="font-weight: bold;">wave_modulating</span>(steps):
    <span style="font-weight: bold; font-style: italic;">step_size</span> = 2 * math.pi / steps
    <span style="font-weight: bold; font-style: italic;">amplitude</span> = <span style="font-weight: bold;">yield</span>    <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Receive initial amplitude</span>
    <span style="font-weight: bold;">for</span> step <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(steps):
        <span style="font-weight: bold; font-style: italic;">radians</span> = step * step_size
        <span style="font-weight: bold; font-style: italic;">fraction</span> = math.sin(radians)
        <span style="font-weight: bold; font-style: italic;">output</span> = amplitude * fraction
        <span style="font-weight: bold; font-style: italic;">amplitude</span> = <span style="font-weight: bold;">yield</span> output  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Receive next amplitude</span>
</pre>
</div>
<p>
上記で、最初にamplitudeの初期値を受け取るところが、yield fromするとNoneが返る箇所です。これを、 <code>send()</code> を使わずに、iteratorを引数で渡しておくようにします。関数の名前が示すように、ジェネレーターのカスケードになります。
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">def</span> <span style="font-weight: bold;">wave_cascading</span>(amplitude_it, steps):
    <span style="font-weight: bold; font-style: italic;">step_size</span> = 2 * math.pi / steps
    <span style="font-weight: bold;">for</span> step <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(steps):
        <span style="font-weight: bold; font-style: italic;">radians</span> = step * step_size
        <span style="font-weight: bold; font-style: italic;">fraction</span> = math.sin(radians)
        <span style="font-weight: bold; font-style: italic;">amplitude</span> = <span style="font-weight: bold;">next</span>(amplitude_it)  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Get next input</span>
        <span style="font-weight: bold; font-style: italic;">output</span> = amplitude * fraction
        <span style="font-weight: bold;">yield</span> output
</pre>
</div>
<p>
こうします。そして、
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">def</span> <span style="font-weight: bold;">complex_cascading</span>(amplitude_it):
    <span style="font-weight: bold;">yield</span> <span style="font-weight: bold;">from</span> wave_cascading(amplitude_it, 3)
    <span style="font-weight: bold;">yield</span> <span style="font-weight: bold;">from</span> wave_cascading(amplitude_it, 4)
    <span style="font-weight: bold;">yield</span> <span style="font-weight: bold;">from</span> wave_cascading(amplitude_it, 5)
</pre>
</div>
<p>
ところで、上の <code>yield from</code> 3行を1行にまとめればいいのに。こんな感じで:
</p>
<pre class="example">
yield from wave_cascading(amplitude_it, 12)
</pre>

<p>
としばらく悩みましたが、 <code>step_size</code> が変わってしまうので駄目でしたね。
そして更に、
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">def</span> <span style="font-weight: bold;">run_cascading</span>():
    <span style="font-weight: bold; font-style: italic;">amplitudes</span> = [7, 7, 7, 2, 2, 2, 2, 10, 10, 10, 10, 10]
    <span style="font-weight: bold; font-style: italic;">it</span> = complex_cascading(<span style="font-weight: bold;">iter</span>(amplitudes))
    <span style="font-weight: bold;">for</span> amplitude <span style="font-weight: bold;">in</span> amplitudes:
        <span style="font-weight: bold; font-style: italic;">output</span> = <span style="font-weight: bold;">next</span>(it)
        transmit(output)
</pre>
</div>
<p>
うーん、わかりやすいですかね。初心者的には若干厳しいです。。。
</p>
</div>
</div>

<div id="outline-container-org1c7e54d" class="outline-3">
<h3 id="org1c7e54d"><span class="section-number-3">2.9</span> Item 35: throwで例外を投げてジェネレータの状態遷移を起こすな</h3>
<div class="outline-text-3" id="text-2-9">
<p>
<code>throw</code> を使う駄目な例:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">def</span> <span style="font-weight: bold;">run</span>():
    <span style="font-weight: bold; font-style: italic;">it</span> = timer(4)
    <span style="font-weight: bold;">while</span> <span style="font-weight: bold; text-decoration: underline;">True</span>:
        <span style="font-weight: bold;">try</span>:
            <span style="font-weight: bold;">if</span> check_for_reset():
                <span style="font-weight: bold; font-style: italic;">current</span> = it.throw(Reset())  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">&#33258;&#20998;&#12391;&#20363;&#22806;&#12434;&#25237;&#12370;&#12390;&#12356;&#12427;</span>
            <span style="font-weight: bold;">else</span>:
                <span style="font-weight: bold; font-style: italic;">current</span> = <span style="font-weight: bold;">next</span>(it)  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">&#12371;&#12371;&#12391;&#20363;&#22806;&#12364;&#30330;&#29983;&#12377;&#12427;&#21487;&#33021;&#24615;&#12354;&#12426;</span>
        <span style="font-weight: bold;">except</span> <span style="font-weight: bold; text-decoration: underline;">StopIteration</span>:
            <span style="font-weight: bold;">break</span>
        <span style="font-weight: bold;">else</span>:  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">&#20363;&#22806;&#12364;&#30330;&#29983;&#12375;&#12394;&#12363;&#12387;&#12383;&#12425;</span>
            announce(current)
</pre>
</div>
<p>
何だか、何がしたいのかよくわかりません。。。。ので調べます。<a href="https://stackoverflow.com/questions/11485591/what-is-generator-throw-good-for">ここ</a>によると、 <code>it.throw()</code> はit内部で例外を発生させるようです。 <code>it</code> の <code>Reset()</code> 例外ハンドラーでタイマーをリセットしているのかな。確かに、少し読みづらいですかね。
</p>

<p>
ジェネレーターの <code>__iter__()</code> を持つクラスを用意して <code>run()</code> を書き換えます。
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Timer</span>:
    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">__init__</span>(<span style="font-weight: bold;">self</span>, period):
        <span style="font-weight: bold;">self</span>.current = period
        <span style="font-weight: bold;">self</span>.period = period

    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">reset</span>(<span style="font-weight: bold;">self</span>):
        <span style="font-weight: bold;">self</span>.current = <span style="font-weight: bold;">self</span>.period

    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">__iter__</span>(<span style="font-weight: bold;">self</span>):
        <span style="font-weight: bold;">while</span> <span style="font-weight: bold;">self</span>.current:
            <span style="font-weight: bold;">self</span>.current -= 1
            <span style="font-weight: bold;">yield</span> <span style="font-weight: bold;">self</span>.current
</pre>
</div>
<p>
<code>run()</code> 関数はずっとシンプルになります。
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">def</span> <span style="font-weight: bold;">run</span>():
    <span style="font-weight: bold; font-style: italic;">timer</span> = Timer(4)
    <span style="font-weight: bold;">for</span> current <span style="font-weight: bold;">in</span> timer:
        <span style="font-weight: bold;">if</span> check_for_reset():
            timer.reset()
        announce(current)
</pre>
</div>
</div>
</div>

<div id="outline-container-orge53ff4e" class="outline-3">
<h3 id="orge53ff4e"><span class="section-number-3">2.10</span> Item 36: Iteratorやジェネレーターを使うときにはitertoolsの使用を検討せよ</h3>
<div class="outline-text-3" id="text-2-10">
<p>
itertoolsには便利な関数がたくさんあるので使うとよい、という節でした。
</p>
</div>

<div id="outline-container-orgc96fef1" class="outline-4">
<h4 id="orgc96fef1"><span class="section-number-4">2.10.1</span> Iteratorsをつなぐ</h4>
<div class="outline-text-4" id="text-2-10-1">
</div>
<ol class="org-ol">
<li><a id="org2a60fc0"></a>chain<br />
<div class="outline-text-5" id="text-2-10-1-1">
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">it</span> = itertools.chain([1, 2, 3], [4, 5, 6])
<span style="font-weight: bold;">print</span>(<span style="font-weight: bold;">list</span>(it))
&gt;&gt;&gt;
[1, 2, 3, 4, 5, 6]
</pre>
</div>
</div>
</li>
<li><a id="orgb9d7543"></a>repeat<br />
<div class="outline-text-5" id="text-2-10-1-2">
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">it</span> = itertools.repeat(<span style="font-style: italic;">'hello'</span>, 3)
<span style="font-weight: bold;">print</span>(<span style="font-weight: bold;">list</span>(it))
&gt;&gt;&gt;
[<span style="font-style: italic;">'hello'</span>, <span style="font-style: italic;">'hello'</span>, <span style="font-style: italic;">'hello'</span>]
</pre>
</div>

<p>
もっと簡単な方法はないのでしょうか。実験してみます。
</p>
<pre class="example">
&gt;&gt;&gt; 'hello' * 3
'hellohellohello'
&gt;&gt;&gt; ['hello' * 3]
['hellohellohello']
&gt;&gt;&gt; list('hello' * 3)
['h', 'e', 'l', 'l', 'o', 'h', 'e', 'l', 'l', 'o', 'h', 'e', 'l', 'l', 'o']
</pre>
</div>
</li>

<li><a id="org2860480"></a>cycle<br />
<div class="outline-text-5" id="text-2-10-1-3">
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">it</span> = itertools.cycle([1, 2])
<span style="font-weight: bold; font-style: italic;">result</span> = [<span style="font-weight: bold;">next</span>(it) <span style="font-weight: bold;">for</span> _ <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(10)]
<span style="font-weight: bold;">print</span>(result)
&gt;&gt;&gt;
[1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
</pre>
</div>
</div>
</li>
<li><a id="orgc108863"></a>tee - iteratorを指定個数に分割して並列実行<br />
<div class="outline-text-5" id="text-2-10-1-4">
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">it1</span>, <span style="font-weight: bold; font-style: italic;">it2</span>, <span style="font-weight: bold; font-style: italic;">it3</span> = itertools.tee([<span style="font-style: italic;">'first'</span>, <span style="font-style: italic;">'second'</span>], 3)
<span style="font-weight: bold;">print</span>(<span style="font-weight: bold;">list</span>(it1))
<span style="font-weight: bold;">print</span>(<span style="font-weight: bold;">list</span>(it2))
<span style="font-weight: bold;">print</span>(<span style="font-weight: bold;">list</span>(it3))
&gt;&gt;&gt;
[<span style="font-style: italic;">'first'</span>, <span style="font-style: italic;">'second'</span>]
[<span style="font-style: italic;">'first'</span>, <span style="font-style: italic;">'second'</span>]
[<span style="font-style: italic;">'first'</span>, <span style="font-style: italic;">'second'</span>]
</pre>
</div>
</div>
</li>
<li><a id="org99f2339"></a>zip_longest - zipと似ているが、一番長いiteratorに合わせる。<br /></li>
</ol>
</div>

<div id="outline-container-orgb7a0d93" class="outline-4">
<h4 id="orgb7a0d93"><span class="section-number-4">2.10.2</span> Iteratorからアイテムをフィルタする</h4>
<div class="outline-text-4" id="text-2-10-2">
</div>
<ol class="org-ol">
<li><a id="org5195528"></a>islice - スライスする。ステップも指定可<br />
<div class="outline-text-5" id="text-2-10-2-1">
<pre class="example">
first_five = itertools.islice(values, 5)  # 最初の5個
mkddle_odds = itertools.islice(values, 2, 8, 2)  # 3番目からステップ2で7まで
</pre>
</div>
</li>
<li><a id="orgeb2cb69"></a>takewhile - 指定関数がFalseを返すまでtakeする<br />
<div class="outline-text-5" id="text-2-10-2-2">
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">values</span> = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
<span style="font-weight: bold; font-style: italic;">less_than_seven</span> = <span style="font-weight: bold;">lambda</span> x: x &lt; 7
<span style="font-weight: bold; font-style: italic;">it</span> = itertools.takewhile(less_than_seven, values)
<span style="font-weight: bold;">print</span>(<span style="font-weight: bold;">list</span>(it))
&gt;&gt;&gt;
[1, 2, 3, 4, 5, 6]
</pre>
</div>
</div>
</li>
<li><a id="org616ef3f"></a>dropwhile - takewhileの逆。指定関数がTrueを返すまでドロップする<br /></li>
<li><a id="org30db805"></a>filterfalse - filterの逆<br /></li>
</ol>
</div>

<div id="outline-container-org6de9414" class="outline-4">
<h4 id="org6de9414"><span class="section-number-4">2.10.3</span> 複数iteratorsのアイテムを結びつける</h4>
<div class="outline-text-4" id="text-2-10-3">
</div>
<ol class="org-ol">
<li><a id="org35b6665"></a>accumulate - 積算する<br />
<div class="outline-text-5" id="text-2-10-3-1">
<p>
二つ目の引数に関数を指定して、加工が可能。
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">values</span> = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
<span style="font-weight: bold; font-style: italic;">sum_reduce</span> = itertools.accumulate(values)
<span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'Sum: '</span>, <span style="font-weight: bold;">list</span>(sum_reduce))
&gt;&gt;&gt;
Sum: [1, 3, 6, 10, 15, 21, 28, 36, 45, 55]
<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">sum_modulo_20</span>(first, second):
    <span style="font-weight: bold;">return</span> (first + second) % 20
<span style="font-weight: bold; font-style: italic;">modulo_reduce</span> = itertools.accumulate(values, sum_modulo_20)
<span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'Modulo: '</span>, <span style="font-weight: bold;">list</span>(modulo_reduce))
&gt;&gt;&gt;
Modulo: [1, 3, 6, 10, 15, 1, 8, 16, 5, 15]
</pre>
</div>
<p>
後者のユースケースは、行列計算かな。
</p>
</div>
</li>

<li><a id="orga165523"></a>product - 直積(cartesian product)<br />
<div class="outline-text-5" id="text-2-10-3-2">
<p>
直積、デカルト積、cartesian積と呼ばれます。AとBの要素からそれぞれ一つずつ取ってきた作ったペアの集合です。学校で習った記憶があまりありません。。。
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">single</span> = itertools.product([1, 2], repeat=2)
<span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'Single: '</span>, <span style="font-weight: bold;">list</span>(single)
&gt;&gt;&gt;
Single: [(1, 2), (1, 2), (2, 1), (2, 2)]
multiple = itertools.product([1, 2], [<span style="font-style: italic;">'a'</span>, <span style="font-style: italic;">'b'</span>])
<span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'Multi: '</span>, <span style="font-weight: bold;">list</span>(multiple))
&gt;&gt;&gt;
Multi: [(1, <span style="font-style: italic;">'a'</span>), (1, <span style="font-style: italic;">'b'</span>), (2, <span style="font-style: italic;">'a'</span>), (2, <span style="font-style: italic;">'b'</span>)
</pre>
</div>
<p>
上の例でのrepeatは、自身で積を計算するときの個数を指定します。product(A, repeat=4)はproduct(A, A, A, A)と等価。
</p>
</div>
</li>

<li><a id="org88123aa"></a>permutations - 順列<br />
<div class="outline-text-5" id="text-2-10-3-3">
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">it</span> = itertools.permutations([1, 2, 3, 4], 2)
<span style="font-weight: bold;">print</span>(<span style="font-weight: bold;">list</span>(it))
&gt;&gt;&gt;
[(1, 2), (1, 3), (1, 4), (2, 1), (2, 3), (2, 4), 
 (3, 1), (3, 2), (3, 4), (4, 1), (4, 2), (4, 3)]
</pre>
</div>
</div>
</li>
<li><a id="org60a6e03"></a>combinations - 組み合わせ<br />
<div class="outline-text-5" id="text-2-10-3-4">
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">it</span> = itertools.combinations([1, 2, 3, 4], 2)
<span style="font-weight: bold;">print</span>(<span style="font-weight: bold;">list</span>(it))
&gt;&gt;&gt;
[(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]
</pre>
</div>
</div>
</li>
<li><a id="orgdf5c175"></a>combinations_with_replacement<br />
<div class="outline-text-5" id="text-2-10-3-5">
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">it</span> = itertools.combinations_with_replacement([1, 2, 3, 4], 2)
<span style="font-weight: bold;">print</span>(<span style="font-weight: bold;">list</span>(it))
&gt;&gt;&gt;
[(1, 1), (1, 2), (1, 3), (1, 4), (2, 2), (2, 3), (2, 4), 
 (3, 3), (3, 4), (4, 4)]
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
    <footer>
<p class="meta">
  <span class="byline author vcard">
    Posted by <span class="fn">
        きょうす
    </span>
  </span>
<time datetime="2020-08-18T00:00:00-04:00" pubdate>Tue 18 August 2020</time>  <span class="categories">
    <a class='category' href='/category/python.html'>Python</a>
  </span>
  <span class="categories">
    <a class="category" href="/tag/python.html">Python</a>  </span>
</p><div class="sharing">
</div>    </footer>
  </article>

</div>
<aside class="sidebar">
  <section>
    <h1>Recent Posts</h1>
    <ul id="recent_posts">
      <li class="post">
          <a href="/etf.html">ETFは何を買うか</a>
      </li>
      <li class="post">
          <a href="/charles.html">Charles Schwabの口座を開設しました</a>
      </li>
      <li class="post">
          <a href="/pronounce.html">googleの英語発音判定サービス</a>
      </li>
      <li class="post">
          <a href="/cookbooklist.html">Python Cookbookレシピリスト</a>
      </li>
      <li class="post">
          <a href="/bose500.html">Bose Home Speaker 500を買いました</a>
      </li>
    </ul>
  </section>
  <section>
      
    <h1>Categories</h1>
    <ul id="recent_posts">
        <li><a href="/category/blog.html">Blog</a></li>
        <li><a href="/category/english.html">English</a></li>
        <li><a href="/category/linux.html">Linux</a></li>
        <li><a href="/category/python.html">Python</a></li>
        <li><a href="/category/tech.html">Tech</a></li>
    </ul>
  </section>
 

  <section>
  <h1>Tags</h1>
    <a href="/tag/blog.html">Blog</a>,    <a href="/tag/investment.html">Investment</a>,    <a href="/tag/english.html">English</a>,    <a href="/tag/tech.html">Tech</a>,    <a href="/tag/python.html">Python</a>,    <a href="/tag/emacs.html">emacs</a>,    <a href="/tag/vacation.html">Vacation</a>,    <a href="/tag/linux.html">Linux</a>,    <a href="/tag/ying-yu.html">英語</a>,    <a href="/tag/ying-yu-jiao-yu.html">英語教育</a>,    <a href="/tag/ying-jian.html">英検</a>,    <a href="/tag/game.html">game</a>  </section>


    <section>
        <h1>Social</h1>
        <ul>
            <li><a href="http://twitter.com/kyos_achwan" target="_blank">Twitter</a></li>
            <li><a href="http://github.com/achiwa912" target="_blank">GitHub</a></li>
        </ul>
    </section>
    <section>
        <h1>Blogroll</h1>
        <ul>
            <li><a href="https://getpelican.com/" target="_blank">Pelican</a></li>
            <li><a href="https://www.python.org/" target="_blank">Python.org</a></li>
        </ul>
    </section>

<section>
    <p>Follow <a href="http://twitter.com/kyos_achwan">@kyos_achwan</a></p>
</section>
</aside>    </div>
  </div>
  <footer role="contentinfo"><p>
    Copyright &copy;  2020&ndash;2021  きょうす kyos &mdash;
  <span class="credit">Powered by <a href="http://getpelican.com">Pelican</a></span>
</p></footer>
  <script src="/theme/js/modernizr-2.0.js"></script>
  <script src="/theme/js/ender.js"></script>
  <script src="/theme/js/octopress.js" type="text/javascript"></script>
</body>
</html>