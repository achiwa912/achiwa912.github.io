<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Dreaming in Brookline, MA 02445 - Python</title><link href="http://achiwa912.github.io/" rel="alternate"></link><link href="http://achiwa912.github.io/feeds/python.atom.xml" rel="self"></link><id>http://achiwa912.github.io/</id><updated>2021-12-03T00:00:00-05:00</updated><entry><title>アメリカから日本に自作ポストカードを送る</title><link href="http://achiwa912.github.io/addadrs.html" rel="alternate"></link><published>2021-11-27T00:00:00-05:00</published><updated>2021-11-30T00:00:00-05:00</updated><author><name>きょうす</name></author><id>tag:achiwa912.github.io,2021-11-27:/addadrs.html</id><summary type="html">Sending postcards from the US</summary><content type="html">&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org02888c2"&gt;1. はじめに&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org78256fa"&gt;2. Avery 8386&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgd20d123"&gt;3. Avery Webサービス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org0e9e6ab"&gt;4. 宛先リスト&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgd579cfc"&gt;5. 日本語フォントの扱い&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org489a95a"&gt;6. Pythonスクリプト&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org39ed6b3"&gt;7. 使い方&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgc2383c6"&gt;8. 印刷&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org9bd3229"&gt;9. 宛名面レイアウト&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgf1f64de"&gt;10. 切手を貼る&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgba23fd0"&gt;11. 終わりに&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org02888c2" class="outline-2"&gt;
&lt;h2 id="org02888c2"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; はじめに&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
今年は転職及び引越しのご挨拶にグリーティングカードを出すことにしました。
日本にいたときには郵便局の「はがきデザインキットWeb版」で年賀状を作成、プリンターで印刷していましたが、アメリカのポストカードにはもちろん対応していません。
&lt;/p&gt;

&lt;p&gt;
色々と調べたところ、ポストカードを自分で作って印刷する人向けに、&lt;a href="https://www.avery.com"&gt;Avery&lt;/a&gt; という会社が用紙を販売、更にポストカード作成用の無料Webサービスまで提供していることがわかりました。これを利用しない手はありません。用紙はポストカード100枚分で$16と若干高めですが、一般的な有償のクリスマスカード作成サービスよりはずっと安価です。
&lt;/p&gt;

&lt;p&gt;
今回は、アメリカのポストカードデータ(両面)を自作し、自宅プリンターで印刷するやり方について書きます。はがきデザインキットWeb版からエキスポートしたcsvの宛先リストを、ポストカード宛名面のPDFファイルに埋め込むために作ったPythonスクリプトも載せておきます。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org78256fa" class="outline-2"&gt;
&lt;h2 id="org78256fa"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; Avery 8386&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
AmazonやAveryのサイトで探してみると、ポストカードにはAvery 8386番が良さそうです。早速注文してみました。
&lt;img src="./images/avery8386.png" alt="avery8386.png" /&gt;
&lt;/p&gt;

&lt;p&gt;
どんな用紙かと思ったら、レターサイズの厚紙1枚からポストカード2枚が切り出せるタイプでした。ハサミ等を使わずに手で簡単に切り取れるように、切り取り線のミシン目が入っていて、更にプリンタへの表裏面や向きを間違えないようにガイドが印刷されています。切り取り線で表裏に2,3回折るだけで簡単に切り離せます。とてもよく出来ていて、感心しました。
&lt;img src="./images/8386sheet.png" alt="8386sheet.png" /&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd20d123" class="outline-2"&gt;
&lt;h2 id="orgd20d123"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; Avery Webサービス&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
PCでAvery用ポストカードデータを作成するには、8386番のテンプレートを使用します。Averyサイトの&lt;a href="https://www.avery.com/templates/8386?gclid=Cj0KCQiAy4eNBhCaARIsAFDVtI1fMZfOw9Qzn_yygpqJkxg7CWWjV6C8DzkWu87LeNpkSuWoDBbKV1caAtIbEALw_wcB&amp;amp;gclsrc=aw.ds"&gt;8386テンプレートページ&lt;/a&gt; からMicrosoft Wordやその他のアプリケーション用テンプレートをダウンロードできます。
&lt;img src="./images/8386template.png" alt="8386template.png" /&gt;
&lt;/p&gt;

&lt;p&gt;
一方、このページ上で START DESIGNING をクリックしてアカウント登録すると、Webサイト上で8386のテンプレートを使ってポストカードが作成できるようになります。今回はこれを使います。用意されているデザインが選べ、クリスマスカードのデザインだけで350種類以上ありました。
&lt;img src="./images/8386design.png" alt="8386design.png" /&gt;
&lt;/p&gt;

&lt;p&gt;
デザインを選んで、表面と裏面(宛名面)をエディットします。このツールの良いところは、絵が単なるポストカード全面の一枚絵ではなく、パーツに分かれているところです。テキストの編集や追加はもちろん、背景色を変えたり、絵のパーツを動かしたりできます。絵のパーツを端に寄せて写真を貼るなど、自由度が高いのです。PowerPoint等を使ったことのある人なら、普通に使えると思います。
&lt;/p&gt;

&lt;p&gt;
&lt;img src="./images/easytext.png" alt="easytext.png" /&gt;
注意点として、日本語の入力に少し工夫がいります。普通にテキストボックスに日本語を入れようとしてもうまく入りません。そこで、Text &amp;gt; Easy Text Fill の画面で入力するワークアラウンドが必要になります。
&lt;/p&gt;

&lt;p&gt;
宛名面には、自分の住所と名前を入れ、日本向けのため"JAPAN"と赤文字で"AirMail"のテキストボックスを予め配置しておきます。そして肝心な宛先のリストを入力しようとしたところ、家族から「待った」がかかりました。一企業のWebサービスに知り合いの個人情報(名前と住所)を入れるのは不安だと言うのです。郵便局の はがきデザインキット では住所録をクラウドで管理していた気がしますが、郵便局と普通の企業ではデータ漏えいや転用のリスクに差がある、、、かもしれません。
&lt;/p&gt;

&lt;p&gt;
なお、作成したデータはAveryのサイト上で保存でき、自分で印刷するためにPDFファイルとしてダウンロード可能です。今回は宛先情報を入れないデータを作成しました。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0e9e6ab" class="outline-2"&gt;
&lt;h2 id="org0e9e6ab"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; 宛先リスト&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
これまで宛先住所録は はがきデザインキットWeb版 のデータを使っていました。2年前のWeb版サービス終了の際に、csvファイルとしてデータをダウンロードしてありました。
&lt;/p&gt;

&lt;p&gt;
このcsvファイルは以下のようなフォーマットになっています。
&lt;/p&gt;
&lt;pre class="example"&gt;
氏名(姓),氏名(名),フリガナ(姓),フリガナ(名),敬称,
郵便番号,都道府県,市区町村,番地・号,建物名,
連名1(姓),連名1(名),連名1(敬称),連名2(姓),連名2(名),連名2(敬称)
&lt;/pre&gt;


&lt;p&gt;
これを利用して、宛先面のPDFファイルに宛名と住所を埋め込めないかと考えました。
私は去年の夏に、PDFファイルにページ番号を付ける &lt;a href="https://github.com/achiwa912/pdfpagenum"&gt;スクリプト&lt;/a&gt; をPythonで作っていました。これを応用できないか試してみます。&lt;a href="https://achiwa912.github.io/pdfpagenum.html"&gt;その時のブログエントリー&lt;/a&gt;。
&lt;/p&gt;

&lt;p&gt;
スクリプトを読み直してみたところ、PDFファイルの各ページ中央下部に「3/50」のような文字列を挿入しているだけでした。この挿入位置を変え、文字列を宛先情報に変えれば行けそうな気がいます。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd579cfc" class="outline-2"&gt;
&lt;h2 id="orgd579cfc"&gt;&lt;span class="section-number-2"&gt;5&lt;/span&gt; 日本語フォントの扱い&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;p&gt;
少し試してみたところ、日本語が全て四角形シンボルになってしまいました。
フォントとして &lt;code&gt;Times-Roman&lt;/code&gt; を指定している部分を、日本語フォントを指定するようにしないとダメそうです。とりあえずフォントブックアプリを見て &lt;code&gt;Hiragino Maru Gothic ProN W4&lt;/code&gt; を指定したところ、PythonのKeyエラーになりました。
&lt;/p&gt;

&lt;p&gt;
解決策をしばらく探してみたところ、以下のページを見つけました。
&lt;/p&gt;

&lt;p&gt;
&lt;a href="https://gammasoft.jp/blog/pdf-japanese-font-by-python/"&gt;GAMMASOFTブログ - Pythonで日本語をPDFに出力する（ReportLabを利用）&lt;/a&gt;
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12487;&amp;#12501;&amp;#12457;&amp;#12523;&amp;#12488;&amp;#12398;&amp;#26085;&amp;#26412;&amp;#35486;&amp;#12501;&amp;#12457;&amp;#12531;&amp;#12488;&amp;#12434;&amp;#29992;&amp;#12356;&amp;#12427;&amp;#26041;&amp;#27861;&lt;/span&gt;
&lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#21069;&amp;#36848;&amp;#12398;&amp;#36890;&amp;#12426;&amp;#12289;ReportLab&amp;#12395;&amp;#12399;HeiseiMin-W3&amp;#12392;HeiseiKakuGo-W5&amp;#12364;&lt;/span&gt;
&lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12487;&amp;#12501;&amp;#12457;&amp;#12523;&amp;#12488;&amp;#12391;&amp;#29992;&amp;#24847;&amp;#12373;&amp;#12428;&amp;#12390;&amp;#12356;&amp;#12414;&amp;#12377;&amp;#12290;&amp;#12371;&amp;#12428;&amp;#12425;&amp;#12434;&amp;#21033;&amp;#29992;&amp;#12377;&amp;#12427;&amp;#12395;&amp;#12399;&amp;#12289;&amp;#20197;&amp;#19979;&amp;#12398;&lt;/span&gt;
&lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12467;&amp;#12540;&amp;#12489;&amp;#12391;&amp;#12501;&amp;#12457;&amp;#12531;&amp;#12488;&amp;#12434;&amp;#30331;&amp;#37682;&amp;#12375;&amp;#12414;&amp;#12377;&amp;#12290;&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; reportlab.pdfbase &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; pdfmetrics
&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; reportlab.pdfbase.cidfonts &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; UnicodeCIDFont
pdfmetrics.registerFont(UnicodeCIDFont(&lt;span style="font-style: italic;"&gt;'HeiseiMin-W3'&lt;/span&gt;))
canvas.setFont(&lt;span style="font-style: italic;"&gt;'HeiseiMin-W3'&lt;/span&gt;, 20)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
日本語フォントの登録が必要だったのですね。
これで日本語が表示できるようになりました。GAMMASOFTさん、どうもありがとうございます。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org489a95a" class="outline-2"&gt;
&lt;h2 id="org489a95a"&gt;&lt;span class="section-number-2"&gt;6&lt;/span&gt; Pythonスクリプト&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-6"&gt;
&lt;p&gt;
数カ月ぶりにPythonコードを書きました。あまりに久しぶりすぎて、
&lt;/p&gt;
&lt;pre class="example"&gt;
python -V
&lt;/pre&gt;

&lt;p&gt;
をしたら2.17にリンクされていました。macOSのバージョンを上げると、結構な確率でPythonの環境が壊れます。。。しばらく試行錯誤した結果、pyenvのPATHが.zshrcから無くなっていたというオチでした。
&lt;/p&gt;
&lt;pre class="example"&gt;
export PATH="$(pyenv root)/shims:$PATH"
&lt;/pre&gt;

&lt;p&gt;
このように、MacでPythonを使うのは若干面倒なので、VirtualBox等でLinuxを動かして、その上でPythonを使うようにするのが安全かもしれません。今回、試行錯誤の過程で、Pythonを最新の3.10.0に上げました。
&lt;/p&gt;


&lt;p&gt;
それでは、作成したスクリプトです。やっていることは:
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;住所一覧のcsvファイルを読んで、住所宛名listのlistを作る&lt;/li&gt;
&lt;li&gt;PDFファイルを扱う準備&lt;/li&gt;
&lt;li&gt;住所宛名listのlistからiteratorを作り、2つずつループで回す(1ページにポストカードが2枚あるため)&lt;/li&gt;
&lt;li&gt;宛名面PDFファイルをベースに、出力PDFページを作成(追加)する&lt;/li&gt;
&lt;li&gt;住所宛名listが存在すれば出力PDFページの指定位置に埋め込む&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
前回同様、reportlabとpdfrwのライブラリを利用しています。注意点は、 &lt;code&gt;canvas.drawString&lt;/code&gt; で指定するY座標は下側がゼロなところです。
定数値を使っていたりして見苦しいですが。。。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; sys, os, csv

&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; reportlab.pdfgen.canvas &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; Canvas
&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; reportlab.pdfbase &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; pdfmetrics
&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; reportlab.pdfbase.cidfonts &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; UnicodeCIDFont
&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; reportlab.lib.pagesizes &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; letter
&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; pdfrw &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; PdfReader
&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; pdfrw.toreportlab &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; makerl
&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; pdfrw.buildxobj &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; pagexobj

&lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; (
    &lt;span style="font-weight: bold;"&gt;len&lt;/span&gt;(sys.argv) != 3
    &lt;span style="font-weight: bold;"&gt;or&lt;/span&gt; &lt;span style="font-style: italic;"&gt;".pdf"&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;not&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; sys.argv[1].lower()
    &lt;span style="font-weight: bold;"&gt;or&lt;/span&gt; &lt;span style="font-style: italic;"&gt;".csv"&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;not&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; sys.argv[2].lower()
):
    &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(f&lt;span style="font-style: italic;"&gt;"Usage: python {sys.argv[0]} &amp;lt;pdf filename&amp;gt; &amp;lt;csv filename&amp;gt;"&lt;/span&gt;)
    sys.&lt;span style="font-weight: bold; text-decoration: underline;"&gt;exit&lt;/span&gt;()

&lt;span style="font-style: italic;"&gt;"""&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;&amp;#20303;&amp;#25152;&amp;#37682;csv&amp;#12501;&amp;#12449;&amp;#12452;&amp;#12523;&amp;#12363;&amp;#12425;&amp;#23451;&amp;#20808;&amp;#12522;&amp;#12473;&amp;#12488;&amp;#12434;&amp;#20316;&amp;#25104;&amp;#12377;&amp;#12427;&amp;#12290;&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;csf&amp;#12501;&amp;#12449;&amp;#12452;&amp;#12523;&amp;#12501;&amp;#12457;&amp;#12540;&amp;#12510;&amp;#12483;&amp;#12488;:&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;&amp;#27663;&amp;#21517;(&amp;#22995;),&amp;#27663;&amp;#21517;(&amp;#21517;),&amp;#12501;&amp;#12522;&amp;#12460;&amp;#12490;(&amp;#22995;),&amp;#12501;&amp;#12522;&amp;#12460;&amp;#12490;(&amp;#21517;),&amp;#25964;&amp;#31216;,&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;&amp;#37109;&amp;#20415;&amp;#30058;&amp;#21495;,&amp;#37117;&amp;#36947;&amp;#24220;&amp;#30476;,&amp;#24066;&amp;#21306;&amp;#30010;&amp;#26449;,&amp;#30058;&amp;#22320;&amp;#12539;&amp;#21495;,&amp;#24314;&amp;#29289;&amp;#21517;,&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;&amp;#36899;&amp;#21517;1(&amp;#22995;),&amp;#36899;&amp;#21517;1(&amp;#21517;),&amp;#36899;&amp;#21517;1(&amp;#25964;&amp;#31216;),&amp;#36899;&amp;#21517;2(&amp;#22995;),&amp;#36899;&amp;#21517;2(&amp;#21517;),&amp;#36899;&amp;#21517;2(&amp;#25964;&amp;#31216;)&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;&amp;#12522;&amp;#12473;&amp;#12488;&amp;#27083;&amp;#36896;:&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;address_list list - [adrs1, adrs2, adrs3, etc.]&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;adrs list - ['&amp;#12306;111-1111', '&amp;#26481;&amp;#20140;&amp;#37117;&amp;#20013;&amp;#21306;&amp;#26412;&amp;#30010;1-1-1', '&amp;#12288;&amp;#12288;&amp;#12513;&amp;#12478;&amp;#12531;&amp;#26412;&amp;#30010;101',&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;'', '&amp;#30000;&amp;#20013;&amp;#12288;&amp;#19968;&amp;#37070;&amp;#12288;&amp;#27096;', '&amp;#12288;&amp;#12288;&amp;#12288;&amp;#33457;&amp;#23376;&amp;#12288;&amp;#27096;', '&amp;#12288;&amp;#12288;&amp;#12288;&amp;#22826;&amp;#37070;&amp;#12288;&amp;#12385;&amp;#12419;&amp;#12435;']&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;"""&lt;/span&gt;
&lt;span style="font-weight: bold; font-style: italic;"&gt;address_list&lt;/span&gt; = []
&lt;span style="font-weight: bold;"&gt;with&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;open&lt;/span&gt;(sys.argv[2], newline=&lt;span style="font-style: italic;"&gt;""&lt;/span&gt;) &lt;span style="font-weight: bold;"&gt;as&lt;/span&gt; csvf:
    &lt;span style="font-weight: bold; font-style: italic;"&gt;csv_rdr&lt;/span&gt; = csv.reader(csvf)
    &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; row &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; csv_rdr:
        &lt;span style="font-weight: bold; font-style: italic;"&gt;adrs&lt;/span&gt; = []
        &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; row[5]:  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#37109;&amp;#20415;&amp;#30058;&amp;#21495;&lt;/span&gt;
            adrs.append(&lt;span style="font-style: italic;"&gt;""&lt;/span&gt;.join([&lt;span style="font-style: italic;"&gt;"&amp;#12306;"&lt;/span&gt;, row[5]]))
        adrs.append(&lt;span style="font-style: italic;"&gt;""&lt;/span&gt;.join([row[6], row[7], row[8]]))  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#20303;&amp;#25152;&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; row[9]:  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12450;&amp;#12497;&amp;#12540;&amp;#12488;&amp;#21517;&lt;/span&gt;
            adrs.append(&lt;span style="font-style: italic;"&gt;""&lt;/span&gt;.join([&lt;span style="font-style: italic;"&gt;"&amp;#12288;&amp;#12288;"&lt;/span&gt;, row[9]]))
        adrs.append(&lt;span style="font-style: italic;"&gt;""&lt;/span&gt;)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#20303;&amp;#25152;&amp;#12392;&amp;#21517;&amp;#21069;&amp;#12398;&amp;#38291;&amp;#12434;1&amp;#34892;&amp;#31354;&amp;#12369;&amp;#12427;&lt;/span&gt;
        adrs.append(&lt;span style="font-style: italic;"&gt;""&lt;/span&gt;.join([row[0], &lt;span style="font-style: italic;"&gt;"&amp;#12288;"&lt;/span&gt;, row[1], &lt;span style="font-style: italic;"&gt;"&amp;#12288;"&lt;/span&gt;, row[4]]))  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#23451;&amp;#20808;&amp;#21517;&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; row[11]:  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#36899;&amp;#21517;1&lt;/span&gt;
            &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; row[10]:  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#36899;&amp;#21517;1&amp;#21517;&amp;#23383;&lt;/span&gt;
                adrs.append(&lt;span style="font-style: italic;"&gt;""&lt;/span&gt;.join([row[10], &lt;span style="font-style: italic;"&gt;"&amp;#12288;"&lt;/span&gt;, row[11], &lt;span style="font-style: italic;"&gt;"&amp;#12288;"&lt;/span&gt;, row[12]]))
            &lt;span style="font-weight: bold;"&gt;else&lt;/span&gt;:
                adrs.append(&lt;span style="font-style: italic;"&gt;""&lt;/span&gt;.join([&lt;span style="font-style: italic;"&gt;"&amp;#12288;"&lt;/span&gt; * (&lt;span style="font-weight: bold;"&gt;len&lt;/span&gt;(row[0]) + 1), row[11], &lt;span style="font-style: italic;"&gt;"&amp;#12288;"&lt;/span&gt;, row[12]]))
        &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; row[14]:  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#36899;&amp;#21517;2&lt;/span&gt;
            &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; row[13]:  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#36899;&amp;#21517;2&amp;#21517;&amp;#23383;&lt;/span&gt;
                adrs.append(&lt;span style="font-style: italic;"&gt;""&lt;/span&gt;.join([row[13], &lt;span style="font-style: italic;"&gt;"&amp;#12288;"&lt;/span&gt;, row[14], &lt;span style="font-style: italic;"&gt;"&amp;#12288;"&lt;/span&gt;, row[15]]))
            &lt;span style="font-weight: bold;"&gt;else&lt;/span&gt;:
                adrs.append(&lt;span style="font-style: italic;"&gt;""&lt;/span&gt;.join([&lt;span style="font-style: italic;"&gt;"&amp;#12288;"&lt;/span&gt; * (&lt;span style="font-weight: bold;"&gt;len&lt;/span&gt;(row[0]) + 1), row[14], &lt;span style="font-style: italic;"&gt;"&amp;#12288;"&lt;/span&gt;, row[15]]))
        address_list.append(adrs)

&lt;span style="font-weight: bold; font-style: italic;"&gt;in_pdf&lt;/span&gt; = sys.argv[1]
&lt;span style="font-weight: bold; font-style: italic;"&gt;out_pdf&lt;/span&gt; = os.path.splitext(sys.argv[1])[0] + &lt;span style="font-style: italic;"&gt;"_adrs.pdf"&lt;/span&gt;

&lt;span style="font-weight: bold; font-style: italic;"&gt;canvas&lt;/span&gt; = Canvas(out_pdf, pagesize=letter)
&lt;span style="font-weight: bold; font-style: italic;"&gt;pdf_rdr&lt;/span&gt; = PdfReader(in_pdf)
&lt;span style="font-weight: bold; font-style: italic;"&gt;pages&lt;/span&gt; = [pagexobj(p) &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; p &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; pdf_rdr.pages]
&lt;span style="font-weight: bold; font-style: italic;"&gt;in_page&lt;/span&gt; = pages[0]  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;assuming it has only one page&lt;/span&gt;

&lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;ReportLab&amp;#12395;&amp;#29992;&amp;#24847;&amp;#12373;&amp;#12428;&amp;#12390;&amp;#12356;&amp;#12427;&amp;#12501;&amp;#12457;&amp;#12531;&amp;#12488;&amp;#12434;&amp;#30331;&amp;#37682;&lt;/span&gt;
pdfmetrics.registerFont(UnicodeCIDFont(&lt;span style="font-style: italic;"&gt;"HeiseiMin-W3"&lt;/span&gt;))

&lt;span style="font-weight: bold; font-style: italic;"&gt;it&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;iter&lt;/span&gt;(address_list)
&lt;span style="font-weight: bold;"&gt;next&lt;/span&gt;(it)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;skip header&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;while&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;True&lt;/span&gt;:
    &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#19978;&amp;#12398;&amp;#12459;&amp;#12540;&amp;#12489;&amp;#12395;&amp;#20303;&amp;#25152;&amp;#12434;&amp;#22475;&amp;#12417;&amp;#36796;&amp;#12416;&lt;/span&gt;
    &lt;span style="font-weight: bold; font-style: italic;"&gt;exit_flag&lt;/span&gt; = &lt;span style="font-weight: bold; text-decoration: underline;"&gt;False&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;try&lt;/span&gt;:
        &lt;span style="font-weight: bold; font-style: italic;"&gt;adrs&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;next&lt;/span&gt;(it)
    &lt;span style="font-weight: bold;"&gt;except&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;StopIteration&lt;/span&gt;:
        &lt;span style="font-weight: bold; font-style: italic;"&gt;exit_flag&lt;/span&gt; = &lt;span style="font-weight: bold; text-decoration: underline;"&gt;True&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;not&lt;/span&gt; exit_flag:
        canvas.doForm(makerl(canvas, in_page))
        canvas.saveState()
        canvas.setStrokeColorRGB(0, 0, 0)
        canvas.setFont(&lt;span style="font-style: italic;"&gt;"HeiseiMin-W3"&lt;/span&gt;, 16)
        &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; ln, sline &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;enumerate&lt;/span&gt;(adrs[::-1], start=1):
            canvas.drawString(180, 500 + ln * 17, sline)
    &lt;span style="font-weight: bold;"&gt;else&lt;/span&gt;:
        &lt;span style="font-weight: bold;"&gt;break&lt;/span&gt;

    &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#19979;&amp;#12398;&amp;#12459;&amp;#12540;&amp;#12489;&amp;#12395;&amp;#20303;&amp;#25152;&amp;#12434;&amp;#26893;&amp;#12360;&amp;#36796;&amp;#12416;&lt;/span&gt;
    &lt;span style="font-weight: bold; font-style: italic;"&gt;exit_flag&lt;/span&gt; = &lt;span style="font-weight: bold; text-decoration: underline;"&gt;False&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;try&lt;/span&gt;:
        &lt;span style="font-weight: bold; font-style: italic;"&gt;adrs&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;next&lt;/span&gt;(it)
    &lt;span style="font-weight: bold;"&gt;except&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;StopIteration&lt;/span&gt;:
        &lt;span style="font-weight: bold; font-style: italic;"&gt;exit_flag&lt;/span&gt; = &lt;span style="font-weight: bold; text-decoration: underline;"&gt;True&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;not&lt;/span&gt; exit_flag:
        &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; ln, sline &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;enumerate&lt;/span&gt;(adrs[::-1], start=1):
            canvas.drawString(180, 160 + ln * 17, sline)
    &lt;span style="font-weight: bold;"&gt;else&lt;/span&gt;:
        canvas.restoreState()
        canvas.showPage()
        &lt;span style="font-weight: bold;"&gt;break&lt;/span&gt;

    canvas.restoreState()
    canvas.showPage()

canvas.save()
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org39ed6b3" class="outline-2"&gt;
&lt;h2 id="org39ed6b3"&gt;&lt;span class="section-number-2"&gt;7&lt;/span&gt; 使い方&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-7"&gt;
&lt;p&gt;
PDFライブラリをインストールします。
&lt;/p&gt;
&lt;pre class="example"&gt;
pip install reportlab
pip install pdfrw
&lt;/pre&gt;


&lt;p&gt;
上記スクリプトをadrs.pyとしてセーブ。
&lt;/p&gt;

&lt;p&gt;
実行
&lt;/p&gt;
&lt;pre class="example"&gt;
python adrs.py &amp;lt;pdf filename&amp;gt; &amp;lt;csv fiiename&amp;gt;
&lt;/pre&gt;


&lt;p&gt;
Pythonは3.6以降なら動くと思います。開発には3.10を使いました。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgc2383c6" class="outline-2"&gt;
&lt;h2 id="orgc2383c6"&gt;&lt;span class="section-number-2"&gt;8&lt;/span&gt; 印刷&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-8"&gt;
&lt;p&gt;
Averyの8386テンプレートを使ってWeb上でポストカードデータを作成したら、自分のプリンターで印刷するためにPDFファイルとしてダウンロードすることができます。
&lt;/p&gt;

&lt;p&gt;
これを日本のプリンターで印刷する際に、いくつかポイントがあるので、書いておきます。なお、私は日本から持っていった、ブラザーのDCP-J983Nを使っています。
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;レターサイズを指定する(デフォルトはA4）&lt;/li&gt;
&lt;li&gt;Scaleは手動で100%を指定する(デフォルトだとauto fitで97%等になっている)&lt;/li&gt;
&lt;li&gt;手差しトレイを使って1枚、1面ずつ印刷する。通常トレイと逆で印刷面が上。&lt;/li&gt;
&lt;li&gt;手差しトレイにはきっちり奥まで差し込む。更に数ミリ自動で送られる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org9bd3229" class="outline-2"&gt;
&lt;h2 id="org9bd3229"&gt;&lt;span class="section-number-2"&gt;9&lt;/span&gt; 宛名面レイアウト&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-9"&gt;
&lt;p&gt;
アメリカのポストカードレイアウト例です。
&lt;img src="./images/postback.png" alt="postback.png" /&gt;
&lt;/p&gt;

&lt;p&gt;
左上に自分の名前住所を英語で、中央付近に宛先を書き、右上に切手を貼ります。英語では名前を先に書きます。宛先は日本語で構いませんが、目立つように大きく"Japan"と"Air Mail"を書きます。
&lt;/p&gt;

&lt;p&gt;
面の右側半分を宛先住所用とし、左側半分にメッセージを書く場合もあります。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf1f64de" class="outline-2"&gt;
&lt;h2 id="orgf1f64de"&gt;&lt;span class="section-number-2"&gt;10&lt;/span&gt; 切手を貼る&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-10"&gt;
&lt;p&gt;
日本に手紙(約30g以内)やポストカードを送るには、グローバルフォーエバー切手を買います。アメリカはインフレで郵便の値段が上がっていきますが、フォーエバー切手を買えば、ずっと使えます。アメリカ国内用と海外用(グローバル)で価格が異なり、グローバルフォーエバー切手は現在1枚$1.3です。
&lt;img src="./images/gstamps.png" alt="gstamps.png" /&gt;
&lt;/p&gt;

&lt;p&gt;
切手は10枚組のシートになっています。1枚1枚がシールになっていて、シートから剥がして手紙やハガキに貼ります。日本の切手のように濡らす必要がなく、便利です。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgba23fd0" class="outline-2"&gt;
&lt;h2 id="orgba23fd0"&gt;&lt;span class="section-number-2"&gt;11&lt;/span&gt; 終わりに&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-11"&gt;
&lt;p&gt;
はがきデザインキットの住所録csvデータを、Avery 8386用のポストカード宛名面PDFファイルに埋め込むという、ものすごくニッチなスクリプトを作りました。需要は無いと思いますが、来年の自分のために記録として残しておきます。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Python"></category><category term="Blog"></category><category term="アメリカ生活"></category><category term="Python"></category></entry><entry><title>S3バックアップツールbus3.pyを作りました</title><link href="http://achiwa912.github.io/bus3.html" rel="alternate"></link><published>2021-08-17T00:00:00-04:00</published><updated>2021-12-03T00:00:00-05:00</updated><author><name>きょうす</name></author><id>tag:achiwa912.github.io,2021-08-17:/bus3.html</id><summary type="html">Developed a backup tool to S3 storage</summary><content type="html">&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org50b175b"&gt;1. はじめに&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org037cbdd"&gt;2. bus3概要&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org3a9df31"&gt;3. bus3特徴&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org93a6658"&gt;3.1. 機能&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgb4dba68"&gt;3.2. 技術面で&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgc518319"&gt;4. 使用法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org50f1d45"&gt;5. 今回学んだこと&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org90a5206"&gt;5.1. asyncio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgf92a515"&gt;5.2. データベース&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgad7a752"&gt;5.3. 性能ボトルネック解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org77f888c"&gt;5.4. python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgf56ed6a"&gt;5.5. 開発環境&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org50b175b" class="outline-2"&gt;
&lt;h2 id="org50b175b"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; はじめに&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Amazon S3とデータベースの勉強を兼ねて、Linux向けのS3ストレージへのバックアップツールbus3.pyを作りました。&lt;a href="https://github.com/achiwa912/bus3"&gt;https://github.com/achiwa912/bus3&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org037cbdd" class="outline-2"&gt;
&lt;h2 id="org037cbdd"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; bus3概要&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
bus3は指定ディレクトリ以下のファイルやディレクトリをバックアップします。ファイルのコンテンツはS3ストレージに、メタデータはデータベースに保管します。
&lt;/p&gt;

&lt;p&gt;
S3ストレージはAmazonのAWSでなく、ローカルネットワークに接続されたS3インタフェースを持つストレージを使って開発、テストしています。このため、AWSを使うためには多少のtweakが必要になるかもしれません。
&lt;/p&gt;

&lt;p&gt;
データベース(DB)は、当初sqlite3を使っていたのですが、DBのライトがボトルネックとなって多重度が上がらず、全く性能が出なかったので、Postgresに移行しました。Postgresはbus3の外側にあって、別途導入やバックアップを行う必要があります。
&lt;/p&gt;

&lt;p&gt;
DBのバックアップを別途行う必要があるため、bus3はあまり実用的では無いかもしれません。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3a9df31" class="outline-2"&gt;
&lt;h2 id="org3a9df31"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; bus3特徴&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org93a6658" class="outline-3"&gt;
&lt;h3 id="org93a6658"&gt;&lt;span class="section-number-3"&gt;3.1&lt;/span&gt; 機能&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-3-1"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;指定ファイルやディレクトリのバックアップ、リストアを行います&lt;/li&gt;
&lt;li&gt;シンボリックリンクやハードリンクをサポートしています&lt;/li&gt;
&lt;li&gt;extended attributesもバックアップ、リストアします&lt;/li&gt;
&lt;li&gt;バックアップヒストリーとファイルバージョンを管理していて、指定バージョンへのリストアが可能です&lt;/li&gt;
&lt;li&gt;ファイルコンテンツに対して、デフォルトで64MBのチャンク単位でのdedupe(シングルインスタンス化)を行います。同じ中身のチャンク(やそれ以下のサイズのファイル)があったら、そのチャンクはS3ストレージ上に一つだけ実体を持ちます。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb4dba68" class="outline-3"&gt;
&lt;h3 id="orgb4dba68"&gt;&lt;span class="section-number-3"&gt;3.2&lt;/span&gt; 技術面で&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-3-2"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;asyncio&lt;/code&gt; をフルに活用してバックアップ・リストアの多重度を上げています
&lt;ul class="org-ul"&gt;
&lt;li&gt;バックアップするファイルやディレクトリ毎にasyncタスクを生成しています&lt;/li&gt;
&lt;li&gt;更に、S3へのオブジェクトの書き込み毎にasyncタスクを生成しています&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aiofiles&lt;/code&gt;, &lt;code&gt;asyncpg&lt;/code&gt;, &lt;code&gt;aioboto3&lt;/code&gt; ライブラリを利用しています&lt;/li&gt;
&lt;li&gt;メモリバッファの使用量上限を制限しており、1GB以上の巨大ファイルを複数バックアップしてもメモリ使用量は2〜3GB程度です(postgres除く)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;asyncio&lt;/code&gt; は基本的に単一コアで動作するため、CPU利用率は120%程度(postgres除く)です。100%を超えるのは、 &lt;code&gt;aiofiles&lt;/code&gt; がワーカースレッドを使ったり、OSのシステムコールを呼んだりするためと思われます&lt;/li&gt;
&lt;li&gt;sqlite3のグローバルライトロックを避けるためにpostgresを使っています&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgc518319" class="outline-2"&gt;
&lt;h2 id="orgc518319"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; 使用法&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
githubのREADMEを参照ください。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org50f1d45" class="outline-2"&gt;
&lt;h2 id="org50f1d45"&gt;&lt;span class="section-number-2"&gt;5&lt;/span&gt; 今回学んだこと&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org90a5206" class="outline-3"&gt;
&lt;h3 id="org90a5206"&gt;&lt;span class="section-number-3"&gt;5.1&lt;/span&gt; asyncio&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-5-1"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;単純に &lt;code&gt;await&lt;/code&gt; を使っても多重度が上がる訳ではないことがわかりました。 多重度を上げるには、 &lt;code&gt;asyncio.create_task()&lt;/code&gt; を使ってasyncタスク化しなくてはいけません&lt;/li&gt;
&lt;li&gt;&lt;code&gt;asyncio&lt;/code&gt; はタスクスイッチを意識して行わなければいけませんが、その分、そこまで資源排他を意識せずに済むため、スレッドよりも使いやすいかもしれません&lt;/li&gt;
&lt;li&gt;同様に、スレッドよりもデバッグしやすいと思います。タスクスイッチのタイミングを意識できるのは、思いの外有益です&lt;/li&gt;
&lt;li&gt;&lt;code&gt;asyncio&lt;/code&gt; はまだ新しい技術なため、足回りが揃っていないと感じました&lt;/li&gt;
&lt;li&gt;asyncタスクで発生した例外の扱いが難しいです。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf92a515" class="outline-3"&gt;
&lt;h3 id="orgf92a515"&gt;&lt;span class="section-number-3"&gt;5.2&lt;/span&gt; データベース&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-5-2"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;sqlite3はとても気軽に使えますが、グローバルライトロックがあるため、多重度を上げる技術である &lt;code&gt;asyncio&lt;/code&gt; とは相性が悪いと感じました&lt;/li&gt;
&lt;li&gt;これまではSQLAlchemyを使っていましたが、今回直接SQLを書いてみて、SQLAlchemyを使わないほうが手間がかからないと思いました。ORMがDBのデータ構造を隠蔽してくれるのは楽ですが、そのぶん、デバッグで苦労します&lt;/li&gt;
&lt;li&gt;sqlite3からpostgresに移行してみて、DB間の挙動や仕様の差に苦労しました。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgad7a752" class="outline-3"&gt;
&lt;h3 id="orgad7a752"&gt;&lt;span class="section-number-3"&gt;5.3&lt;/span&gt; 性能ボトルネック解析&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-5-3"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;CPUやメモリの利用率は &lt;code&gt;top&lt;/code&gt; コマンドを使って見ました&lt;/li&gt;
&lt;li&gt;標準のcProfileと、可視化ツールである&lt;a href="https://jiffyclub.github.io/snakeviz/"&gt;snakeviz&lt;/a&gt;の組み合わせは素晴らしいと思いました。使い方:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="example"&gt;
pip install snakeviz
python -m cProfile -o prof.bin &amp;lt;yourscript.py&amp;gt; &amp;lt;args&amp;gt;
snakeviz prof.bin
&lt;/pre&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;これらを使っても、性能ボトルネックの特定は難しいです。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org77f888c" class="outline-3"&gt;
&lt;h3 id="org77f888c"&gt;&lt;span class="section-number-3"&gt;5.4&lt;/span&gt; python&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-5-4"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;argparse&lt;/code&gt; が思ったように動いてくれず、とても使いづらかったです。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf56ed6a" class="outline-3"&gt;
&lt;h3 id="orgf56ed6a"&gt;&lt;span class="section-number-3"&gt;5.5&lt;/span&gt; 開発環境&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-5-5"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;私はemacs + elpyで開発していますが、どうもセーブ時の自動整形が変だと思ったら、必要なバックエンド機能が動いていなかった、ということがありました。 &lt;code&gt;M-x elpy-config&lt;/code&gt; で確認するまでわかりませんでした&lt;/li&gt;
&lt;li&gt;せっかくelpyを使っているのに、定義箇所や使用箇所へのジャンプ機能を使っていませんでした。 &lt;code&gt;M-.&lt;/code&gt; で定義元へジャンプ、 &lt;code&gt;M-,&lt;/code&gt; で元の場所にジャンプなのですが、普通の検索で乗り切っていました&lt;/li&gt;
&lt;li&gt;同様に、 &lt;code&gt;M-&amp;lt;矢印キー&amp;gt;&lt;/code&gt; でリージョンのインデントを一括で変えられることを最近になって知りました。手動でタブキーを連打して整形していました。これで何度バグを作り込んだか。。&lt;/li&gt;
&lt;li&gt;emacs lispの勉強の必要性を感じました。導入したemacsパッケージで問題が起きた場合、現状では、google検索で解決しないとあきらめるしかありません。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Python"></category><category term="Python"></category></entry><entry><title>DL-13; サーバー&amp;クライアント</title><link href="http://achiwa912.github.io/dl13.html" rel="alternate"></link><published>2021-05-16T00:00:00-04:00</published><updated>2021-12-03T00:00:00-05:00</updated><author><name>きょうす</name></author><id>tag:achiwa912.github.io,2021-05-16:/dl13.html</id><summary type="html">DL server</summary><content type="html">&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orga51640f"&gt;1. はじめに&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org859e41b"&gt;2. クライアント&amp;amp;サーバー&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgd737238"&gt;3. Pythonのお勉強&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org8193055"&gt;3.1. List comprehension&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org939cd81"&gt;3.2. SQLAlchemy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org8621e08"&gt;3.3. asyncプログラミング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org7f14fc3"&gt;3.4. Python-socketio&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#org103f733"&gt;4. 次は、、、&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga51640f" class="outline-2"&gt;
&lt;h2 id="orga51640f"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; はじめに&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Rogue+Wizライクなゲーム(DL - Daemon Lord)を作るプロジェクトの13回目です。
&lt;/p&gt;

&lt;p&gt;
githubでコードを &lt;a href="https://github.com/achiwa912/daemonlord"&gt;公開&lt;/a&gt; しています。MacとLinuxで動作確認していますが、Windowsは未検証です。(いちおうWindows用のコードは入れてみました。Macは立ち上げ確認くらい。。)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org859e41b" class="outline-2"&gt;
&lt;h2 id="org859e41b"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; クライアント&amp;amp;サーバー&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
前回、次回作の予告らしきものをしましたが、次回作ではなく今作の延長線上でクライアント&amp;amp;サーバー化にトライしています。サーバーは別レポジトリに分けています。
&lt;/p&gt;

&lt;p&gt;
予告通りサーバーはasync対応しました。asyncプログラミングは初めてです。ライブラリは長考の結果、&lt;a href="https://python-socketio.readthedocs.io/en/latest/"&gt;python-socketio&lt;/a&gt;を使うことにしました。これはシンプルなパッケージですが、DLの用途では必要十分であると感じました。
&lt;/p&gt;

&lt;p&gt;
とりあえず現在できることは、
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;複数クライアントのサーバー接続(localhostのみ確認)&lt;/li&gt;
&lt;li&gt;ダンジョンマップ上でメッセージ送付、リアルタイム受信&lt;/li&gt;
&lt;li&gt;サーバーでのフロアマップ生成&amp;amp;同じルーム参加者(チーム)とのマップ共有&lt;/li&gt;
&lt;li&gt;マップ上で他の参加者の移動状況をリアルタイムに見られる&lt;/li&gt;
&lt;li&gt;サーバー接続ダンジョン内でのセーブ&amp;amp;ロード&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
といったところで、ごくprimitiveなことしかできません。それでも、同じチームとしてログインしている他のユーザーの動きがマップ上に見られたり、メッセージをリアルタイムに送受信できるだけで結構楽しいです。
&lt;/p&gt;

&lt;p&gt;
今後エンハンス予定(取らぬ狸の皮算用ですが。。。)なのは、
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;他参加者のモンスターとのバトルへのjoin&lt;/li&gt;
&lt;li&gt;サーバー独自モンスターの追加&lt;/li&gt;
&lt;li&gt;他参加者との共同キャンプ&lt;/li&gt;
&lt;li&gt;共同キャンプでのアイテム受け渡し/売買&lt;/li&gt;
&lt;li&gt;共同キャンプでの相手パーティメンバーの回復魔法、アイテム使用&lt;/li&gt;
&lt;li&gt;インターネット対応
&lt;ul class="org-ul"&gt;
&lt;li&gt;username &amp;amp; passwordを使った認証&lt;/li&gt;
&lt;li&gt;ユーザー登録(flask使うべきだったのかな。。)&lt;/li&gt;
&lt;li&gt;https対応(できるのかなぁ)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;サーバーのDB対応(サーバーリブートで情報が失われないようにする)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd737238" class="outline-2"&gt;
&lt;h2 id="orgd737238"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; Pythonのお勉強&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org8193055" class="outline-3"&gt;
&lt;h3 id="org8193055"&gt;&lt;span class="section-number-3"&gt;3.1&lt;/span&gt; List comprehension&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-3-1"&gt;
&lt;p&gt;
DLのプログラミングで一番楽しいのは、list/dictionary comprehensionやgenerator 
expressionを考えて工夫している時です。Python初級者を卒業した気になるし、パズル
みたいで本当に楽しいです。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org939cd81" class="outline-3"&gt;
&lt;h3 id="org939cd81"&gt;&lt;span class="section-number-3"&gt;3.2&lt;/span&gt; SQLAlchemy&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-3-2"&gt;
&lt;p&gt;
前回の更新から使い始めたSQLAlchemyですが、今回またもや衝撃的な学びがありました。
なんと、既存テーブルへのカラムの追加はSQLAlchemyでサポートされていないのでした。
えー。そんなのあり? DBの基本機能だと思うのですが。。。これができないとなると、
ORMのお気楽さがものすごく中途半端に感じます。テーブル設計だけは事前にかっちりやって
おかないといけないなら、そもそも軟弱なORMなど使わないのでは。。。(個人の感想です)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org8621e08" class="outline-3"&gt;
&lt;h3 id="org8621e08"&gt;&lt;span class="section-number-3"&gt;3.3&lt;/span&gt; asyncプログラミング&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-3-3"&gt;
&lt;p&gt;
最近流行のasyncですが、いろいろ調べたところ、これにはasyncio派とgreenlet派がある
ことがわかりました。前者は明示的にasync def, awaitといったキーワードを使って
意識的にasyncとそうでない部分を使い分ける必要があり、後者は既存の書き方で作った
プログラムを(半ば無理矢理)async化してくれるというもののようでした。
&lt;/p&gt;

&lt;p&gt;
ぱっと見では後者の方が良さそうですが、async化を隠蔽して実施する後者はデバッグが
より大変そうです。うまく動かない時には、実際にはどう動いているのかを見なければ
ならないので、結局、隠蔽されている部分がどうなっているのかを正しく理解していなくては
ならず、それならば明示的にコード上でasyncなのかそうでないのかを判別出来る方が
単純です。そんなわけで、最初はすごく良さそうに見えたgreenletは見送ることにしました。
&lt;/p&gt;

&lt;p&gt;
SQLAlchemyのORMと同様に、複雑な部分を隠蔽してくれるのはありがたいのですが、いざ
デバッグしなくてはならなくなると、一見面倒な細かい部分まで隠蔽せずにオープンにして
くれた方が実は楽だったりするのですね。
&lt;/p&gt;

&lt;p&gt;
まあ、このあたりは好みの問題という気がします。私は元々がアセンブラプログラマー
(アマチュア)だったので、細かいところまで何でも理解しておきたい傾向があるようです。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7f14fc3" class="outline-3"&gt;
&lt;h3 id="org7f14fc3"&gt;&lt;span class="section-number-3"&gt;3.4&lt;/span&gt; Python-socketio&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-3-4"&gt;
&lt;p&gt;
このパッケージはすごいです。独立したチュートリアルが必要ないくらいシンプルかつ、
必要十分な機能が備わっていて、とても使いやすいです。クライアントサーバーの
システムがここまで簡単に実現できるとは思いませんでした。比較的低レベルな関数の
集合ですが、そこも気に入っています。
&lt;/p&gt;

&lt;p&gt;
作者の&lt;a href="https://github.com/miguelgrinberg"&gt;Miguel Grinberg&lt;/a&gt;という人はただ者ではないです。弟子入りしたいくらい。
どうやらgreenlet推しのようですが、そこだけは賛同できません。。。笑
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org103f733" class="outline-2"&gt;
&lt;h2 id="org103f733"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; 次は、、、&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
今回いろいろ変えすぎて、プログラムがすっかり不安定になってしまっているので、
しばらくはエンハンスしつつ安定化に努めたいと思います。
&lt;/p&gt;

&lt;p&gt;
実は、まだ致命的なバグが残っていてアップロードできずにいます。。。今週末中に
取れるかなぁ。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Python"></category><category term="Python"></category><category term="game"></category></entry><entry><title>DL-12; データベースをサポート</title><link href="http://achiwa912.github.io/dl12.html" rel="alternate"></link><published>2021-05-07T00:00:00-04:00</published><updated>2021-12-03T00:00:00-05:00</updated><author><name>きょうす</name></author><id>tag:achiwa912.github.io,2021-05-07:/dl12.html</id><summary type="html">DL database support</summary><content type="html">&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orgb539b44"&gt;1. はじめに&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgfc1d019"&gt;2. データベース対応&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org87b7efd"&gt;2.1. DLのデータベース対応&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org9278943"&gt;2.2. データベース/SQLAlchemyを使ってみて&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#org88f2714"&gt;3. 次の構想&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb539b44" class="outline-2"&gt;
&lt;h2 id="orgb539b44"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; はじめに&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Rogue+Wizライクなゲーム(DL - Daemon Lord)を作るプロジェクトの12回目です。
&lt;/p&gt;

&lt;p&gt;
githubでコードを &lt;a href="https://github.com/achiwa912/daemonlord"&gt;公開&lt;/a&gt; しています。MacとLinuxで動作確認していますが、Windowsは未検証です。(いちおうWindows用のコードは入れてみました。Macは立ち上げ確認くらい。。)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgfc1d019" class="outline-2"&gt;
&lt;h2 id="orgfc1d019"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; データベース対応&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org87b7efd" class="outline-3"&gt;
&lt;h3 id="org87b7efd"&gt;&lt;span class="section-number-3"&gt;2.1&lt;/span&gt; DLのデータベース対応&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-1"&gt;
&lt;p&gt;
DLはこれまでセーブデータをpickleしてファイルにセーブしていたのですが、データベースを使ってみたかったのでサポートしてみました。セーブするときには全部セーブして、ロードするときも同様という使い方なので、データベースにしたメリットは今のところほぼありません。それどころか、セーブに数秒かかるようになってしまいました。
&lt;/p&gt;

&lt;p&gt;
使ったのはSQLAlchemyという有名なライブラリで、object relational mapping (ORM)を選択しました。バックエンドには設定の楽なsqlite3を使っています。
&lt;/p&gt;

&lt;p&gt;
「データベースに変えたからこれまでのセーブデータは使えなくなりました」とは言えないので、DBファイルが無い時には従来のセーブファイルからデータをロードできるようにしました。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org9278943" class="outline-3"&gt;
&lt;h3 id="org9278943"&gt;&lt;span class="section-number-3"&gt;2.2&lt;/span&gt; データベース/SQLAlchemyを使ってみて&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-2"&gt;
&lt;p&gt;
SQLは&lt;a href="https://www.amazon.com/Learning-SQL-Generate-Manipulate-Retrieve/dp/1492057614/"&gt;Learning SQL&lt;/a&gt;という入門書を読んだくらいで、ネットで検索しながら基本的なSELECT * FROM &amp;lt;table&amp;gt;のようなコマンドが使える程度でした。&lt;a href="https://docs.sqlalchemy.org/en/14/orm/tutorial.html"&gt;SQLAlchemyのチュートリアル&lt;/a&gt;も目を通しました。
&lt;/p&gt;

&lt;p&gt;
実際にPythonのオブジェクトをDBに書き込むためのテーブル構造を考えてみて、Python(だけではありませんが)とSQLの相性がとても悪いことがわかりました。SQLにはリストも配列も無いのです! いろいろ調べてみて、リストや配列等のオブジェクト間の関係を規定するデータ構造のために、テーブルを作るのが普通であることがわかりました。これはSQL初級者の私には衝撃的な気づきでした。
&lt;/p&gt;

&lt;p&gt;
また、sqlite3のデータタイプが貧弱であることも驚きでした。なんと、NULL, INTEGER, REAL, TEXT, BLOB の5種類しか無いのです。ネットで調べると、BooleanはIntegerを使い、EnumはTextで表現するらしいことを知り、やはりショックを受けました。しかしここはSQLAlchemy(SA)が補強してくれていました。SAのお陰で、PythonのTrue/FalseやEnumをそのまま使えるのは非常に助かりました。
&lt;/p&gt;

&lt;p&gt;
デバッグも少し大変でした。ORMを使って抽象化されたPythonオブジェクトを介してデータベースにアクセスしているのに、問題が起こると、結局はデータベースが想定通りに反映されているのかを確認するために、sqlite3のコマンドラインからSQLコマンドをたたく必要がありました。
&lt;/p&gt;

&lt;p&gt;
今回はデータベースを使ってみたかったので自己満足していますが、プログラムの比較的単純なステートを永続化するためにデータベースを使うのはやりすぎ(overkill)であると思いました。フラットファイルにpickleする方が簡単だし性能もよかったです。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org88f2714" class="outline-2"&gt;
&lt;h2 id="org88f2714"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; 次の構想&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
次回作ですが、特に面白いアイデアがあるわけでも無いので、使ってみたい技術を使ってDLをマルチプレイヤー化してみたいと考えています。実はDLのデータベース化はその準備の一環です。他には、クライアント-サーバー化と、サーバーのasync対応をやりたいと考えています。ライブラリとしては&lt;a href="https://python-socketio.readthedocs.io/en/latest/"&gt;python-socketio&lt;/a&gt;や&lt;a href="https://flask-socketio.readthedocs.io/en/latest/"&gt;flask-socketio&lt;/a&gt;あたりに目を付けています。
&lt;/p&gt;

&lt;p&gt;
WizardryクローンであるDLの戦闘はターン制なので、マルチプレイヤー化には向いていない気もしますが、逆にターン制であることをうまく生かした戦闘システムができないかを考え中です。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Python"></category><category term="Python"></category><category term="game"></category></entry><entry><title>DL-11; DLのアルファ版を公開しました</title><link href="http://achiwa912.github.io/dl11.html" rel="alternate"></link><published>2021-04-18T00:00:00-04:00</published><updated>2021-12-03T00:00:00-05:00</updated><author><name>きょうす</name></author><id>tag:achiwa912.github.io,2021-04-18:/dl11.html</id><summary type="html">Released DL v0.1-alpha</summary><content type="html">&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orgf386260"&gt;1. はじめに&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org36f2a5c"&gt;2. アルファ版リリース&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org3c7dcf9"&gt;3. issuesをgithubで管理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org69386fb"&gt;4. 開発での経験&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org12408d5"&gt;4.1. 学んだこと&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org6e77073"&gt;4.2. まだまだなこと&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgea5818a"&gt;5. 次は、、&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf386260" class="outline-2"&gt;
&lt;h2 id="orgf386260"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; はじめに&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Rogue+Wizライクなゲーム(DL - Daemon Lord)を作るプロジェクトの11回目です。
&lt;/p&gt;

&lt;p&gt;
githubでコードを &lt;a href="https://github.com/achiwa912/daemonlord"&gt;公開&lt;/a&gt; しています。MacとLinuxで動作確認していますが、Windowsは未検証です。(いちおうWindows用のコードは入れてみました)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org36f2a5c" class="outline-2"&gt;
&lt;h2 id="org36f2a5c"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; アルファ版リリース&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
一通り実装が終わり、ゲームを通しでプレイして致命的なバグが出ないようになってきたので、アルファ版をリリースしました。zen tetrisを作った時と同じようにpygameに登録して(pygame使っていませんが、それでもいいらしいので)、twitterでつぶやいただけなので、誰か見てくれるのか分かりません。
&lt;/p&gt;

&lt;p&gt;
そもそも30〜40年前のゲームのリメイクなので、需要がほぼゼロだとは思います。まあ、Pythonの勉強という意味では役に立ったのでいいでしょう。不足していた実践経験を少し補うことはできたと思います。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3c7dcf9" class="outline-2"&gt;
&lt;h2 id="org3c7dcf9"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; issuesをgithubで管理&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
バグなどの問題点管理をgithub上でするようにしました。自分でissue登録して自分でfix、closeしていくだけなので少し寂しい感じです。前近代的にexcelでバグ管理するよりは、職場で使っているjiraに近くていい感じです。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org69386fb" class="outline-2"&gt;
&lt;h2 id="org69386fb"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; 開発での経験&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org12408d5" class="outline-3"&gt;
&lt;h3 id="org12408d5"&gt;&lt;span class="section-number-3"&gt;4.1&lt;/span&gt; 学んだこと&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-4-1"&gt;
&lt;p&gt;
Pythonで用意されているlist, tuple, dict, namedtuple, enumなどのデータ構造にだいぶ慣れました。setは重複排除できるだけの使いにくい(順番が変わるので)listといった印象で、ほとんど使いませんでした。list comprehensionやgenerator expressionの便利さに感動しました。walrus expression(&lt;code&gt;:=&lt;/code&gt;)は結構微妙でした。うまく使っても1,2行減るくらいで、可読性が上がるわけでもないので。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6e77073" class="outline-3"&gt;
&lt;h3 id="org6e77073"&gt;&lt;span class="section-number-3"&gt;4.2&lt;/span&gt; まだまだなこと&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-4-2"&gt;
&lt;p&gt;
クラスの設計が下手だと思います。後から様々なフラグアトリビュートを追加して複雑になる傾向がありました。今回はリアルタイムキースキャン以外はほぼ標準ライブラリのみのため、サードパーティーライブラリの使用スキルも身についていません。
&lt;/p&gt;

&lt;p&gt;
きちんとしたプロジェクトでは致命的と思いますが、今回はユニットテストを全くしませんでした。作ったきり、一度も通っていないコードパスが結構残っていそうです。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgea5818a" class="outline-2"&gt;
&lt;h2 id="orgea5818a"&gt;&lt;span class="section-number-2"&gt;5&lt;/span&gt; 次は、、&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;p&gt;
バグが見つかったら直して、というようにペースを落として開発継続していくつもりです。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Python"></category><category term="Python"></category><category term="game"></category></entry><entry><title>DL-10; だいぶ出来てきた</title><link href="http://achiwa912.github.io/dl10.html" rel="alternate"></link><published>2021-04-12T00:00:00-04:00</published><updated>2021-12-03T00:00:00-05:00</updated><author><name>きょうす</name></author><id>tag:achiwa912.github.io,2021-04-12:/dl10.html</id><summary type="html">implemented many features</summary><content type="html">&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org26528cd"&gt;1. はじめに&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orge347a0b"&gt;2. 一通り実装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgab85845"&gt;3. DLゲームシステムの特徴&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org24dd49c"&gt;4. 次は、、&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org26528cd" class="outline-2"&gt;
&lt;h2 id="org26528cd"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; はじめに&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Rogue+Wizライクなゲーム(DL - Daemon Lord)を作るプロジェクトの10回目です。
&lt;/p&gt;

&lt;p&gt;
githubでコードを &lt;a href="https://github.com/achiwa912/daemonlord"&gt;公開&lt;/a&gt; しています。MacとLinuxで動作確認していますが、Windowsは未検証です。(いちおうWindows用のコードは入れてみました)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orge347a0b" class="outline-2"&gt;
&lt;h2 id="orge347a0b"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; 一通り実装&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
だいぶ時間が空いてしまいましたが、だいぶ実装が進みました。魔法が一通り使えるようになり、宝箱も罠付きで用意しました。
&lt;/p&gt;

&lt;p&gt;
現在、実際にプレイしながらバグ取りとバランス調整をしています。まだまだ基本システム部分で大きなバグが出ていて、完成度はアルファ版未満です。中ボスとの対決の前に階段で下に行くか聞かれたり、逃げるとボス対決が終了したりしています 笑。
&lt;/p&gt;

&lt;p&gt;
システム部分では、迷宮への出入りとフロア間の移動が思いの外複雑で、バグが収束しないので条件を整理して大きく手直ししました。通常の階段による上下だけでなく、セーブデータからのresumeや、魔法でのフロア移動でも破綻せずに動くようにするのは大変でした。
&lt;/p&gt;

&lt;p&gt;
githubにREADMEを用意して、一通りゲームの説明を英語で書きました。Wizardryは昔のシンプルなゲームですが、文章で説明してみると結構な量になりました。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgab85845" class="outline-2"&gt;
&lt;h2 id="orgab85845"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; DLゲームシステムの特徴&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
DL(Daemon Lord)のゲームシステムでの特徴は、入る度にダンジョンが自動生成されることです。当初は、Rogueのように毎回地下1階からプレイする(迷宮内ではセーブできない)ようにするつもりでしたが、レベルは上がったまま地下1階からずっと歩いて冒険するのは面倒かつ、魔法が比較的低層で切れてしまうことから、魔法(mage level 2のtsubasa)での移動を基本にすることにしました。
&lt;/p&gt;

&lt;p&gt;
魔法tsubasaを使うと、これまで潜った最深階の最初の部屋(上り階段のある部屋)までテレポーテーションすることができます。tsubasaのお陰で、常に自分のレベルにあったフロアから冒険をスタートできるようになりました。
&lt;/p&gt;

&lt;p&gt;
このため、常に下り階段を探すスタイルの冒険になります。時折、そのフロア内のどこかにランダム配置された鍵を探さないと入れない部屋を用意して、必ずしも常に最短コースが狙えないように工夫しました。
&lt;/p&gt;

&lt;p&gt;
その結果、オリジナルのWizardryとはゲームバランスがだいぶ変わってしまいましたが、それなりに遊べるシステムに仕上がってきているように思います。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org24dd49c" class="outline-2"&gt;
&lt;h2 id="org24dd49c"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; 次は、、&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
デバッグを進めてアルファ版として公開できるようにしたいです。一回通してプレイできるようになったらアルファ版認定してよいでしょうか。
&lt;/p&gt;

&lt;p&gt;
全滅パーティーの救出はまだ入っていませんが、要りますかね。DLでは比較的自由にセーブ、やり直しができるので、パーティーの誰かが死んだりドレインされたらリセットして再開するような気がしています。
&lt;/p&gt;

&lt;p&gt;
いちおうのエンディング後(地下11階〜)の冒険用データも用意しないと。ダンジョンフロア自体はメモリの許す限り深い階に対応しているのですが。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Python"></category><category term="Python"></category><category term="game"></category></entry><entry><title>DL-9; 宿と病院、戦闘での魔法</title><link href="http://achiwa912.github.io/dl9.html" rel="alternate"></link><published>2021-03-26T00:00:00-04:00</published><updated>2021-12-03T00:00:00-05:00</updated><author><name>きょうす</name></author><id>tag:achiwa912.github.io,2021-03-26:/dl9.html</id><summary type="html">Inn, hospital and spells in battles</summary><content type="html">&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orge77ee81"&gt;1. はじめに&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org38989a8"&gt;2. 宿と病院&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orge186d73"&gt;3. 戦闘&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org47d9228"&gt;4. セーブとロード&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orga3e5f35"&gt;5. 次は、、&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orge77ee81" class="outline-2"&gt;
&lt;h2 id="orge77ee81"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; はじめに&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Rogue+Wizライクなゲーム(仮称Daemon Lord)を作るプロジェクトの9回目です。
&lt;/p&gt;

&lt;p&gt;
githubでコードを &lt;a href="https://github.com/achiwa912/daemonlord"&gt;公開&lt;/a&gt; しています。MacとLinuxで動作確認していますが、Windowsは未対応です。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org38989a8" class="outline-2"&gt;
&lt;h2 id="org38989a8"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; 宿と病院&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
前々回に予告した宿をようやく実装しました。宿は宿泊することでレベルアップします。このレベルアップ判定と処理が思いのほか複雑で、実装に結構苦労しました。'ず'さんの &lt;a href="https://wiliki.zukeran.org/index.cgi?Wizardry1%2FApple%2F%B2%F2%C0%CF%A5%E1%A5%E2"&gt;解析ページ&lt;/a&gt; にすっかりお世話になりました。
&lt;/p&gt;

&lt;p&gt;
宿屋に泊まるとHPとMPが回復し、レベルアップチェックを行います。次のレベルに十分な経験値を得ていればレベルアップしてHPが増え、クラスによって魔法を覚えていきます。年齢の関係する特性値の変化を除いて、ほぼApple版Wizardryの実装そのままになっていると思います。
&lt;/p&gt;

&lt;p&gt;
一人ずつちまちま宿泊するのは面倒なので、より普通に、パーティー全員で宿泊するよう変えています。年齢を無視したことで、存分に高級な部屋に宿泊できるようになりました 笑。
&lt;/p&gt;

&lt;pre class="example"&gt;
|   v)lake view suites   1200 gold                           |        
|   p)residential suites 3000 gold                           |        
|   or l)eave                                                |        
|   Which rooms to stay today? &amp;gt; p                           |        
| * Today's dinner is supreme course w/ champagne.           |        
| * Alex went to bed...                                      |        
| * Level up!                                                |        
| * Gained strength by 2 points.                             |        
|   Gained i.q. by 1 points.                                 |        
|   Gained vitality by 1 points.                             |        
|   Lost agility by 1 points.                                |        
|   Lost luck by 1 points.                                   |        
|   Your hp increased by 25 points.                          |        
&lt;/pre&gt;
&lt;p&gt;
これはレベルアップしたところです。複数レベルまとめてアップするのでstrは+2しています。
&lt;/p&gt;

&lt;p&gt;
病院は寺院(temple of cant)の代わりですが、やっていることは一緒です。麻痺以上の状態で迷宮から出てくると、救急車がやってきて病院に運ばれます(演出は無し)。死亡や灰からの復活も可能です。しかし灰ってすごいですよね。。。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orge186d73" class="outline-2"&gt;
&lt;h2 id="orge186d73"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; 戦闘&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
殴り合いだけでは地味なので、魔法をいくつか実装しました。katino相当で眠らせて倍打攻撃もできます。halito/mahalito/lahalito/dalto/madalto/malikto/tiltowait相当は全て同じメソッドで実現しています。
&lt;/p&gt;

&lt;pre class="example"&gt;
 daemon lord - dl - [battle] floor: 1 (5/8) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^|   1) 4 men in uniform           (4)    |^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^|                                        |^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^|                                        |^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^|                                        |^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^| * What spell to cast?                  |^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^| &amp;gt; taika                                |^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^| * hit any key or t)ake back &amp;gt;          |^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^| * Fast casted taika.                   |^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^|   man in uniform incurred 15 damage.   |^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^|   man in uniform is killed.            |^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^|   man in uniform incurred 13 damage.   |^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^|   man in uniform is killed.            |^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^|   man in uniform incurred 8 damage.    |^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^|   man in uniform incurred 19 damage.   |^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^|   man in uniform is killed.            |^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^| * Cal parried.                         |^^^^^^^^^^^^^^^^^^^^^^^^
 # name       class  ac   hp status       * south                               
 1 Alex       G-FIG   2   38 parry        * east                                
 2 Betty      G-FIG   3   15 parry          Which direction? - ;)leave &amp;gt; l      
 3 Cal        G-SAM   4   16 parry        * Unlocked.                           
 4 Debora     N-THI  10   11 parry        * east                                
 5 Emily      G-PRI  10   24 parry        * east                                
 6 Fast       G-MAG  10   33 taika        * *** encounter *** 
&lt;/pre&gt;

&lt;p&gt;
mahalito相当を唱えてモンスターを蹴散らしたところです。Macのターミナルの仕様のせいか、1画面コピペするのに、3回に分けないとうまくいきません。ひどい仕様です。
&lt;/p&gt;

&lt;p&gt;
これまでのところ実装したのは全てパーティーメンバーが使う、攻撃、HP回復、AC上下、ステータス攻撃(katino, monitino等)です。また、自分たちの位置を表示するdumapic相当、モンスターを識別するlatumapic相当、パーティー全体のACを迷宮にいる間-2するmaporfic相当も実装しています。よくお世話になるmadi相当も入れました。
&lt;/p&gt;

&lt;p&gt;
ここでも色々なバグが出ました。敵のグループをPythonのリストで管理しているのですが、for文で回しているのに死亡した敵を都度リストから抜いていて不思議な現象が起きたり、死んだはずの敵が攻撃してきたり、ここに来て基本関数であるダイスの計算が間違っていることに気がついたり、、、。
&lt;/p&gt;

&lt;p&gt;
ちなみにPythonのリストをiterateしながら中身を抜きたいような場合は、いったんリストをコピーしてコピーしたリストをiterateしながら、オリジナルから抜いていくようにするとよいようです。最近読んだPython本にも書いてあった気がします。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org47d9228" class="outline-2"&gt;
&lt;h2 id="org47d9228"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; セーブとロード&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
いちおうセーブとロードも実装しました。セーブ(&amp;amp;終了)はEdge of townと迷宮でのキャンプ中にすることができます。ロードはセーブしたところからの再開で、Edge of townでのみすることができます。Edge of townで再開の操作をしても、迷宮でセーブした場合には迷宮のセーブ位置からの再開になります。
&lt;/p&gt;

&lt;p&gt;
Pythonのpickleがどこまでクラスオブジェクトを保存してくれるのかいまひとつわからず、セーブとロードにはかなり試行錯誤しました。
&lt;/p&gt;

&lt;p&gt;
セーブデータには多分まだ手が入るので、今セーブしたデータは無駄になってしまう可能性が高いです。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga3e5f35" class="outline-2"&gt;
&lt;h2 id="orga3e5f35"&gt;&lt;span class="section-number-2"&gt;5&lt;/span&gt; 次は、、&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;p&gt;
そろそろ宝箱の実装でしょうか。魔法の実装もたくさん残っています。一通りシステムが完成して、初めてシナリオと、オリジナルのモンスターやアイテムデータを考えることになりそうです。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Python"></category><category term="Python"></category><category term="game"></category></entry><entry><title>DL-8; キャンプと戦闘の基本部分</title><link href="http://achiwa912.github.io/dl8.html" rel="alternate"></link><published>2021-03-21T00:00:00-04:00</published><updated>2021-12-03T00:00:00-05:00</updated><author><name>きょうす</name></author><id>tag:achiwa912.github.io,2021-03-21:/dl8.html</id><summary type="html">camp and basic battle</summary><content type="html">&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orgda907ef"&gt;1. はじめに&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org7d5c2cc"&gt;2. 表示バグの解決&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org82d9a57"&gt;3. キャンプ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org1f182f0"&gt;4. 戦闘基本&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org090b74b"&gt;5. 次は、、&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgda907ef" class="outline-2"&gt;
&lt;h2 id="orgda907ef"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; はじめに&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Rogue+Wizライクなゲーム(仮称Daemon Lord)を作るプロジェクトの8回目です。今回はキャンプと戦闘の非常に基本的な部分を実装しています(現在進行形)。
&lt;/p&gt;

&lt;p&gt;
githubでコードを &lt;a href="https://github.com/achiwa912/daemonlord"&gt;公開&lt;/a&gt; しています。MacとLinuxで動作確認していますが、Windowsは未対応です。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7d5c2cc" class="outline-2"&gt;
&lt;h2 id="org7d5c2cc"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; 表示バグの解決&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
これまでずっと妙な表示バグに悩まされてきました。DL(Daemon Lord)では仮想画面を使ったダブルバッファリングをしているのですが、ふと、一部古い画面を表示してしまうのです。致命的なバグではないのでしばらく放置してきましたが、ようやく原因がわかりました。メッセージ表示メソッドにおいて、メッセージウインドウのみを書き換えて他は前回の画面のまま表示していたのです。現象から原因を推測するのが難しいバグでした。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org82d9a57" class="outline-2"&gt;
&lt;h2 id="org82d9a57"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; キャンプ&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
キャンプはキャラクター表示からの魔法(スペル)使用やアイテムの装備など、使い回しでそれなりに実装できました。キャンプ途中のみとはいえ、回復魔法が使えるのは心強いです。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1f182f0" class="outline-2"&gt;
&lt;h2 id="org1f182f0"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; 戦闘基本&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
Wizardryのシステムにおいて、戦闘は最も複雑な部分です。その中で、逃亡、単純な打撃、parry(身を守る)と戦闘終了時の経験値とgoldの取得のみを実装しました。打撃は更に属性攻撃やドレイン、クリティカルなどの効果があります。
&lt;/p&gt;

&lt;pre class="example"&gt;
 daemon lord - dl - [battle] floor: 1 (8/14) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^|   1) 1 robber                   (1)    |^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^|                                        |^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^|                                        |^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^|                                        |^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^....###.#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^|   Betty's action? &amp;gt; f                  |^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^|   Cal's action? &amp;gt; f                    ||^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^|   Debora's action? &amp;gt; p                 |^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^|   Emily's action? &amp;gt; p                  ||^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^|   Fast's action? &amp;gt; p                   ||^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^| * hit any key or t)ake back &amp;gt;          |^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^| * Alex stabs violently at robber and   ||^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^|   hits 1 times for 2 damage.           |^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^| * Fast parried.                        |^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^| * Betty stabs violently at robber and  ||^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^|   hits 1 times for 4 damage.           ||^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^|   robber is killed.                    |^^^^^^^^^^^^^^^^^^^^^^^^
 # name       class  ac   hp status       * south                               
 1 Alex       G-FIG   2   13 fight          Which direction? - ;)leave &amp;gt; o      
 2 Betty      G-FIG   3    8 fight          Which direction? - ;)leave &amp;gt; j      
 3 Cal        G-SAM   4   16 fight        * Unlocked.                           
 4 Debora     N-THI  10   11 parry        * south                               
 5 Emily      G-PRI  10   12 parry        * south                               
 6 Fast       G-MAG  10    7 parry        * *** encounter ***   
&lt;/pre&gt;

&lt;p&gt;
メッセージのみの戦闘は地味ですねぇ。まあWizardryはこれでいいのです。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org090b74b" class="outline-2"&gt;
&lt;h2 id="org090b74b"&gt;&lt;span class="section-number-2"&gt;5&lt;/span&gt; 次は、、&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;p&gt;
戦闘の実装を進めます。魔法がキャンプと戦闘で思ったよりも共通化が難しいので、工夫が必要です。不本意ながら、それぞれ独立した実装になってしまうかもしれません。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Python"></category><category term="Python"></category><category term="game"></category></entry><entry><title>DL-7; ダンジョン内移動</title><link href="http://achiwa912.github.io/dl7.html" rel="alternate"></link><published>2021-03-15T00:00:00-04:00</published><updated>2021-12-03T00:00:00-05:00</updated><author><name>きょうす</name></author><id>tag:achiwa912.github.io,2021-03-15:/dl7.html</id><summary type="html">Get in and out of dungeon.  Move between floors.</summary><content type="html">&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org989428c"&gt;1. はじめに&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org0d06424"&gt;2. 仮想マップ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orga7dc185"&gt;3. ドアオープン、ロック解除&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org5ff4f1a"&gt;4. フロア間移動&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org99d99c1"&gt;5. ダンジョンへの出入り&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org000d577"&gt;6. 次は、、&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org989428c" class="outline-2"&gt;
&lt;h2 id="org989428c"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; はじめに&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Rogue+Wizライクなゲーム(仮称Daemon Lord)を作るプロジェクトの7回目です。今回は宿屋を作ると予告しましたが、まだ必要ないので先にダンジョンへの出入り、フロア間移動を作りました。
&lt;/p&gt;

&lt;p&gt;
githubでコードを &lt;a href="https://github.com/achiwa912/daemonlord"&gt;公開&lt;/a&gt; しています。MacとLinuxで動作確認していますが、Windowsは未対応です。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0d06424" class="outline-2"&gt;
&lt;h2 id="org0d06424"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; 仮想マップ&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
これまでのスクリーンショットではマップ画面が全て見えていましたが、自分たちの隣接1文字分しか見えないように仮想マップを実装しました。見えないところは &lt;code&gt;^&lt;/code&gt; で隠れています。
&lt;/p&gt;

&lt;p&gt;
ダンジョンに入ったばかりの画面。周囲1マス分だけが見えています。
&lt;/p&gt;
&lt;pre class="example"&gt;
 daemon lord - dl - [maze] floor: 1 (3/22) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^...^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^.@.^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^...^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;/pre&gt;

&lt;p&gt;
歩き回ったところが見えるようになります。見えるようになったマップを管理するのが仮想マップです。 &lt;code&gt;#&lt;/code&gt; は壁、 &lt;code&gt;.&lt;/code&gt; は歩ける床、そして &lt;code&gt;+&lt;/code&gt; はドアです。
&lt;/p&gt;

&lt;pre class="example"&gt;
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^###+##^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^#@...#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^#....#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^.&amp;lt;.+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^...#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^...#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^####^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga7dc185" class="outline-2"&gt;
&lt;h2 id="orga7dc185"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; ドアオープン、ロック解除&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
ドアのオープンも実装しました。隣に移動して &lt;code&gt;o&lt;/code&gt; キー、方向指定でドアを開けることができます。
&lt;/p&gt;

&lt;p&gt;
右側のドアを開けたところ。床のタイルに変わります。:
&lt;/p&gt;
&lt;pre class="example"&gt;
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^###+##^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^#....#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^#....#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^.&amp;lt;@.^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^...#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^...#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^####^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 # name       class  ac   hp status       * east                                
 1 Alex       G-FIG  10   13 OK           * south                               
 2 Betty      G-FIG  10   15 OK           * south                               
 3 Cal        G-SAM  10   16 OK           * south                               
 4 Debora     N-THI  10   11 OK           * north                               
 5 Emily      G-PRI  10   12 OK             Which direction? - ;)leave &amp;gt; l      
 6 Fast       G-MAG  10    7 OK           * Opened.         
&lt;/pre&gt;

&lt;p&gt;
隣の部屋に入れました。
&lt;/p&gt;

&lt;pre class="example"&gt;
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^###+#########^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^#....##....@#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^#....##.....#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^.&amp;lt;........#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^...#+.....#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^...#+.....#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^####+.....#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^.######^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;/pre&gt;

&lt;p&gt;
&lt;code&gt;*&lt;/code&gt; はロック付きドアです。ロックにトライする部分は未実装で、今は普通にあきます。
&lt;/p&gt;

&lt;pre class="example"&gt;
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^#*#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^###@#########^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^#....##.....#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^#....##.....#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5ff4f1a" class="outline-2"&gt;
&lt;h2 id="org5ff4f1a"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; フロア間移動&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
ひたすらフロアを歩き回っていると、下り階段 &lt;code&gt;&amp;gt;&lt;/code&gt; がありました。
&lt;/p&gt;
&lt;pre class="example"&gt;
^^^^^^^^.....#####.#^^^^^^^^^^+.###^^^^#.#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^...^^^^^^#.#^^^^^^^^^^....#^^^^...^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^#.#^^^^^^#.#^^^^^^^^^^....#^^^^.@.^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^#.#^^^^^^#.###^^^^^^^^^...#^^^^.&amp;gt;.^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
....#####.#^^^^^^....#^^^^^^^^^...#^^^^...^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..........#^^^^^^....###^^^^^^^#.##^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

&lt;/pre&gt;

&lt;p&gt;
下り階段に乗ると、下に行くか聞かれます。
&lt;/p&gt;

&lt;pre class="example"&gt;
^^^^^^^^#.#^^^^^^#.#^^^^^^^^^^....#^^^^...^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^#.#^^^^^^#.###^^^^^^^^^...#^^^^.@.^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
....#####.#^^^^^^....#^^^^^^^^^...#^^^^...^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..........#^^^^^^....###^^^^^^^#.##^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
....#######^^^^^^......#^^^^^^##.#####^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...^^^^^^^^^^^^^^^^..#.#^^^^^^#......#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#.##########^^^^^^^###.#^^^^^^#......#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#.##.......#^^^^^^^^^#.#^^^^^^#......#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#.##.......#^^^^^^^^^#.#^^^^^^#......#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...........#^^^^^^^^^#.#^^^^^^#......#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 # name       class  ac   hp status       * south                               
 1 Alex       G-FIG  10   13 OK           * south                               
 2 Betty      G-FIG  10   15 OK           * south                               
 3 Cal        G-SAM  10   16 OK           * south                               
 4 Debora     N-THI  10   11 OK           * south                               
 5 Emily      G-PRI  10   12 OK           * south                               
 6 Fast       G-MAG  10    7 OK             Stairs.  Go down? (y/n) &amp;gt;   
&lt;/pre&gt;

&lt;p&gt;
yと答えると、地下二階に移動しました。フロアが 2 になっているところに注目です。来たばかりなので自分の周囲しか見えていません。dl(daemon lord)では、まだ行ったことのないフロアに移動する際に、フロアデータを生成しています。現状では、メモリの許す限り深く下ることができます 笑
&lt;/p&gt;

&lt;pre class="example"&gt;
 daemon lord - dl - [maze] floor: 2 (3/3) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^...^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^.@.^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^...^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;/pre&gt;

&lt;p&gt;
&lt;code&gt;&amp;lt;&lt;/code&gt; が上り階段です。もちろん、上のフロアに戻れます。
&lt;/p&gt;

&lt;pre class="example"&gt;
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^#####^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^#...#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^#.&amp;lt;.#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^#...#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^##.##^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^#@+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^...^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

&lt;/pre&gt;

&lt;p&gt;
地下1階に戻りました。
&lt;/p&gt;

&lt;pre class="example"&gt;
 daemon lord - dl - [maze] floor: 1 (73/6) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^####^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^...#^^^^^^^^^^^...#.....###^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^...#^^^^^^^^^^^...........#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^.....##...+#^^^^^^^^^^...#.....#.#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^...........#^^^^^^^^^^#.#^^^^^^#.#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^.....#####.#^^^^^^^^^^+.###^^^^#.#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^...^^^^^^#.#^^^^^^^^^^....#^^^^.@.^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^#.#^^^^^^#.#^^^^^^^^^^....#^^^^...^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^#.#^^^^^^#.###^^^^^^^^^...#^^^^.&amp;gt;.^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
....#####.#^^^^^^....#^^^^^^^^^...#^^^^...^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org99d99c1" class="outline-2"&gt;
&lt;h2 id="org99d99c1"&gt;&lt;span class="section-number-2"&gt;5&lt;/span&gt; ダンジョンへの出入り&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;p&gt;
地下1階から上り階段を使うと、地上に戻れます。
&lt;/p&gt;

&lt;pre class="example"&gt;
 daemon lord - dl - [maze] floor: 1 (4/8) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^#............#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^#............#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^#............#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^#............#^^^^^^^^^^^^^^^^^^^^^^^^^^^...
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^###.##########^^^^^^^^^^^^^^^^^^^^^^^^^^^...
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^###.#########^^^^^^^^^^^^^^^^^^^^^^^^^^^^...
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^#....##.....#^^^^^^^^^^^^^^^^^^^^^^^^^^^^...
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^#....##.....#^^^^^^^^^^^^^^^^^^^^^^^^^^^^#.#
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^.&amp;lt;@.......#^^^^^^^^^^^^^^^^^^^^^^^^^^^^#.#
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^...#+.....#^^^^^^^^^^^^^^^^^^^^....#####.#
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^...#+.....#^^^^^^^^^^^^^^^^^^^^..........#
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^####......#^^^^^^^^^^^^^^^^^^^^....######
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^#.######^^^^^^^^^^^^^^^^^^^^...^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^#.#^^^^^^^^^^^^^^^^^^^^^^^^^#.########
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^#.#^^^^^^^^^^^^^^^^^^^^^^^^^#.##......
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^##.##^^^^^^^^^^^^^^^^^^^^^.###.##......
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^#...#^^^^^^^^^^^^^^^^^^^^^+............
 # name       class  ac   hp status       * west                                
 1 Alex       G-FIG  10   13 OK           * west                                
 2 Betty      G-FIG  10   15 OK           * west                                
 3 Cal        G-SAM  10   16 OK           * west                                
 4 Debora     N-THI  10   11 OK           * west                                
 5 Emily      G-PRI  10   12 OK           * west                                
 6 Fast       G-MAG  10    7 OK             Exit from dungeon? (y/n) &amp;gt; 
&lt;/pre&gt;

&lt;p&gt;
戻りました。
&lt;/p&gt;
&lt;pre class="example"&gt;
 daemon lord - dl - [edge_of_town] floor: 0 (3/8)                               
	  | * *** Edge of Town ***                                     |        
	  |   m)aze                                                    |        
	  |   t)raining grounds                                        |        
	  |   l)eave game                                              |        
	  |   c)astle                                                  |        
	  |   Command?  &amp;gt;                                              |        
	  |                                                            |        
&amp;lt;snip&amp;gt;
 # name       class  ac   hp status       * west                                
 1 Alex       G-FIG  10   13 OK           * west                                
 2 Betty      G-FIG  10   15 OK           * west                                
 3 Cal        G-SAM  10   16 OK           * west                                
 4 Debora     N-THI  10   11 OK           * west                                
 5 Emily      G-PRI  10   12 OK           * west                                
 6 Fast       G-MAG  10    7 OK             Exit from dungeon? (y/n) &amp;gt; y        
&lt;/pre&gt;

&lt;p&gt;
そして、もう一度 M)aze を選択すると、、、
&lt;/p&gt;

&lt;pre class="example"&gt;
 daemon lord - dl - [maze] floor: 1 (5/2) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^...^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^.@.^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^...^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;/pre&gt;

&lt;p&gt;
部屋の配置が異なる新たなダンジョンに入ることになります。先ほどの地下1階とマップが変わっているのがわかるでしょうか。
&lt;/p&gt;

&lt;pre class="example"&gt;
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^#.........#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^#.........##.+....#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^#....&amp;lt;...........@#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^#.........##+######^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^#####.#####^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^#.#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^#.#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^#.#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org000d577" class="outline-2"&gt;
&lt;h2 id="org000d577"&gt;&lt;span class="section-number-2"&gt;6&lt;/span&gt; 次は、、&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-6"&gt;
&lt;p&gt;
地味な実装が続きますが、次はキャンプですかね。ではまた。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Python"></category><category term="Python"></category><category term="game"></category></entry><entry><title>DL-6; 買い物とアイテム装備</title><link href="http://achiwa912.github.io/dl6.html" rel="alternate"></link><published>2021-03-12T00:00:00-05:00</published><updated>2021-12-03T00:00:00-05:00</updated><author><name>きょうす</name></author><id>tag:achiwa912.github.io,2021-03-12:/dl6.html</id><summary type="html">buy, sell, equip, idendity, uncurse, etc.</summary><content type="html">&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orgb71c3e7"&gt;1. はじめに&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org9b8188c"&gt;2. アイテム装備&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org90bf733"&gt;3. 呪いを解く、識別する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org7cd764b"&gt;4. アイテム売買&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org06daa72"&gt;5. 次は、、&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb71c3e7" class="outline-2"&gt;
&lt;h2 id="orgb71c3e7"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; はじめに&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Rogue+Wizライクなゲーム(仮称Daemon Lord)を作るプロジェクトの6回目です。今回は酒場(tavern)と店(trader)のメニューを作り込みました。アイテムの装備、売買、識別、呪いの除去などです。
&lt;/p&gt;

&lt;p&gt;
githubでコードを &lt;a href="https://github.com/achiwa912/daemonlord"&gt;公開&lt;/a&gt; しています。MacとLinuxで動作確認していますが、Windowsは未対応です。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org9b8188c" class="outline-2"&gt;
&lt;h2 id="org9b8188c"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; アイテム装備&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
アイテム装備は酒場でキャラクターをidentifyする画面から行います。アイテムを選択して装備します。装備したアイテムは名前の横に &lt;code&gt;*&lt;/code&gt; が付き、パーティーウインドウのACが即時で(?)反映されます。
&lt;/p&gt;

&lt;pre class="example"&gt;
daemon lord - dl - [hawthorne_tavern] floor: 1 (0/0)                           
	 |   Betty            L  1 g-fig human                        |        
	 |   | * which item?  # or l)leave            |               |        
	 |   |   1) mace                              | 1             |        
	 |   |   u)se e)quip t)rade d)rop l)eave &amp;gt;    |28             |        
	 |   |                                        | 6             |        
	 |   |                                        | 0             |        
	 |   |                                        |               |        
	 |   |                                        |               |        
	 |   |                                        |               |        
	 |   mage  0/0/0/0/0/0/0   priest  0/0/0/0/0/0/0/             |        
	 |   1) *mace              2) *leather armor                  |        
	 |   3) *small shield      4)                                 |        
	 |   5)                    6)                                 |        
	 |   7)                    8)                                 |        
	 |                                                            |        
	 |   i)tems s)pells l)eave &amp;gt; i                                |        
	 |                                                            |        
# name       class  ac   hp status                                             
1 Alex       G-FIG  10   13 OK                                                 
2 Betty      G-FIG   6   15 OK                                                 
3 Cal        G-SAM  10   16 OK                                                 
4 Debora     N-THI  10   11 OK                                                 
5 Emily      G-PRI  10   12 OK                                                 
6 Fast       G-MAG  10    7 OK     
&lt;/pre&gt;

&lt;p&gt;
不確定名の呪いアイテムも装備可能です(笑)。もちろん、呪われます(&lt;code&gt;&amp;amp;&lt;/code&gt; 印)。
&lt;/p&gt;

&lt;pre class="example"&gt;
daemon lord - dl - [hawthorne_tavern] floor: 1 (0/0)                           
	 |   Alex             L  1 g-fig dwarf                        |        
	 |   | * which item?  # or l)leave            |               |        
	 |   |   1) ?shield                           | 1             |        
	 |   |   u)se e)quip t)rade d)rop l)eave &amp;gt; e  |32             |        
	 |   | * Cursed!                              |10             |        
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org90bf733" class="outline-2"&gt;
&lt;h2 id="org90bf733"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; 呪いを解く、識別する&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
店(Trader Jay's)で呪いを解くことができます。有料です。アイテムは持ち物から無くなり、不確定名だったとしても正式名を教えてくれます。
&lt;/p&gt;

&lt;pre class="example"&gt;
| * *** Trader Jay's ***                                     |        
|   Who? - # or l)eave &amp;gt; 1                                   |        
| * Welcome, Alex.                                           |        
| *   You have 50000 gold.                                   |        
|   b)uy s)ell u)ncurse i)dentify p)ool gold l)eave &amp;gt; u      |        
| * Which item to uncurse? -  # or leave                     |        
|   1)&amp;amp;?shield         4000                                  |        
|   # or l)eave &amp;gt; 1                                          |        
| * Uncursed shield -3.                                      |        
&lt;/pre&gt;

&lt;p&gt;
呪われていなければ、これも有料で不確定名アイテムを識別してもらえます。bishopがいるので使いませんかね。。。
&lt;/p&gt;

&lt;pre class="example"&gt;
| * *** Trader Jay's ***                                     |        
|   Who? - # or l)eave &amp;gt; 1                                   |        
| * Welcome, Alex.                                           |        
| *   You have 50000 gold.                                   |        
|   b)uy s)ell u)ncurse i)dentify p)ool gold l)eave &amp;gt; i      |        
| * Which item to identify? -  # or leave                    |        
|   1) ?shield         4000                                  |        
|   # or l)eave &amp;gt; 1                                          |        
| * Identified as shield -3.                                 |        
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7cd764b" class="outline-2"&gt;
&lt;h2 id="org7cd764b"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; アイテム売買&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
順番が逆になりましたが、アイテムの売買ができます。
&lt;/p&gt;

&lt;p&gt;
買い物では別ウインドウ(笑)が開きます。武器、鎧、盾などのページをh, lキーで切り替え、j, kキーで買いたいアイテムを選択して x キーで購入します。装備出来ないアイテムには#が、現在の持ち金で購入できるアイテムには$が付きます。
&lt;/p&gt;

&lt;pre class="example"&gt;
	  | | Alex has 46000 gold                   |                  |        
	  | |  jk)cursor x)choose hl)page ;)leave   |                  |        
	  | | &amp;gt; 1 long sword                    25#$|                  |        
	  | |   2 sling                          5 $|                  |        
	  | |   3 mage's bow                   500 $|                  |        
	  | |   4 bow                           25 $|                  |        
&amp;lt;snip&amp;gt;
&lt;/pre&gt;

&lt;p&gt;
買ったアイテムを売ることもできます。半額になりますが。販売可能アイテムがリストされるので、番号で指定します。以下はロングソードを売ったところです。
&lt;/p&gt;

&lt;pre class="example"&gt;
|   b)uy s)ell u)ncurse i)dentify p)ool gold l)eave &amp;gt; s      |        
| * Which item to sell? -  # or leave                        |        
|   1) shield -3       4000                                  |        
|   2) long sword      12                                    |        
|   3) robes           7                                     |        
|   4) small shield    10                                    |        
|   5) helm            50                                    |        
|   6) gloves          3000                                  |        
|   # or l)eave &amp;gt; 2                                          |        
| * I'm sure fellows'll want it.                             |        
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org06daa72" class="outline-2"&gt;
&lt;h2 id="org06daa72"&gt;&lt;span class="section-number-2"&gt;5&lt;/span&gt; 次は、、&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;p&gt;
次はいよいよダンジョンと行きたいところですが、その前に宿屋くらいは用意しておきましょうか。寺院はまだいいかな。。。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Python"></category><category term="Python"></category><category term="game"></category></entry><entry><title>DL-5; キャラクター作成</title><link href="http://achiwa912.github.io/dl5.html" rel="alternate"></link><published>2021-03-07T00:00:00-05:00</published><updated>2021-12-03T00:00:00-05:00</updated><author><name>きょうす</name></author><id>tag:achiwa912.github.io,2021-03-07:/dl5.html</id><summary type="html">create characters and add to party</summary><content type="html">&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orgaa880a3"&gt;1. はじめに&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org6412535"&gt;2. 問題発生&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgb95d611"&gt;3. キャラクター作成&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgfe2e966"&gt;4. キャラクターのパーティー追加&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgc099383"&gt;5. 次は、、&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgaa880a3" class="outline-2"&gt;
&lt;h2 id="orgaa880a3"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; はじめに&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Rogue+Wizライクなゲーム(仮称Daemon Lord)を作るプロジェクトの5回目です。久々ですが、パーティー表示ウインドウ、キャラクター作成、キャラクターのパーティー追加を作り込んでいました。
&lt;/p&gt;

&lt;p&gt;
githubでコードを &lt;a href="https://github.com/achiwa912/daemonlord"&gt;公開&lt;/a&gt; しています。MacとLinuxで動作確認していますが、Windowsは未対応です。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6412535" class="outline-2"&gt;
&lt;h2 id="org6412535"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; 問題発生&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
パーティーウインドウを実装したのですが、メッセージウインドウと同時に表示するとマップ画面が妙に狭くて見づらくなる問題が発生しました。試行錯誤の結果、パーティーウインドウの右側にメッセージウインドウを固定し、その上側を全てマップスクロールウインドウとすることで画面を広く使えるようにしました。
&lt;/p&gt;

&lt;p&gt;
今回からソースコードの引用は省略しますので、githubを参照してください。
&lt;/p&gt;

&lt;pre class="example"&gt;
 daemon lord - dl - [maze] floor: 1 (23/5) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^##########################################################...##
^^^^^^^^^^^^^^^^^##########################################################...##
^^^^^^^^^^^^^^^^^###..........####################....#####################...##
^^^^^^^^^^^^^^^^^###..........####################....#####################...+.
^^^^^^^^^^^^^^^^^###..........############++++...+....#......##############...##
^^^^^^^^^^^^^^^^^###..........+......+..@.....+..+....+......+............+...##
^^^^^^^^^^^^^^^^^###..........########........+..###+++......###################
^^^^^^^^^^^^^^^^^###..........########........##.######......####.....##########
^^^^^^^^^^^^^^^^^###############################.######......####.....##########
^^^^^^^^^^^^^^^^^###############################.#########+######.....##########
^^^^^^^^^^^^^^^^^############.......############.#########.######.....+..+...###
^^^^^^^^^^^^^^^^^####.......*.......############+#########.######.....####...###
^^^^^^^^^^^^^^^^^####.#######.......#######..........#####+######.....####...+..
^^^^^^^^^^^^^^^^^####.##########*##########..........####.....#####+######...###
 # name       class  ac   hp status       * east                                
 1 socla      G-FIG  10   11 OK             Do you? (y/n) &amp;gt; n                   
 2 flag       G-BIS  10    9 OK           * Input char: n                       
 3 joe        G-PRI  10   13 OK           * east                                
 4                                        * east                                
 5                                        * north                               
 6                                        * south
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb95d611" class="outline-2"&gt;
&lt;h2 id="orgb95d611"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; キャラクター作成&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
Wizardry的なキャラクター作成を実装しました。名前、種族(race)、アラインメントを選択したあと、年齢は指定できるようにしました。そしてボーナスポイントの振り分けです。カーソル &lt;code&gt;&amp;gt;&lt;/code&gt; をj, kで上下に動かし、h, lで値を増減させます。ボーナスポイントの再計算もできるようにしました。
&lt;/p&gt;

&lt;pre class="example"&gt;
daemon lord - dl - [training_grounds] floor: 1 (0/0)                           
	 * Distribute bonus points                                             
	     h)minus j)down k)up l)plus .)change bonus x)done                  

	   strength  10                                                        
	   iq        13                                                        
	   piety    &amp;gt;13                                                        
	   vitality   8                                                        
	   agility    8                                                        
	   luck       9                                                        

	   bonus      0                                                        
	 * mage priest bishop
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgfe2e966" class="outline-2"&gt;
&lt;h2 id="orgfe2e966"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; キャラクターのパーティー追加&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
キャラクターのパーティー追加ですが、キャラクターは20人まで登録可能なため、キャラクターを選択するメッセージウインドウの行数を超えてしまう場合があります。そこで、別ウインドウを開いてそこでスクロールしながら選択できるようにしました。下図で、 &lt;code&gt;|&lt;/code&gt; で挟まれて部分がキャラクター選択のための別ウインドウです。
&lt;/p&gt;

&lt;p&gt;
登録されているキャラクターが多くてウインドウに収まらない場合はウインドウ内でスクロールするようにしています。キャラクターを &lt;code&gt;x&lt;/code&gt; で選択すると、画面左下のパーティーウインドウに反映されます。
&lt;/p&gt;

&lt;pre class="example"&gt;
daemon lord - dl - [hawthorne_tavern] floor: 1 (0/0)                           
	 * *** trai| Add who to the party?                |                    
	   c)reate |  - j)down k)up x)choose l)eave       |                    
	   i)nspect| &amp;gt; 1 prince           Lv  1 ELF-N-MAG |                    
	   l)eave  |   2 michael          Lv  1 ELF-E-BIS |                                
	   Command?|   3 springsteen      Lv  1 HUM-G-FIG |                    
	 * *** Edge                                                            
	   m)aze                                                               
	   t)rainin                                                            
	   l)eave game                                                         
	   c)astle                                                             
	   Command?  &amp;gt; c               
	 * *** Castle ***                                                      
	   h)awthorne tavern                                                   
	   e)dge or town                                                       
	   Command? &amp;gt; h                                                        
	 * *** The Hawthorne Tavern ***                                        
	   Command? - a)dd r)emove i)nspect d)ivvy gold l)eave &amp;gt; a 
# name       class  ac   hp status                                             
1 jostle     N-FIG  10   15 OK                                                 
2                                                                              
3                                                                              
4                                                                              
5                                                                              
6
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgc099383" class="outline-2"&gt;
&lt;h2 id="orgc099383"&gt;&lt;span class="section-number-2"&gt;5&lt;/span&gt; 次は、、&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;p&gt;
このままモンスターと遭遇すると全滅必至ですから、次は買い物してアイテムを装備出来るようにしましょうかね。ではまた。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Python"></category><category term="Python"></category><category term="game"></category></entry><entry><title>DL-4; メッセージ表示ウインドウ</title><link href="http://achiwa912.github.io/dl4.html" rel="alternate"></link><published>2021-02-27T00:00:00-05:00</published><updated>2021-12-03T00:00:00-05:00</updated><author><name>きょうす</name></author><id>tag:achiwa912.github.io,2021-02-27:/dl4.html</id><summary type="html">message window and user input</summary><content type="html">&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org797e504"&gt;1. はじめに&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org4844cfa"&gt;2. メッセージウインドウクラス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgaaabf65"&gt;3. メッセージ表示メソッド&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org0ea8716"&gt;4. ユーザーインプットメソッド&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org0c27e0b"&gt;5. 1文字入力メソッド&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgece50c0"&gt;6. 次は、、&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org797e504" class="outline-2"&gt;
&lt;h2 id="org797e504"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; はじめに&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Rogue+Wizライクなゲーム(仮称Daemon Lord)を作るプロジェクトの4回目です。今回はメッセージウインドウとその上での文字列入力を実装します。
&lt;/p&gt;

&lt;p&gt;
コードのリファクタリングが進んで状況がわからなくなっていると思うので、githubでコードを &lt;a href="https://github.com/achiwa912/daemonlord"&gt;公開&lt;/a&gt; しています。MacとLinuxで動作確認していますが、Windowsは未対応です。
&lt;/p&gt;

&lt;p&gt;
メッセージウインドウはスペックがなかなか決まらず、どういったものを作るかを決めるのにだいぶ時間がかかりました。スクロール画面の一部に常時表示する形態としました。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org4844cfa" class="outline-2"&gt;
&lt;h2 id="org4844cfa"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; メッセージウインドウクラス&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
仮想スクロール画面クラス(Vscr)の一部にするか悩んだのですが、肥大化するのも嫌なので、メッセージウインドウクラス(Meswin)として独立させました。
&lt;/p&gt;

&lt;p&gt;
ウインドウ自体のサイズ(width, height)とその中のメッセージ表示エリアのサイズ(mes_width, mes_height)とを分けて管理しています。(x, y)はスクロールウインドウ内のメッセージウインドウの表示位置(左上)です。
&lt;/p&gt;

&lt;p&gt;
mes_linesに表示するメッセージ(文字列)のリストを入れます。これを空にするとメッセージウインドウをクリアすることができます(cls())。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;Meswin&lt;/span&gt;:
    &lt;span style="font-style: italic;"&gt;"""&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    Message window.  Max 40x8 at the upper center of the scroll window.&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    The message area is max 36x6 and a message starts with " * ".&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    """&lt;/span&gt;

    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__init__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, vscr):
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.vscr = vscr
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.width = &lt;span style="font-weight: bold;"&gt;min&lt;/span&gt;(40, vscr.width)
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.height = &lt;span style="font-weight: bold;"&gt;min&lt;/span&gt;(8, vscr.height)
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.x = &lt;span style="font-weight: bold;"&gt;max&lt;/span&gt;(0, (vscr.width-&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.width)//2)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;center&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.y = &lt;span style="font-weight: bold;"&gt;max&lt;/span&gt;(0, (vscr.height-&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.height)//10)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;uppper&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.mes_width = &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.width - 4  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;Message area width&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.mes_height = &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.height - 2  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;Message area height&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.cur_x = 0  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;cursor position in message area&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.cur_y = 0
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.show = &lt;span style="font-weight: bold; text-decoration: underline;"&gt;False&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.mes_lines = []
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.cls()

    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;cls&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
        &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;clear message area&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.mes_lines = []
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgaaabf65" class="outline-2"&gt;
&lt;h2 id="orgaaabf65"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; メッセージ表示メソッド&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
print()メソッドでメッセージを表示します。昔のファミコンRPGのように、メッセージの先頭には" * "を付けます。この記号はstart引数で変更できます。
&lt;/p&gt;

&lt;p&gt;
引数msgはメッセージで、この中に含まれる'\n'を改行として処理します。メソッドの最初に'\n'でsublinesリストにsplitしていますが、'\n'の情報が失われないように正規表現のre.split()を使っています。
&lt;/p&gt;

&lt;p&gt;
sublineは更にウインドウの右端&amp;amp;単語の境界で折り返すようにtextwrap.wrap()を使います。ここで折り返した行の先頭には' * 'が付かないようにしました。
&lt;/p&gt;

&lt;p&gt;
改行オンリーの行を正しく処理するように、len(ssls)がゼロの時にもmes_linesに登録する処理を入れています。
&lt;/p&gt;

&lt;p&gt;
表示行数がメッセージエリアの行数よりも多い文はmes_linesから抜いています。こうすることで、メッセージウインドウがスクロールします。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, msg, start=&lt;span style="font-style: italic;"&gt;'*'&lt;/span&gt;):
    &lt;span style="font-style: italic;"&gt;"""&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    Print a message in the message window.  Long text wraps&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    to the next line.  Process '\n' in texts.&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    """&lt;/span&gt;
    &lt;span style="font-weight: bold; font-style: italic;"&gt;sublines&lt;/span&gt; = re.split(&lt;span style="font-style: italic;"&gt;'\n'&lt;/span&gt;, msg)
    &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; idx, sl &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;enumerate&lt;/span&gt;(sublines):  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;subline&lt;/span&gt;
        &lt;span style="font-weight: bold; font-style: italic;"&gt;header&lt;/span&gt; = &lt;span style="font-style: italic;"&gt;'  '&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; idx == 0:
            &lt;span style="font-weight: bold; font-style: italic;"&gt;header&lt;/span&gt; = start + &lt;span style="font-style: italic;"&gt;' '&lt;/span&gt;
        &lt;span style="font-weight: bold; font-style: italic;"&gt;ssls&lt;/span&gt; = textwrap.wrap(sl, width=&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.mes_width)
        &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;len&lt;/span&gt;(ssls) == 0:
            &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.mes_lines.append(header)
        &lt;span style="font-weight: bold;"&gt;else&lt;/span&gt;:
            &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; ssl &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; ssls:
                &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.mes_lines.append(&lt;span style="font-style: italic;"&gt;''&lt;/span&gt;.join([header, ssl]))
                &lt;span style="font-weight: bold; font-style: italic;"&gt;header&lt;/span&gt; = &lt;span style="font-style: italic;"&gt;'  '&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;len&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.mes_lines) &amp;gt; &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.mes_height:
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.mes_lines = &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.mes_lines[&lt;span style="font-weight: bold;"&gt;len&lt;/span&gt;(
            &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.mes_lines)-&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.mes_height:]
    &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.cur_y = &lt;span style="font-weight: bold;"&gt;len&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.mes_lines)-1
    &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.show = &lt;span style="font-weight: bold; text-decoration: underline;"&gt;True&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
スクリーンショット(笑)です。1歩歩くたびにメッセージ出力するようにしてみました。
&lt;/p&gt;

&lt;pre class="example"&gt;
^^^^^^^^^^^^^^^^^^^^----------------------------------------^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^| * north                               |^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^| * north                               |^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^| * south                               |^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^| * west                                |^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^| * south                               |###...#############
^^^^^^^^^^^^^^^^^^^^| * east                                |###...##...........
^^^^^^^^^^^^^^^^^^^^----------------------------------------+..+...##...........
^^^^^^^^^^^^^^^^^^^^^^^^^^^^##########..........#####.......####...##...........
^^^^^^^^^^^^^^^^^^^^^^^^^^^^##########..........########+#######...########+####
^^^^^^^^^^^^^^^^^^^^^^^^^^^^##########..........########+#######...########.####
^^^^^^^^^^^^^^^^^^^^^^^^^^^^##########..@.......*.....+.....+...+++++.......####
^^^^^^^^^^^^^^^^^^^^^^^^^^^^##########..........#######.....####.....###########
^^^^^^^^^^^^^^^^^^^^^^^^^^^^##########..........#######.....####.....###########
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0ea8716" class="outline-2"&gt;
&lt;h2 id="org0ea8716"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; ユーザーインプットメソッド&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
メッセージウインドウ内でユーザーインプットできるようにしました。"* "の代わりに"&amp;gt; "で入力を促します。
&lt;/p&gt;

&lt;pre class="example"&gt;
^^^^^^^^^^^^^^^^^^^^----------------------------------------####......##########
&amp;lt;snip&amp;gt;
^^^^^^^^^^^^^^^^^^^^| * How?                                |*......#####.......
^^^^^^^^^^^^^^^^^^^^| &amp;gt;                                     |#####..#####.......
^^^^^^^^^^^^^^^^^^^^----------------------------------------.#####++#####.......
&lt;/pre&gt;

&lt;p&gt;
宝箱の罠やスペル(魔法)の名前の入力でこのメソッドを使います。
&lt;/p&gt;

&lt;pre class="example"&gt;
^^^^^^^^^^^^^^^^^^^^| * How?                                |.######*#####......
^^^^^^^^^^^^^^^^^^^^| &amp;gt; poison needle                       |.*......#####......
^^^^^^^^^^^^^^^^^^^^| * Input: poison needle                |.#####..#####......
^^^^^^^^^^^^^^^^^^^^----------------------------------------.#####++#####.......
&lt;/pre&gt;

&lt;p&gt;
inputメソッドです。メッセージとプロンプトを表示して、その右にカーソルを持って行き、後は普通に標準ライブラリのinput()関数を呼んでいます。こちらの関数で画面表示された文字列はメッセージウインドウに登録されておらず、次回の表示で消えてしまうために、メッセージウインドウに登録しなおしています。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;input&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, msg):
    &lt;span style="font-style: italic;"&gt;"""&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    Input a string in the message window.&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    """&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(msg)
    &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;''&lt;/span&gt;, start=&lt;span style="font-style: italic;"&gt;'&amp;gt;'&lt;/span&gt;)
    &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.vscr.show_meswin()
    &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.vscr.display()
    &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(f&lt;span style="font-style: italic;"&gt;"\033[{self.y+self.cur_y+1};{self.x+5}H"&lt;/span&gt;, end=&lt;span style="font-style: italic;"&gt;''&lt;/span&gt;, flush=&lt;span style="font-weight: bold; text-decoration: underline;"&gt;True&lt;/span&gt;)
    &lt;span style="font-weight: bold;"&gt;try&lt;/span&gt;:
        value = &lt;span style="font-weight: bold;"&gt;input&lt;/span&gt;()
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.mes_lines[&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.cur_y] = &lt;span style="font-style: italic;"&gt;"&amp;gt; "&lt;/span&gt; + value
    &lt;span style="font-weight: bold;"&gt;except&lt;/span&gt;:
        &lt;span style="font-weight: bold;"&gt;pass&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; value
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0c27e0b" class="outline-2"&gt;
&lt;h2 id="org0c27e0b"&gt;&lt;span class="section-number-2"&gt;5&lt;/span&gt; 1文字入力メソッド&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;p&gt;
次は1文字入力メソッドです。Yes/Noに答える際に'y'または'n'の入力待ちをするようなケースで使用します。
&lt;/p&gt;

&lt;pre class="example"&gt;
^^^^^^^^^^^^^^^^^^^^----------------------------------------^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^| * east                                |^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^| * east                                |^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^| * east                                |^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^| * Do you? (y/n) &amp;gt; f                   |^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^| * Do you? (y/n) &amp;gt; y                   |^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^| * Input char: y                       |^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^----------------------------------------####################
&lt;/pre&gt;

&lt;p&gt;
期待する文字をリストで渡して、それが出るまでループさせることもできます。このメソッドはnon-blocking 1文字入力のgetch()関数を使っていて、リターンキーの入力が不要です。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;input_char&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, msg, values=[]):
    &lt;span style="font-style: italic;"&gt;"""&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    Input a character in the message window.&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    """&lt;/span&gt;
    &lt;span style="font-weight: bold; font-style: italic;"&gt;ch&lt;/span&gt; = &lt;span style="font-style: italic;"&gt;''&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;while&lt;/span&gt; ch &lt;span style="font-weight: bold;"&gt;not&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; values:
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(msg+&lt;span style="font-style: italic;"&gt;' &amp;gt;'&lt;/span&gt;)
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.vscr.show_meswin()
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.vscr.display()
        &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(f&lt;span style="font-style: italic;"&gt;"\033[{self.y+self.cur_y+1};{self.x+len(msg)+8}H"&lt;/span&gt;,
              end=&lt;span style="font-style: italic;"&gt;''&lt;/span&gt;, flush=&lt;span style="font-weight: bold; text-decoration: underline;"&gt;True&lt;/span&gt;)
        &lt;span style="font-weight: bold; font-style: italic;"&gt;ch&lt;/span&gt; = getch()
        &lt;span style="font-weight: bold; font-style: italic;"&gt;l&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.mes_lines.pop()
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;''&lt;/span&gt;.join([l, &lt;span style="font-style: italic;"&gt;' '&lt;/span&gt;, ch])[2:])
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.vscr.show_meswin()
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.vscr.display()
        &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;not&lt;/span&gt; values:
            &lt;span style="font-weight: bold;"&gt;break&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; ch
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgece50c0" class="outline-2"&gt;
&lt;h2 id="orgece50c0"&gt;&lt;span class="section-number-2"&gt;6&lt;/span&gt; 次は、、&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-6"&gt;
&lt;p&gt;
メッセージも出力できるようになったので、次はいよいよWizardry画面らしい、パーティーリストの画面表示にチャレンジします。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Python"></category><category term="Python"></category><category term="game"></category></entry><entry><title>DL-3; マップをスクロールさせる</title><link href="http://achiwa912.github.io/dl3.html" rel="alternate"></link><published>2021-02-26T00:00:00-05:00</published><updated>2021-12-03T00:00:00-05:00</updated><author><name>きょうす</name></author><id>tag:achiwa912.github.io,2021-02-26:/dl3.html</id><summary type="html">scroll map</summary><content type="html">&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org2cf4dfa"&gt;1. はじめに&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org60297f9"&gt;2. スクロール画面表示&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org5ed98ee"&gt;2.1. メインメソッド&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org8c96d83"&gt;2.2. マップから仮想画面の作成&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgb4444b4"&gt;2.3. 仮想画面を実際に表示&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#org3ef5573"&gt;3. プレイヤーパーティーの移動&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org71adb75"&gt;4. 動かしてみる&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org9a01d87"&gt;5. 次は、、&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org2cf4dfa" class="outline-2"&gt;
&lt;h2 id="org2cf4dfa"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; はじめに&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Rogue+Wizライクなゲーム(仮称Daemon Lord)を作るプロジェクトの3回目です。今回はマップのスクロール画面表示を行います。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org60297f9" class="outline-2"&gt;
&lt;h2 id="org60297f9"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; スクロール画面表示&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
スクロール画面の表示のために、いったん仮想画面を作ることにします。仮想画面は新旧2面持ち、前回描いた行と全く同じ内容の行は画面書き換えをしないようにすることで、画面全体の書き換え量を節約します。また、マップに重ねてメッセージウインドウ等を表示する場合に、実際の画面書き換えを何度も行わないようにして、画面書換量を減らすと同時に、画面のちらつきを防止します。
&lt;/p&gt;

&lt;p&gt;
まずはスクロール画面制御用のクラスを定義します。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;Vscr&lt;/span&gt;:
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__init__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, width, height):
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.width = width
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.height = height
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.vscr0 = &lt;span style="font-weight: bold;"&gt;bytearray&lt;/span&gt;(b&lt;span style="font-style: italic;"&gt;'M'&lt;/span&gt;*width*height)
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.vscr1 = &lt;span style="font-weight: bold;"&gt;bytearray&lt;/span&gt;(b&lt;span style="font-style: italic;"&gt;'N'&lt;/span&gt;*width*height)
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.prev_vscr_view = &lt;span style="font-weight: bold;"&gt;memoryview&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.vscr0)
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.cur_vscr_view = &lt;span style="font-weight: bold;"&gt;memoryview&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.vscr1)
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
width, heightは表示画面のサイズ=仮想画面のサイズです。vscr0/1が仮想画面の実体で、現在使用中の仮想画面ビュー(cur_vscr_view)と前回使った仮想画面ビュー(prev_vscr_view)をmemoryviewとして持ちます。スクロール画面表示が終わるたびに、これらのビューが指す仮想画面の実体を切り替えます。
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5ed98ee" class="outline-3"&gt;
&lt;h3 id="org5ed98ee"&gt;&lt;span class="section-number-3"&gt;2.1&lt;/span&gt; メインメソッド&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-1"&gt;
&lt;p&gt;
スクロール画面表示のメインメソッドはdisp_scrwin()です。ここでは主に、マップから仮想画面を作成し、仮想画面を実際に表示して、仮想画面のビューを切り替えています。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;disp_scrwin&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, party, floor):
    &lt;span style="font-style: italic;"&gt;"""&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    Display scroll window main&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    """&lt;/span&gt;
    &lt;span style="font-weight: bold; font-style: italic;"&gt;start&lt;/span&gt; = time.time()
    &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.draw_map(party, floor)
    &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.display()
    &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.cur_vscr_view, &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.prev_vscr_view \
        = &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.prev_vscr_view, &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.cur_vscr_view
    &lt;span style="font-weight: bold; font-style: italic;"&gt;delta&lt;/span&gt; = time.time() - start
    &lt;span style="font-weight: bold;"&gt;try&lt;/span&gt;:
        &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(f&lt;span style="font-style: italic;"&gt;"\033[{self.height-1};0H"&lt;/span&gt;, end=&lt;span style="font-style: italic;"&gt;''&lt;/span&gt;)
        &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(f&lt;span style="font-style: italic;"&gt;"\n{party.x:03d}/{party.y:03d}, {delta:.5f}"&lt;/span&gt;, flush=&lt;span style="font-weight: bold; text-decoration: underline;"&gt;True&lt;/span&gt;)
    &lt;span style="font-weight: bold;"&gt;except&lt;/span&gt;:
        &lt;span style="font-weight: bold;"&gt;pass&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org8c96d83" class="outline-3"&gt;
&lt;h3 id="org8c96d83"&gt;&lt;span class="section-number-3"&gt;2.2&lt;/span&gt; マップから仮想画面の作成&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-2"&gt;
&lt;p&gt;
マップデータを仮想画面にコピーするのはdraw_map()メソッドで行います。フロア全体のマップデータから、画面表示する部分だけを切り取っています。表示エリアがフロアからはみ出た部分は、いまのところ岩('#')と区別して'^'記号を表示しています。
&lt;/p&gt;

&lt;p&gt;
表示する1行分をスライスして'^'で初期化しています。ここに対応するマップデータをスライスしてコピー、上書きします。l_left/l_rightの計算がmin()を使って若干面倒なことになっているのは、フロア外の表示部分を考慮しているためです。プレイヤーパーティーは常に画面の中心位置に'@'として表示します。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;draw_map&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, party, floor):
    &lt;span style="font-style: italic;"&gt;"""&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    Copy map data to a virtual scroll window&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    """&lt;/span&gt;
    &lt;span style="font-weight: bold; font-style: italic;"&gt;floor_view&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;memoryview&lt;/span&gt;(floor.floor_data)
    &lt;span style="font-weight: bold; font-style: italic;"&gt;cv&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.cur_vscr_view
    &lt;span style="font-weight: bold; font-style: italic;"&gt;w&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.width
    &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; cy &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;range&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.height):
        &lt;span style="font-weight: bold; font-style: italic;"&gt;cv&lt;/span&gt;[cy*w:(cy+1)*w] = b&lt;span style="font-style: italic;"&gt;'^'&lt;/span&gt;*w  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;fill with rocks&lt;/span&gt;
        &lt;span style="font-weight: bold; font-style: italic;"&gt;my&lt;/span&gt; = party.y - &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.height//2 + cy  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;convert cy to floor_y&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; 0 &amp;lt;= my &amp;lt; floor.y_size:
            &lt;span style="font-weight: bold; font-style: italic;"&gt;l_left&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;min&lt;/span&gt;(0, party.x-w//2) * -1
            &lt;span style="font-weight: bold; font-style: italic;"&gt;l_right&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;min&lt;/span&gt;(w, floor.x_size - party.x + w//2)
            &lt;span style="font-weight: bold; font-style: italic;"&gt;map_left&lt;/span&gt; = my*floor.x_size + party.x - w//2 + l_left
            &lt;span style="font-weight: bold; font-style: italic;"&gt;map_right&lt;/span&gt; = map_left + l_right - l_left
            &lt;span style="font-weight: bold; font-style: italic;"&gt;cv&lt;/span&gt;[cy*w+l_left:cy*w+l_right] = floor_view[map_left:map_right]
        &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; cy == &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.height//2:
            &lt;span style="font-weight: bold; font-style: italic;"&gt;cv&lt;/span&gt;[cy*w+w//2:cy*w+w//2+1] = b&lt;span style="font-style: italic;"&gt;'@'&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb4444b4" class="outline-3"&gt;
&lt;h3 id="orgb4444b4"&gt;&lt;span class="section-number-3"&gt;2.3&lt;/span&gt; 仮想画面を実際に表示&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-3"&gt;
&lt;p&gt;
display()メソッドは、仮想画面を実際にprint()文を使ってターミナルに表示します。ロジックはstraight forwardで読みやすくなっていると思います。if文は前回描いた仮想画面と今回描く仮想画面の行同士を比較している部分です。1行まるまる同じであれば、描画をスキップします。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;display&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
    &lt;span style="font-style: italic;"&gt;"""&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    Actually print scroll window on the terminal&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    """&lt;/span&gt;
    &lt;span style="font-weight: bold; font-style: italic;"&gt;cv&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.cur_vscr_view
    &lt;span style="font-weight: bold; font-style: italic;"&gt;w&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.width
    &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; y &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;range&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.height):
        &lt;span style="font-weight: bold; font-style: italic;"&gt;slc&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;slice&lt;/span&gt;(y*w, (y+1)*w)
        &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; cv[slc] != &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.prev_vscr_view[slc]:
            &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(f&lt;span style="font-style: italic;"&gt;"\033[{y};0H"&lt;/span&gt;, end=&lt;span style="font-style: italic;"&gt;''&lt;/span&gt;)
            &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(cv[slc].tobytes().decode(), end=&lt;span style="font-style: italic;"&gt;''&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3ef5573" class="outline-2"&gt;
&lt;h2 id="org3ef5573"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; プレイヤーパーティーの移動&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
プレイヤーパーティーは常に画面中心に表示するとしているため、パーティーの座標を変えると画面がスクロールします。
&lt;/p&gt;

&lt;p&gt;
Rogueと同様のキーバインド、つまり'h', 'j', 'k', 'l'のキーでパーティー座標を移動させています。キーが押されるとパーティー座標を1ずつずらし、draw_map()関数を呼んでいます。
&lt;/p&gt;

&lt;p&gt;
non-blockingなキー入力は初回で紹介したコードスニペットを修正して使っています。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;main&lt;/span&gt;():
    &lt;span style="font-weight: bold; font-style: italic;"&gt;floor&lt;/span&gt; = generate_floor(1)
    &lt;span style="font-weight: bold; font-style: italic;"&gt;party&lt;/span&gt; = Party(0, 0, 1)
    &lt;span style="font-weight: bold; font-style: italic;"&gt;w&lt;/span&gt;, &lt;span style="font-weight: bold; font-style: italic;"&gt;h&lt;/span&gt; = terminal_size()
    &lt;span style="font-weight: bold; font-style: italic;"&gt;vscr&lt;/span&gt; = Vscr(w, h-1)
    vscr.disp_scrwin(party, floor)

    &lt;span style="font-weight: bold; font-style: italic;"&gt;fd&lt;/span&gt; = sys.stdin.fileno()

    &lt;span style="font-weight: bold; font-style: italic;"&gt;oattr&lt;/span&gt; = termios.tcgetattr(fd)
    &lt;span style="font-weight: bold; font-style: italic;"&gt;nattr&lt;/span&gt; = oattr
    &lt;span style="font-weight: bold; font-style: italic;"&gt;nattr&lt;/span&gt;[3] = nattr[3] &amp;amp; ~termios.ICANON &amp;amp; ~termios.ECHO
    termios.tcsetattr(fd, termios.TCSANOW, nattr)

    &lt;span style="font-weight: bold; font-style: italic;"&gt;oflags&lt;/span&gt; = fcntl.fcntl(fd, fcntl.F_GETFL)
    fcntl.fcntl(fd, fcntl.F_SETFL, oflags | os.O_NONBLOCK)

    &lt;span style="font-weight: bold;"&gt;try&lt;/span&gt;:
        &lt;span style="font-weight: bold;"&gt;while&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;True&lt;/span&gt;:
            &lt;span style="font-weight: bold;"&gt;try&lt;/span&gt;:
                &lt;span style="font-weight: bold; font-style: italic;"&gt;c&lt;/span&gt; = sys.stdin.read(1)
                &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; c:
                    &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; c == &lt;span style="font-style: italic;"&gt;'h'&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;and&lt;/span&gt; party.x &amp;gt; 0:
                        &lt;span style="font-weight: bold; font-style: italic;"&gt;party.x&lt;/span&gt; -= 1
                    &lt;span style="font-weight: bold;"&gt;elif&lt;/span&gt; c == &lt;span style="font-style: italic;"&gt;'k'&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;and&lt;/span&gt; party.y &amp;gt; 0:
                        &lt;span style="font-weight: bold; font-style: italic;"&gt;party.y&lt;/span&gt; -= 1
                    &lt;span style="font-weight: bold;"&gt;elif&lt;/span&gt; c == &lt;span style="font-style: italic;"&gt;'j'&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;and&lt;/span&gt; party.y &amp;lt; floor.y_size-1:
                        &lt;span style="font-weight: bold; font-style: italic;"&gt;party.y&lt;/span&gt; += 1
                    &lt;span style="font-weight: bold;"&gt;elif&lt;/span&gt; c == &lt;span style="font-style: italic;"&gt;'l'&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;and&lt;/span&gt; party.x &amp;lt; floor.x_size-1:
                        &lt;span style="font-weight: bold; font-style: italic;"&gt;party.x&lt;/span&gt; += 1
                    &lt;span style="font-weight: bold;"&gt;elif&lt;/span&gt; c == &lt;span style="font-style: italic;"&gt;'.'&lt;/span&gt;:
                        &lt;span style="font-weight: bold;"&gt;pass&lt;/span&gt;
                    &lt;span style="font-weight: bold;"&gt;else&lt;/span&gt;:
                        &lt;span style="font-weight: bold;"&gt;pass&lt;/span&gt;
                &lt;span style="font-weight: bold;"&gt;else&lt;/span&gt;:
                    &lt;span style="font-weight: bold; font-style: italic;"&gt;draw&lt;/span&gt; = &lt;span style="font-weight: bold; text-decoration: underline;"&gt;False&lt;/span&gt;
                &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; draw:
                    vscr.disp_scrwin(party, floor)

            &lt;span style="font-weight: bold;"&gt;except&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;IOError&lt;/span&gt;:
                &lt;span style="font-weight: bold;"&gt;pass&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;finally&lt;/span&gt;:
        termios.tcsetattr(fd, termios.TCSAFLUSH, oattr)
        fcntl.fcntl(fd, fcntl.F_SETFL, oflags)


&lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__name__&lt;/span&gt; == &lt;span style="font-style: italic;"&gt;"__main__"&lt;/span&gt;:
    main()
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org71adb75" class="outline-2"&gt;
&lt;h2 id="org71adb75"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; 動かしてみる&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
動かしてみます。
&lt;/p&gt;

&lt;pre class="example"&gt;
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^######################............######^^^^^^^^^^^^
^^^^^^^^^^^^^#.......##############............######^^^^^^^^^^^^
^^^^^^^^^^^^^#.......##############............######^^^^^^^^^^^^
^^^^^^^^^^^^^#.......####.......#########+##+########^^^^^^^^^^^^
^^^^^^^^^^^^^#.......####.......######............###^^^^^^^^^^^^
^^^^^^^^^^^^^#.......####.......+....+............###^^^^^^^^^^^^
^^^^^^^^^^^^^####+#######.......######............###^^^^^^^^^^^^
^^^^^^^^^^^^^####.#######.......@#####............###^^^^^^^^^^^^
^^^^^^^^^^^^^####.##########+#############+##########^^^^^^^^^^^^
^^^^^^^^^^^^^####*....######.........#####+##########^^^^^^^^^^^^
^^^^^^^^^^^^^####*....*....+.........###.....########^^^^^^^^^^^^
^^^^^^^^^^^^^####*....######.........###.....+..+++##^^^^^^^^^^^^
^^^^^^^^^^^^^####+##*#######.........###.....###....#^^^^^^^^^^^^
^^^^^^^^^^^^^#......+#######.........###########....#^^^^^^^^^^^^
^^^^^^^^^^^^^#......+#######.........###########....#^^^^^^^^^^^^
^^^^^^^^^^^^^#......#################################^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
019/007, 0.00011
&lt;/pre&gt;

&lt;p&gt;
少し楽しいです。マップをスクロールして表示するだけでなかなかゲームらしくなりますね。Rogueぽいのはここまでで、これからはどんどんWizardry色が強くなっていく予定です。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org9a01d87" class="outline-2"&gt;
&lt;h2 id="org9a01d87"&gt;&lt;span class="section-number-2"&gt;5&lt;/span&gt; 次は、、&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;p&gt;
次は画面上にメッセージを表示できるようにします。
ではまた。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Python"></category><category term="Python"></category><category term="game"></category></entry><entry><title>DL-2; マップを自動生成する</title><link href="http://achiwa912.github.io/dl2.html" rel="alternate"></link><published>2021-02-25T00:00:00-05:00</published><updated>2021-12-03T00:00:00-05:00</updated><author><name>きょうす</name></author><id>tag:achiwa912.github.io,2021-02-25:/dl2.html</id><summary type="html">automatic map generation</summary><content type="html">&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orged0d216"&gt;1. はじめに&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org9b26269"&gt;2. マップ自動生成&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org55d1c55"&gt;2.1. 部屋データ生成&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org3b1aa0d"&gt;2.2. 部屋のフロアへの配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgd00a7a5"&gt;2.3. 廊下で部屋をつなぐ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgdf0ee0f"&gt;2.4. ドアの設置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgbeb568a"&gt;3. 続き&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orged0d216" class="outline-2"&gt;
&lt;h2 id="orged0d216"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; はじめに&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Rogue+Wizライクなゲームを作るプロジェクトの2回目です。プロジェクトに名前が無いと不便なので、仮称DL - Daemon Lordとしました。dl.pyで作り始めます。
&lt;/p&gt;

&lt;p&gt;
今回はマップの自動生成をやります。&lt;a href="http://rogueliketutorials.com/tutorials/tcod/v2/"&gt;このサイト&lt;/a&gt; にざっと目を通して簡単に予習しておきました。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org9b26269" class="outline-2"&gt;
&lt;h2 id="org9b26269"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; マップ自動生成&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
まずは1フロア分のマップを作ります。以下のような流れになります。
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;配置する部屋データを生成する&lt;/li&gt;
&lt;li&gt;フロアを岩で埋め尽くす&lt;/li&gt;
&lt;li&gt;部屋をフロアに配置する&lt;/li&gt;
&lt;li&gt;廊下で部屋同士をつなぐ&lt;/li&gt;
&lt;li&gt;ドアを配置する&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

&lt;div id="outline-container-org55d1c55" class="outline-3"&gt;
&lt;h3 id="org55d1c55"&gt;&lt;span class="section-number-3"&gt;2.1&lt;/span&gt; 部屋データ生成&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-1"&gt;
&lt;p&gt;
まずはRoomクラスを作ります。パラメーターとして左上の座標(x, y)と横縦のサイズ(x_size, y_size)を持ちます。後で計算をさぼるために部屋の中心座標も計算して持っておきます(center_x, center_y)。
&lt;/p&gt;

&lt;p&gt;
\__repr__()をデバッグ用に用意しました。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;Room&lt;/span&gt;:
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__init__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, x, y, x_size, y_size):
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.x = x
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.y = y
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.x_size = x_size
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.y_size = y_size
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.center_x = x + x_size//2
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.center_y = y + y_size//2

    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__repr__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
        &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; f&lt;span style="font-style: italic;"&gt;"Room(x/y: {self.x}/{self.y}, size: {self.x_size}/{self.y_size})"&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
これを生成してroomsリストにアペンドしていきます。
&lt;/p&gt;

&lt;p&gt;
他にもフロアFloorクラスを定義します。ディクショナリで十分な気もします。。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;Floor&lt;/span&gt;:
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__init__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, x_size, y_size, floor, floor_data):
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.x_size = x_size
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.y_size = y_size
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.floor = floor
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.floor_data = floor_data

    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__repr__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
        &lt;span style="font-weight: bold; font-style: italic;"&gt;s&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.floor_data.decode()
        &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; f&lt;span style="font-style: italic;"&gt;"Floor(size: {self.x_size}x{self.y_size}, floor: {self.floor} - {s})"&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
次は部屋生成のprepare_rooms関数です。フロアのサイズを引数として取ります。
フロアのランダムな位置に、横サイズ3-12 x 縦サイズ3-7の部屋候補を作り、既にroomsリストに登録されている部屋と重ならなければリストに追加することを繰り返します。二つの部屋の重なりを判定するユーティリティー関数rooms_intersect()を定義しています。
&lt;/p&gt;

&lt;p&gt;
仮に256, 10, 4等の定数を直接指定していて見苦しいですが、後でconfig値化するつもりです。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;prepare_rooms&lt;/span&gt;(floor_x_size, floor_y_size):
    &lt;span style="font-style: italic;"&gt;"""&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    Return a list filled with Rooms objects on a floor.&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    """&lt;/span&gt;
    &lt;span style="font-weight: bold; font-style: italic;"&gt;rooms&lt;/span&gt; = []
    &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; _ &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;range&lt;/span&gt;(random.randrange(256)):
        &lt;span style="font-weight: bold; font-style: italic;"&gt;rx&lt;/span&gt; = 3 + random.randrange(10)
        &lt;span style="font-weight: bold; font-style: italic;"&gt;ry&lt;/span&gt; = 3 + random.randrange(4)
        &lt;span style="font-weight: bold; font-style: italic;"&gt;room&lt;/span&gt; = Room(random.randrange(floor_x_size-rx+1),
                    random.randrange(floor_y_size-ry+1),
                    rx, ry)
        &lt;span style="font-weight: bold; font-style: italic;"&gt;intersect&lt;/span&gt; = &lt;span style="font-weight: bold; text-decoration: underline;"&gt;False&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; r &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; rooms:
            &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; rooms_intersect(room, r):
                &lt;span style="font-weight: bold; font-style: italic;"&gt;intersect&lt;/span&gt; = &lt;span style="font-weight: bold; text-decoration: underline;"&gt;True&lt;/span&gt;
                &lt;span style="font-weight: bold;"&gt;break&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;not&lt;/span&gt; intersect:
            rooms.append(room)
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; rooms
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
部屋の重なり判定は、「矩形」「重なり」「判定」あたりのキーワードで検索し、紙に絵をいくつか描いて整理してからコードにしました。以下のコードは単純ですが、これだけを読んで理解するのはハードルが高いかもしれません。。。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;rooms_intersect&lt;/span&gt;(r1, r2):
    &lt;span style="font-style: italic;"&gt;"""&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    Return True if two rooms are intersected.&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    """&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;max&lt;/span&gt;(r1.x, r2.x) &amp;lt;= &lt;span style="font-weight: bold;"&gt;min&lt;/span&gt;(r1.x+r1.x_size, r2.x+r2.x_size) \
        &lt;span style="font-weight: bold;"&gt;and&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;max&lt;/span&gt;(r1.y, r2.y) &amp;lt;= &lt;span style="font-weight: bold;"&gt;min&lt;/span&gt;(r1.y+r1.y_size, r2.y+r2.y_size)
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3b1aa0d" class="outline-3"&gt;
&lt;h3 id="org3b1aa0d"&gt;&lt;span class="section-number-3"&gt;2.2&lt;/span&gt; 部屋のフロアへの配置&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-2"&gt;
&lt;p&gt;
続いて、フロアを岩で埋め尽くして初期化し、そこに部屋を配置していきます。これは一フロアを生成する関数generate_floor()の中で直接やってしまいます。今回のテーマのメイン関数です。
&lt;/p&gt;

&lt;p&gt;
フロアデータfloor_dataはbytearrayで表現します。最初これをstrで作って、上書きしようとしてエラーになったのは内緒です(汗)。slice操作を高速化するためにfloor_dataのmemoryviewを作成し、それに対して以降はfloor_viewに対して操作します。
&lt;/p&gt;

&lt;p&gt;
'#'の文字は岩を、'.'は歩ける床を意味しています。floor_dataをb'#'で埋めたbytearrayとし、そこに(floor_view経由で)部屋の床b'.'を上書きしています。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;generate_floor&lt;/span&gt;(floor_x_size, floor_y_size, floor):
    &lt;span style="font-style: italic;"&gt;"""&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    Generate a dungeon floor.&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    Create rooms, connect among them and place doors&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    """&lt;/span&gt;
    &lt;span style="font-weight: bold; font-style: italic;"&gt;rooms&lt;/span&gt; = prepare_rooms(floor_x_size, floor_y_size)
    &lt;span style="font-weight: bold; font-style: italic;"&gt;floor_data&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;bytearray&lt;/span&gt;(b&lt;span style="font-style: italic;"&gt;'#'&lt;/span&gt; * floor_x_size *
                           floor_y_size)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;rock only floor&lt;/span&gt;
    &lt;span style="font-weight: bold; font-style: italic;"&gt;floor_view&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;memoryview&lt;/span&gt;(floor_data)
    &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; r &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; rooms:
        &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; y &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;range&lt;/span&gt;(r.y_size):
            &lt;span style="font-weight: bold; font-style: italic;"&gt;start&lt;/span&gt; = (r.y + y)*floor_x_size + r.x
            &lt;span style="font-weight: bold; font-style: italic;"&gt;floor_view&lt;/span&gt;[start:start+r.x_size] = b&lt;span style="font-style: italic;"&gt;'.'&lt;/span&gt;*r.x_size
    connect_all_rooms(rooms, floor_x_size, floor_view)
    place_doors(rooms, floor_x_size, floor_y_size, floor_view)
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; Floor(floor_x_size, floor_y_size, floor, floor_data)
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd00a7a5" class="outline-3"&gt;
&lt;h3 id="orgd00a7a5"&gt;&lt;span class="section-number-3"&gt;2.3&lt;/span&gt; 廊下で部屋をつなぐ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-3"&gt;
&lt;p&gt;
そして、部屋を廊下でつないでいきます。まずは部屋をy座標 &amp;rarr; x座標の順でソートします。そして部屋をひとつずつリストからpopして、一番近い部屋を探し、互いの中心座標を歩ける床のタイルb'.'で結び、廊下とします。他の廊下や部屋と重なっても気にしません。全ての部屋を一筆書きの要領でつなぎます。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;connect_all_rooms&lt;/span&gt;(rooms, floor_x_size, floor_view):
    &lt;span style="font-style: italic;"&gt;"""&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    Connect all rooms with hallways.&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    Try to find and connect with the nearest room.&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    """&lt;/span&gt;
    rooms.sort(key=&lt;span style="font-weight: bold;"&gt;lambda&lt;/span&gt; room: room.y+room.y_size//2)
    rooms.sort(key=&lt;span style="font-weight: bold;"&gt;lambda&lt;/span&gt; room: room.x+room.x_size//2)
    &lt;span style="font-weight: bold; font-style: italic;"&gt;rs&lt;/span&gt; = rooms[:]
    &lt;span style="font-weight: bold; font-style: italic;"&gt;r_src&lt;/span&gt; = rs.pop()
    &lt;span style="font-weight: bold;"&gt;while&lt;/span&gt; rs:
        &lt;span style="font-weight: bold; font-style: italic;"&gt;idx_near&lt;/span&gt; = 0
        &lt;span style="font-weight: bold; font-style: italic;"&gt;len_rs&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;len&lt;/span&gt;(rs)
        &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; i &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;range&lt;/span&gt;(len_rs):  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;look for the nearest room&lt;/span&gt;
            &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; distsq_rooms(r_src, rs[i]) &amp;lt; distsq_rooms(r_src, rs[idx_near]):
                &lt;span style="font-weight: bold; font-style: italic;"&gt;idx_near&lt;/span&gt; = i
        &lt;span style="font-weight: bold; font-style: italic;"&gt;r_near&lt;/span&gt; = rs.pop(idx_near)
        connect_rooms(r_src, r_near, floor_x_size, floor_view)
        &lt;span style="font-weight: bold; font-style: italic;"&gt;r_src&lt;/span&gt; = r_near
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
disqsq_rooms関数は、二つの部屋間の距離(の2乗)を求めるユーティリティー関数です。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;distsq_rooms&lt;/span&gt;(r1, r2):
    &lt;span style="font-style: italic;"&gt;"""&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    Calculate distance between two rooms.&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    Will return distance**2.&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    """&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; (r1.x+r1.x_size//2 - (r2.x+r2.x_size//2))**2 \
        + (r1.y+r1.y_size//2 - (r2.y+r2.y_size//2))**2
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
connect_rooms()関数は、二つの部屋に廊下を作ります。二つの部屋の結び方は、横方向と縦方向のどちらを先に作るかで2パターンあります。確率50%のランダムで決めています。(cx, cy)は縦線と横線が交差する点です。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;connect_rooms&lt;/span&gt;(r1, r2, floor_x_size, floor_view):
    &lt;span style="font-style: italic;"&gt;"""&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    Create a hallway between two rooms and connect them.&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    """&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; random.randrange(1) == 0:  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;1/2&lt;/span&gt;
        &lt;span style="font-weight: bold; font-style: italic;"&gt;cx&lt;/span&gt; = r1.center_x
        &lt;span style="font-weight: bold; font-style: italic;"&gt;cy&lt;/span&gt; = r2.center_y
    &lt;span style="font-weight: bold;"&gt;else&lt;/span&gt;:
        &lt;span style="font-weight: bold; font-style: italic;"&gt;cx&lt;/span&gt; = r2.center_x
        &lt;span style="font-weight: bold; font-style: italic;"&gt;cy&lt;/span&gt; = r1.center_y
    &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; x, y &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; draw_line(r1.center_x, r1.center_y, cx, cy):
        &lt;span style="font-weight: bold; font-style: italic;"&gt;pos&lt;/span&gt; = floor_x_size * y + x
        &lt;span style="font-weight: bold; font-style: italic;"&gt;floor_view&lt;/span&gt;[pos:pos+1] = b&lt;span style="font-style: italic;"&gt;'.'&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; x, y &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; draw_line(r2.center_x, r2.center_y, cx, cy):
        &lt;span style="font-weight: bold; font-style: italic;"&gt;pos&lt;/span&gt; = floor_x_size * y + x
        &lt;span style="font-weight: bold; font-style: italic;"&gt;floor_view&lt;/span&gt;[pos:pos+1] = b&lt;span style="font-style: italic;"&gt;'.'&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
draw_line()は縦線あるいは横線を一本引くだけの関数です。次の座標(x, y)をyieldするジェネレーター関数なので、for文に与えています。最初、終点をyieldせずにしばらく悩んだことも内緒です(汗)。これをジェネレーター関数として実装するアイデアは、例のRogue-like tutorialからいただきました。ジェネレーターはなんか初心者ぽくなくて格好良いので好きです。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;draw_line&lt;/span&gt;(x1, y1, x2, y2):
    &lt;span style="font-style: italic;"&gt;"""&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    Utility generator function to draw a straight line.&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    Must eithr be vertical (x1==x2) or horizontal (y1==y2).&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    """&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; x1 &amp;lt; x2:
        &lt;span style="font-weight: bold; font-style: italic;"&gt;x1&lt;/span&gt;, &lt;span style="font-weight: bold; font-style: italic;"&gt;x2&lt;/span&gt; = x2, x1
    &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; y1 &amp;lt; y2:
        &lt;span style="font-weight: bold; font-style: italic;"&gt;y1&lt;/span&gt;, &lt;span style="font-weight: bold; font-style: italic;"&gt;y2&lt;/span&gt; = y2, y1
    &lt;span style="font-weight: bold;"&gt;while&lt;/span&gt; x1 &amp;gt; x2 &lt;span style="font-weight: bold;"&gt;or&lt;/span&gt; y1 &amp;gt; y2:
        &lt;span style="font-weight: bold;"&gt;yield&lt;/span&gt; x2, y2
        &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; x1 &amp;gt; x2:
            &lt;span style="font-weight: bold; font-style: italic;"&gt;x2&lt;/span&gt; += 1
        &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; y1 &amp;gt; y2:
            &lt;span style="font-weight: bold; font-style: italic;"&gt;y2&lt;/span&gt; += 1
    &lt;span style="font-weight: bold;"&gt;yield&lt;/span&gt; x2, y2
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgdf0ee0f" class="outline-3"&gt;
&lt;h3 id="orgdf0ee0f"&gt;&lt;span class="section-number-3"&gt;2.4&lt;/span&gt; ドアの設置&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-4"&gt;
&lt;p&gt;
最後に、place_doors()関数で部屋の入り口にドアを設置します。ドアにはロック無し('+')、あり('*')の2種類を用意し、10%の確率でその部屋のドアをロック付きにします。
&lt;/p&gt;

&lt;p&gt;
部屋の4隅の辺(上下左右)をチェックし、その隣が歩ける床タイル('.')等なら廊下と接続していると判断し、ドアを設置していきます。
&lt;/p&gt;

&lt;p&gt;
コードの繰り返しがみっともなかったので、共通部分をplace_door()関数として切り出しました。見た目がすっきりしたと思います。最初のif文では、その座標がフロアの内側にあるかどうかを判定しています。指定座標が床('.')または(ロック無し)ドア('+')ならばドア(ロック付きかもしれない)を設置します。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;place_door&lt;/span&gt;(x, y, floor_x_size, floor_y_size, floor_view, dc):
    &lt;span style="font-style: italic;"&gt;"""&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    Utility function to check and place a door&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    """&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; 0 &amp;lt;= x &amp;lt; floor_x_size &lt;span style="font-weight: bold;"&gt;and&lt;/span&gt; 0 &amp;lt;= y &amp;lt; floor_y_size:
        &lt;span style="font-weight: bold; font-style: italic;"&gt;pos&lt;/span&gt; = y*floor_x_size + x
        &lt;span style="font-weight: bold; font-style: italic;"&gt;c&lt;/span&gt; = floor_view[pos:pos+1]
        &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; c == b&lt;span style="font-style: italic;"&gt;'.'&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;or&lt;/span&gt; c == b&lt;span style="font-style: italic;"&gt;'+'&lt;/span&gt;:
            &lt;span style="font-weight: bold; font-style: italic;"&gt;floor_view&lt;/span&gt;[pos:pos+1] = dc


&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;place_doors&lt;/span&gt;(rooms, fl_xsz, fl_ysz, fl_vw):
    &lt;span style="font-style: italic;"&gt;"""&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    Place locked or unlocked doors in front of rooms.&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;    """&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; r &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; rooms:
        &lt;span style="font-weight: bold; font-style: italic;"&gt;dc&lt;/span&gt; = b&lt;span style="font-style: italic;"&gt;'+'&lt;/span&gt;  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;door character&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; random.randrange(10) == 0:  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;10%&lt;/span&gt;
            &lt;span style="font-weight: bold; font-style: italic;"&gt;dc&lt;/span&gt; = b&lt;span style="font-style: italic;"&gt;'*'&lt;/span&gt;  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;locked door&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; x &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;range&lt;/span&gt;(r.x_size):  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;top and bottom edges&lt;/span&gt;
            place_door(r.x+x, r.y-1, fl_xsz, fl_ysz, fl_vw, dc)
            place_door(r.x+x, r.y+r.y_size, fl_xsz, fl_ysz, fl_vw, dc)

        &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; y &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;range&lt;/span&gt;(r.y_size):  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;left and right edges&lt;/span&gt;
            place_door(r.x-1, r.y+y, fl_xsz, fl_ysz, fl_vw, dc)
            place_door(r.x+r.x_size, r.y+y, fl_xsz, fl_ysz, fl_vw, dc)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
このアルゴリズムには難点があって、部屋のすぐ隣を廊下が併走しているときに、この廊下を全てドアにしてしまいます。まあ、実害は無さそうなので放置しておきましょう。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgbeb568a" class="outline-2"&gt;
&lt;h2 id="orgbeb568a"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; 続き&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
今回はダンジョンフロアの自動生成部分を作ってみました。思いのほか長くなってしまいました。次回はフロアをスクロール画面に表示します。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Python"></category><category term="Python"></category><category term="game"></category></entry><entry><title>キー入力と任意位置へのテキスト表示</title><link href="http://achiwa912.github.io/dl1.html" rel="alternate"></link><published>2021-02-24T00:00:00-05:00</published><updated>2021-12-03T00:00:00-05:00</updated><author><name>きょうす</name></author><id>tag:achiwa912.github.io,2021-02-24:/dl1.html</id><summary type="html">Non-blocking key scan and put character at (x,y)</summary><content type="html">&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orgd56742c"&gt;1. ノンブロッキングキー入力&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org8c66ff4"&gt;2. 任意位置への文字表示&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org06e0f8e"&gt;3. 次回&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
Rogue + Wizライクプロジェクトの2回目はキー入力と画面表示です。
&lt;/p&gt;


&lt;div id="outline-container-orgd56742c" class="outline-2"&gt;
&lt;h2 id="orgd56742c"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; ノンブロッキングキー入力&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
まずはリアルタイムキースキャンから。これがいきなり曲者で、簡単には実現できないようです。
&lt;/p&gt;

&lt;p&gt;
Windowsではmsvcrtというライブラリを使うみたいです。msvcrt.getch()は使い勝手がよさそう。しかし私の手元にはMacしかないので、別のやり方を探してみます。検索すること数十分、いちおう標準ライブラリの(?)termiosを使うやり方がいいのかな。Stackoverflowの&lt;a href="https://stackoverflow.com/questions/13207678/whats-the-simplest-way-of-detecting-keyboard-input-in-a-script-from-the-termina"&gt;このQ&amp;amp;A&lt;/a&gt; に例が出ています。引用します。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; termios, fcntl, sys, os
&lt;span style="font-weight: bold; font-style: italic;"&gt;fd&lt;/span&gt; = sys.stdin.fileno()

&lt;span style="font-weight: bold; font-style: italic;"&gt;oldterm&lt;/span&gt; = termios.tcgetattr(fd)
&lt;span style="font-weight: bold; font-style: italic;"&gt;newattr&lt;/span&gt; = termios.tcgetattr(fd)
&lt;span style="font-weight: bold; font-style: italic;"&gt;newattr&lt;/span&gt;[3] = newattr[3] &amp;amp; ~termios.ICANON &amp;amp; ~termios.ECHO
termios.tcsetattr(fd, termios.TCSANOW, newattr)

&lt;span style="font-weight: bold; font-style: italic;"&gt;oldflags&lt;/span&gt; = fcntl.fcntl(fd, fcntl.F_GETFL)
fcntl.fcntl(fd, fcntl.F_SETFL, oldflags | os.O_NONBLOCK)

&lt;span style="font-weight: bold;"&gt;try&lt;/span&gt;:
    &lt;span style="font-weight: bold;"&gt;while&lt;/span&gt; 1:
        &lt;span style="font-weight: bold;"&gt;try&lt;/span&gt;:
            &lt;span style="font-weight: bold; font-style: italic;"&gt;c&lt;/span&gt; = sys.stdin.read(1)
            &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; c:
                &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;"Got character"&lt;/span&gt;, &lt;span style="font-weight: bold;"&gt;repr&lt;/span&gt;(c))
        &lt;span style="font-weight: bold;"&gt;except&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;IOError&lt;/span&gt;: &lt;span style="font-weight: bold;"&gt;pass&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;finally&lt;/span&gt;:
    termios.tcsetattr(fd, termios.TCSAFLUSH, oldterm)
    fcntl.fcntl(fd, fcntl.F_SETFL, oldflags)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Windowsよりもずいぶん準備や後処理が面倒だし、tryブロックがネストしていて微妙な感じですが、試したところ十分使えそうです。これをお借りしましょう。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org8c66ff4" class="outline-2"&gt;
&lt;h2 id="org8c66ff4"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; 任意位置への文字表示&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
次は画面上の指定位置への文字表示です。昔懐かしのBASIC言語でいうところのLOCATEに相当することがしたいです。検索でだいぶ手間取りましたが、思いのほか簡単に実現できることがわかりました。ANSIエスケープシーケンスで指定するのですね。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(f&lt;span style="font-style: italic;"&gt;"\033[{y};{x}H@"&lt;/span&gt;, end=&lt;span style="font-style: italic;"&gt;''&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
これでx, yの位置にアットマーク('@')を表示します。バックスラッシュ('\')から'H'までが位置指定のエスケープシーケンスです。ここでは1文字しか表示していませんが、2文字以上の文字列を表示させることももちろんできます。
&lt;/p&gt;

&lt;p&gt;
簡単な性能テストをしてみます。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; random
&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; time
&lt;span style="font-weight: bold;"&gt;while&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;True&lt;/span&gt;:
    &lt;span style="font-weight: bold; font-style: italic;"&gt;c&lt;/span&gt; = random.choice([b&lt;span style="font-style: italic;"&gt;'1'&lt;/span&gt;,b&lt;span style="font-style: italic;"&gt;'2'&lt;/span&gt;,b&lt;span style="font-style: italic;"&gt;'3'&lt;/span&gt;,b&lt;span style="font-style: italic;"&gt;'4'&lt;/span&gt;,b&lt;span style="font-style: italic;"&gt;'5'&lt;/span&gt;,b&lt;span style="font-style: italic;"&gt;'6'&lt;/span&gt;,b&lt;span style="font-style: italic;"&gt;'7'&lt;/span&gt;,b&lt;span style="font-style: italic;"&gt;'8'&lt;/span&gt;,b&lt;span style="font-style: italic;"&gt;'9'&lt;/span&gt;])
    &lt;span style="font-weight: bold; font-style: italic;"&gt;start&lt;/span&gt; = time.time()
    &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; y &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;range&lt;/span&gt;(25):
        &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(f&lt;span style="font-style: italic;"&gt;"\033[{y};0H"&lt;/span&gt;, end=&lt;span style="font-style: italic;"&gt;''&lt;/span&gt;)
        &lt;span style="font-weight: bold; font-style: italic;"&gt;line&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;bytearray&lt;/span&gt;(c*60)
        &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(line.decode())
    &lt;span style="font-weight: bold; font-style: italic;"&gt;delta&lt;/span&gt; = time.time() - start
    &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(f&lt;span style="font-style: italic;"&gt;"{delta:.3f}"&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
これはランダムな数字を60x25文字の表示エリアに一様に表示することを繰り返します。実際のゲームと同様にbytearrayで持つ1行ごとのデータを、文字列にデコードしながら1回のプリント文で表示しています。
&lt;/p&gt;

&lt;p&gt;
実行したところ、十分に高速でした。描画しているところはほとんど見えず、実行時間は1画面あたり100分の一秒未満でした。行けそうです。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org06e0f8e" class="outline-2"&gt;
&lt;h2 id="org06e0f8e"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; 次回&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
次はローグライクなランダムマップの自動生成に挑戦します。ありがたいことにRoguelike Tutorialなページが &lt;a href="http://rogueliketutorials.com/tutorials/tcod/v2/part-3/"&gt;ありました&lt;/a&gt; ので、参考にさせていただきます。なるほど、部屋と部屋を結ぶ方法は意外と単純だったのですね。線を引くのにジェネレーターを使うのはよいアイデアと思いました。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Python"></category><category term="Python"></category><category term="game"></category></entry><entry><title>Rogue+Wizライクゲームのリメイク構想</title><link href="http://achiwa912.github.io/dl0.html" rel="alternate"></link><published>2021-02-23T00:00:00-05:00</published><updated>2021-12-03T00:00:00-05:00</updated><author><name>きょうす</name></author><id>tag:achiwa912.github.io,2021-02-23:/dl0.html</id><summary type="html">Rogue-like + Wizardry-like</summary><content type="html">&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org2958966"&gt;1. はじめに&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org31e14b4"&gt;2. どんなゲームを作るか&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org4cc649e"&gt;3. どこから手を付けるか&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org2958966" class="outline-2"&gt;
&lt;h2 id="org2958966"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; はじめに&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
20年ほど前に、Rogue風のマップとWizardryの戦闘システムを組み合わせたような、Daemonという名のゲームをC言語で作って公開していたのですが、去年末くらいにホストしていたWebサイトがひっそりとクローズしていました。
&lt;/p&gt;

&lt;p&gt;
私はPythonの修行中で、中級者向けの本を何冊か読んだのですが、実践不足で本の内容が消化不良になっていることは否めません。そこで、Rogue+WizardryのゲームDaemonをPythonでリメイクしてしばらく実戦経験を積むことにします。Wizardryは古いゲームにしては扱うデータが多く複雑で、データ構造の経験を積むのに適している気がします。当時、C言語で双方向リストを作ってパーティーを表現したりするのが大変だったと記憶していますが、Pythonを使うとどこまで楽になるでしょうか。
&lt;/p&gt;

&lt;p&gt;
とは言え、当時のソースコードや資料は全く残っておらず、全く一から作り直しです。とほほ。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org31e14b4" class="outline-2"&gt;
&lt;h2 id="org31e14b4"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; どんなゲームを作るか&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
私はWizardryが大好きなのですが、あの3Dマップだけは苦手です。Daemonを作ったときの動機が、マップ移動の楽なWizardryで遊びたいというものでした。かと言って、立派なグラフィックの2Dマップを作る余裕もセンスもありません。そこで今回もRogue風のテキストベースマップのお世話になります。
&lt;/p&gt;

&lt;p&gt;
マップ画面イメージ:
&lt;/p&gt;
&lt;pre class="example"&gt;
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^######################..........###
^^^^^######################..........###
^^^^^######################..........###
^^^^^######################..........###
^^^^^######################..........###
^^^^^######################..........##.
^^^^^########.......########+###+######.
^^^^^########.......@#######.###.######.
^^^^^########.......+............#######
^^^^^########.......########.########...
^^^^^###########+###########*########...
^^^^^###########.#######.........####...
^^^^^...........+#######.........####...
^^^^^...........+##....*.........####...
&lt;/pre&gt;

&lt;p&gt;
戦闘システムはWizardryを踏襲し、6人パーティー制です。戦闘は文章だけで進行します。魔法使い、僧侶のスペルは著作権の関係で同じ物(Katino, mahalito, dios等)が使えないので、名前は考えなくてはなりません。今回は日本風にしようかな。
&lt;/p&gt;

&lt;p&gt;
Daemonではダンジョンマップをデータとして用意しましたが、10階分も用意するのはかなり大変だったので、今回はRogueライクを見習って自動生成します。アイテムやモンスターも入力が面倒なので、固定のものを除いて自動生成にしましょうか。うまくゲームバランスが取れるでしょうか。
&lt;/p&gt;

&lt;p&gt;
城や街はマップ無し、メッセージのみのWizardry風です。Wizardryでは年を取るのが怖くて馬小屋ばかり使っていましたが、なんだか可哀想なので年は取らないようにし、年齢ペナルティーも撤廃しましょう。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org4cc649e" class="outline-2"&gt;
&lt;h2 id="org4cc649e"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; どこから手を付けるか&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
まずはキー入力(リアルタイムキースキャン)と画面表示(任意の位置に文字を表示)から始めます。低レベル機能のため、Pythonなのに機種依存が出てくるかもしれません。なるべくPyGameのような大がかりなライブラリには手を出したくないところです。
&lt;/p&gt;

&lt;p&gt;
次はダンジョンマップの自動生成とスクロールマップの表示にチャレンジします。Pythonでローグライクを作るチュートリアルを斜め読みして予習したので、マップの自動生成は多分行けるでしょう。むしろ、ここで十分な性能が出ないと、プロジェクトを断念することになるかも。
&lt;/p&gt;

&lt;p&gt;
次回のアップデートはこのあたりが出来たらになると思います。それでは。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Python"></category><category term="Python"></category><category term="game"></category></entry><entry><title>Pythonでemail送受信テストしてみる</title><link href="http://achiwa912.github.io/pyemail.html" rel="alternate"></link><published>2021-02-05T00:00:00-05:00</published><updated>2021-12-03T00:00:00-05:00</updated><author><name>きょうす</name></author><id>tag:achiwa912.github.io,2021-02-05:/pyemail.html</id><summary type="html">Sending email from Python</summary><content type="html">&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org69f128d"&gt;1. テストSMTPサーバーを立てる&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orga3befb8"&gt;2. テストメールを送る&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org5486a55"&gt;3. テストしてみる&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org1246488"&gt;4. 宛先が表示されない?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org38d7fed"&gt;5. 参考リンク&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org69f128d" class="outline-2"&gt;
&lt;h2 id="org69f128d"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; テストSMTPサーバーを立てる&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
emailのテストをするには、何はともあれSMTPサーバーが必要ですが、Pythonではとても簡単にテスト用のSMTPサーバーを立てることができます。
&lt;/p&gt;

&lt;p&gt;
まずはpipでモジュールをインストールします。
&lt;/p&gt;
&lt;pre class="example"&gt;
pip install aiosmtpd
&lt;/pre&gt;

&lt;p&gt;
そして実行します。
&lt;/p&gt;
&lt;pre class="example"&gt;
python -m aiosmtpd -n
&lt;/pre&gt;

&lt;p&gt;
なんと、これだけ。&lt;a href="https://aiosmtpd.readthedocs.io/en/latest/cli.html"&gt;aiosmtpd公式ドキュメント&lt;/a&gt;によるとlocalhostのポート8025をリッスンするようです。変えるには &lt;code&gt;-l &amp;lt;[HOST][:PORT]&amp;gt;&lt;/code&gt; オプションを与えます。
&lt;/p&gt;

&lt;p&gt;
pipするのが面倒な方は、標準ライブラリにsmtpdがありますが、&lt;a href="https://docs.python.org/3/library/smtpd.html"&gt;公式ドキュメント&lt;/a&gt;によるとdeprecatedなのでaiosmtpdを使うように書いてありました。以下で使えます。
&lt;/p&gt;
&lt;pre class="example"&gt;
python -m smtpd -n -c DebuggingServer &amp;lt;IP address&amp;gt;:&amp;lt;port&amp;gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga3befb8" class="outline-2"&gt;
&lt;h2 id="orga3befb8"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; テストメールを送る&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
SMTPサーバーを立てるほどではありませんが、テストメールの送信も簡単にできます。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; smtplib
&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; email &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; utils
&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; email.mime.text &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; MIMEText

&lt;span style="font-weight: bold; font-style: italic;"&gt;msg&lt;/span&gt; = MIMEText(&lt;span style="font-style: italic;"&gt;'This is the body'&lt;/span&gt;)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12513;&amp;#12540;&amp;#12523;&amp;#26412;&amp;#25991;&lt;/span&gt;
&lt;span style="font-weight: bold; font-style: italic;"&gt;msg&lt;/span&gt;[&lt;span style="font-style: italic;"&gt;'To'&lt;/span&gt;] = utils.formataddr((
    &lt;span style="font-style: italic;"&gt;'Recipient'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'test_recv@example.com'&lt;/span&gt;))
&lt;span style="font-weight: bold; font-style: italic;"&gt;msg&lt;/span&gt;[&lt;span style="font-style: italic;"&gt;'From'&lt;/span&gt;] = utils.formataddr((
    &lt;span style="font-style: italic;"&gt;'Author'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'test_send@example.com'&lt;/span&gt;))
&lt;span style="font-weight: bold; font-style: italic;"&gt;msg&lt;/span&gt;[&lt;span style="font-style: italic;"&gt;'Subject'&lt;/span&gt;] = &lt;span style="font-style: italic;"&gt;'Test email subject'&lt;/span&gt;

&lt;span style="font-weight: bold; font-style: italic;"&gt;server&lt;/span&gt; = smtplib.SMTP(&lt;span style="font-style: italic;"&gt;'localhost'&lt;/span&gt;, 8025)
&lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;server.set_debuglevel(True)  # &amp;#12487;&amp;#12496;&amp;#12483;&amp;#12464;&amp;#29992;&amp;#35443;&amp;#32048;&amp;#12513;&amp;#12483;&amp;#12475;&amp;#12540;&amp;#12472;&amp;#20986;&amp;#21147;&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;try&lt;/span&gt;:
    server.sendmail(&lt;span style="font-style: italic;"&gt;'test_send@example.com'&lt;/span&gt;,
                    [&lt;span style="font-style: italic;"&gt;'test_recv@example.com'&lt;/span&gt;],
                    msg.as_string())
&lt;span style="font-weight: bold;"&gt;finally&lt;/span&gt;:
    server.&lt;span style="font-weight: bold; text-decoration: underline;"&gt;quit&lt;/span&gt;()
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5486a55" class="outline-2"&gt;
&lt;h2 id="org5486a55"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; テストしてみる&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
ターミナル上でテスト用のSMTPサーバーを走らせている状態で、上記のテストメール送信スクリプトを別ターミナルから実行してみます。
&lt;/p&gt;
&lt;pre class="example"&gt;
python emtest.py
&lt;/pre&gt;


&lt;p&gt;
あ、来ました。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;$ python -m aiosmtpd -n
^[---------- MESSAGE FOLLOWS ----------
Content-Type: text/plain; charset=&lt;span style="font-style: italic;"&gt;"us-ascii"&lt;/span&gt;
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
To: Recipient &lt;a href="mailto:test_recv%40example.com"&gt;&amp;lt;test_recv@example.com&amp;gt;&lt;/a&gt;
From: Author &lt;a href="mailto:test_send%40example.com"&gt;&amp;lt;test_send@example.com&amp;gt;&lt;/a&gt;
Subject: Simple test message
X-Peer: (&lt;span style="font-style: italic;"&gt;'::1'&lt;/span&gt;, 52132, 0, 0)

This &lt;span style="font-weight: bold;"&gt;is&lt;/span&gt; the body.
------------ END MESSAGE ------------
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Pythonを使うとemailのテストがとても簡単にできますね。
&lt;/p&gt;

&lt;p&gt;
上記スクリプトのデバッグ用詳細メッセージ出力の行のコメントを外すと、SMTPサーバーとの詳細なやりとりが見られます。(一部情報を伏せています)
&lt;/p&gt;

&lt;pre class="example"&gt;
$ python emtest.py 
send: 'ehlo localhost.localdomain\r\n'
reply: b'250-localhost.localdomain\r\n'
reply: b'250-8BITMIME\r\n'
reply: b'250 HELP\r\n'
reply: retcode (250); Msg: b'localhost.localdomain\n8BITMIME\nHELP'
send: 'mail FROM:&amp;lt;test_send@example.com&amp;gt;\r\n'
reply: b'250 OK\r\n'
reply: retcode (250); Msg: b'OK'
send: 'rcpt TO:&amp;lt;test_recv@example.com&amp;gt;\r\n'
reply: b'250 OK\r\n'
reply: retcode (250); Msg: b'OK'
send: 'data\r\n'
reply: b'354 End data with &amp;lt;CR&amp;gt;&amp;lt;LF&amp;gt;.&amp;lt;CR&amp;gt;&amp;lt;LF&amp;gt;\r\n'
reply: retcode (354); Msg: b'End data with &amp;lt;CR&amp;gt;&amp;lt;LF&amp;gt;.&amp;lt;CR&amp;gt;&amp;lt;LF&amp;gt;'
data: (354, b'End data with &amp;lt;CR&amp;gt;&amp;lt;LF&amp;gt;.&amp;lt;CR&amp;gt;&amp;lt;LF&amp;gt;')
send: b'Content-Type: text/plain; charset="us-ascii"\r\nMIME-Version: 1.0\r\nContent-Transfer-Encoding: 7bit\r\nTo: Recipient &amp;lt;test_recv@example.com&amp;gt;\r\nFrom: Author &amp;lt;test_send@example.com&amp;gt;\r\nSubject: Simple test message\r\n\r\nThis is the body.\r\n.\r\n'
reply: b'250 OK\r\n'
reply: retcode (250); Msg: b'OK'
data: (250, b'OK')
send: 'quit\r\n'
reply: b'221 Bye\r\n'
reply: retcode (221); Msg: b'Bye'
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1246488" class="outline-2"&gt;
&lt;h2 id="org1246488"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; 宛先が表示されない?&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
あることに気がつきました。上で紹介した簡易smtpサーバーで表示される情報に、宛先(To/Cc/Bcc)が表示されないことがあるのです。&lt;a href="https://www.quora.com/How-is-it-possible-that-an-email-with-the-to-field-empty-arrived-in-my-Yahoo-inbox"&gt;調べてみた&lt;/a&gt;ところ、宛先の情報はSMTP envelopeに含まれるRCPT TOが使われることがわかりました。実際の宛先が知りたい場合には、上記smtpサーバーで出力される情報では不足です。
&lt;/p&gt;

&lt;p&gt;
そこで、aiosmtpdのドキュメントを参考(ほぼ丸写しとも言う)に、SMTPサーバー側も簡単なスクリプトを作成してRCPT TO情報を出力するようにしました。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; asyncio

&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;MyHandler&lt;/span&gt;:
    &lt;span style="font-weight: bold;"&gt;async def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;handle_DATA&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, server, session, envelope):
        &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(f&lt;span style="font-style: italic;"&gt;'Msg from {envelope.mail_from}'&lt;/span&gt;)
        &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;envelope&amp;#12398;RCPT TO&amp;#24773;&amp;#22577;&amp;#12434;&amp;#34920;&amp;#31034;&amp;#12377;&amp;#12427;&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(f&lt;span style="font-style: italic;"&gt;'Msg for {envelope.rcpt_tos}'&lt;/span&gt;)
        &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(f&lt;span style="font-style: italic;"&gt;'Msg data:\n'&lt;/span&gt;)
        &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; ln &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; envelope.content.decode(&lt;span style="font-style: italic;"&gt;'utf8'&lt;/span&gt;, errors=&lt;span style="font-style: italic;"&gt;'replace'&lt;/span&gt;).splitlines():
            &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(f&lt;span style="font-style: italic;"&gt;'&amp;gt; {ln}'&lt;/span&gt;.strip())
        &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;()
        &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'End of msg'&lt;/span&gt;)
        &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; &lt;span style="font-style: italic;"&gt;'250 Message accepted for delivery'&lt;/span&gt;

&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; aiosmtpd.controller &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; Controller
&lt;span style="font-weight: bold; font-style: italic;"&gt;ctrlr&lt;/span&gt; = Controller(MyHandler(), hostname=&lt;span style="font-style: italic;"&gt;'&amp;lt;IP&amp;#12450;&amp;#12489;&amp;#12524;&amp;#12473;&amp;gt;'&lt;/span&gt;)
ctrlr.start()
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
さて、どうでしょうか。To/Cc/Bccを含めない送信元からメールを出してみます。
&lt;/p&gt;

&lt;pre class="example"&gt;
Msg from &amp;lt;送り主emailアドレス&amp;gt;
Msg for ['&amp;lt;宛先emailアドレス&amp;gt;']  # RCPT TOsアドレスのリスト
Msg data:

&amp;gt; Date: Fri, 5 Feb 2021 18:12:38 -0500 (EST)
&amp;gt; From: &amp;lt;送り主emailアドレス&amp;gt;
&amp;gt; Message-ID: &amp;lt;XXXXX2588.7.XXXXXXXX.JavaMail.root@XXXXX&amp;gt;
&amp;gt; Subject: &amp;lt;タイトル文字列&amp;gt;
&amp;gt; MIME-Version: 1.0
&amp;gt; Content-Type: text/plain; charset=us-ascii
&amp;gt; Content-Transfer-Encoding: 7bit
&amp;gt;
&amp;gt; This is email contents.
&amp;gt;

End of msg
&lt;/pre&gt;

&lt;p&gt;
無事、宛先アドレスがわかるようになりました。(引用では伏せてあります)
&lt;/p&gt;

&lt;p&gt;
なお、送信側を以下のように変えて、RCPT TOにToとは異なるアドレス(複数可能)を指定することができます。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;try&lt;/span&gt;:
    server.sendmail(&lt;span style="font-style: italic;"&gt;'send@example.com'&lt;/span&gt;,  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;mail from&amp;#12450;&amp;#12489;&amp;#12524;&amp;#12473;&lt;/span&gt;
                    [&lt;span style="font-style: italic;"&gt;'recv1@example.com'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'recv2@example.com'&lt;/span&gt;],  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;RCPT TOs&amp;#12450;&amp;#12489;&amp;#12524;&amp;#12473;&amp;#12398;&amp;#12522;&amp;#12473;&amp;#12488;&lt;/span&gt;
                    msg.as_string())
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org38d7fed" class="outline-2"&gt;
&lt;h2 id="org38d7fed"&gt;&lt;span class="section-number-2"&gt;5&lt;/span&gt; 参考リンク&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://aiosmtpd.readthedocs.io/en/latest/index.html"&gt;aiosmtpd - An asyncio based SMTP server&lt;/a&gt; aiosmtpd公式&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3/library/smtpd.html"&gt;smtpd — SMTP Server&lt;/a&gt; Python公式&lt;/li&gt;
&lt;li&gt;&lt;a href="https://pymotw.com/2/smtpd/"&gt;PyMOTW smtpd – Sample SMTP Servers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Python"></category><category term="Python"></category></entry><entry><title>Python Cookbookレシピリスト</title><link href="http://achiwa912.github.io/cookbooklist.html" rel="alternate"></link><published>2021-01-11T00:00:00-05:00</published><updated>2021-01-22T00:00:00-05:00</updated><author><name>きょうす</name></author><id>tag:achiwa912.github.io,2021-01-11:/cookbooklist.html</id><summary type="html">Python Cookbook 3rd edition recipes list</summary><content type="html">&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orgb03992a"&gt;1. はじめに&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org196c607"&gt;2. レシピ一覧&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org989fec0"&gt;2.1. Chapter 1: データ構造とアルゴリズム&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org555aa91"&gt;2.1.1. defaultdictとsetdefault(1.6)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgc0a2b18"&gt;2.1.2. itemgetter()関数(1.13)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgc5addab"&gt;2.1.3. dictcompを使ってフィルタする(1.17)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#org276d4b1"&gt;2.2. Chapter 2: 文字列とテキスト&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org957360b"&gt;2.2.1. noncaptureグループ(2.1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org0938309"&gt;2.2.2. テキストファイル全体をstripする(2.11)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org6e858ab"&gt;2.2.3. (2.14)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#org3600816"&gt;2.3. Chapter 3: 数、日にちと時間&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org91d96c0"&gt;2.3.1. ランダム値を得る(3.11)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org688330c"&gt;2.3.2. タイムゾーンの扱い(3.16)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#org8e1f4f2"&gt;2.4. Chapter 4: アイテレーターとジェネレーター&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org3959fa7"&gt;2.4.1. iterate可能なオブジェクト (4.4)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org15bc220"&gt;2.4.2. iter()の特別な用法(4.16)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#org27dbfd2"&gt;2.5. Chapter 5: ファイルとI/O&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org1d59159"&gt;2.5.1. バッファインタフェース(5.4)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgb03a621"&gt;2.5.2. 圧縮ファイルの読み書き(5.7)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgb14798f"&gt;2.5.3. mmapを使う(5.10)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org1480057"&gt;2.5.4. テキスト操作の3つのレイヤー(5.16)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb03992a" class="outline-2"&gt;
&lt;h2 id="orgb03992a"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; はじめに&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Python Cookbook 3rd edition by David Beazley &amp;amp; Brian K. Jonesを読んだのですが、読んだことはほとんど忘れてしまっていて、レシピ集として活用できるレベルになっていません。やはり、掲載されているコードサンプルは全て自分で入力して動きを確認していかないと駄目そうです。
&lt;/p&gt;

&lt;p&gt;
そこで、復習の意味でサンプルコードの実行と、自分用にレシピリストを作ることにしました。少しずつアップデートするので、完成までに時間がかかりそうです。今のペースだと5ヶ月くらい。。。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org196c607" class="outline-2"&gt;
&lt;h2 id="org196c607"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; レシピ一覧&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org989fec0" class="outline-3"&gt;
&lt;h3 id="org989fec0"&gt;&lt;span class="section-number-3"&gt;2.1&lt;/span&gt; Chapter 1: データ構造とアルゴリズム&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-1"&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-right" /&gt;

&lt;col  class="org-left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;1.1&lt;/td&gt;
&lt;td class="org-left"&gt;シーケンスやiterableは &lt;code&gt;=&lt;/code&gt; で複数変数にアンパックできる&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;1.2&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;*&lt;/code&gt; (star unpacking)を使って可変数変数をリストに受ける&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;リストのレコードにタグを付けて異なる処理をするレシピ&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;1.3&lt;/td&gt;
&lt;td class="org-left"&gt;限定数のヒストリーを持つのにcollections.dequeが使える &lt;code&gt;deque(maxlen=3)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;ファイル内でアイテムを探す、yieldを使うレシピ&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;1.4&lt;/td&gt;
&lt;td class="org-left"&gt;最大/最小からN個のアイテムを見つけるのにheapqが使える &lt;code&gt;heapq.nlargest(3, somelist)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;大きなリストを扱うにはheapify()しておく&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;1.5&lt;/td&gt;
&lt;td class="org-left"&gt;プライオリティキューを作るのにheapqが使える&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;1.6&lt;/td&gt;
&lt;td class="org-left"&gt;複数値を持つdictionaryの作り方&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;初期値の自動作成にdefaultdictが使えるが、やや不自然&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;1.7&lt;/td&gt;
&lt;td class="org-left"&gt;OrderedDictの使い方。後でJSON化したい時に有用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;1.8&lt;/td&gt;
&lt;td class="org-left"&gt;zip()を使ってdictionaryを(value, key)のシーケンスに並び替えてソート等する&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;1.9&lt;/td&gt;
&lt;td class="org-left"&gt;dictionaries間の共通等を操作するのに &lt;code&gt;&amp;amp;, -&lt;/code&gt; 等のset操作を使う&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;1.10&lt;/td&gt;
&lt;td class="org-left"&gt;シーケンスの順序を維持したままdedupeする&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;重複をsetで管理し、重複していない場合に値をyieldするdedupe関数のレシピ&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;1.11&lt;/td&gt;
&lt;td class="org-left"&gt;スライスに名前を付けてコードの可読性を上げる。ビルトインslice()関数の使い方&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;IndexErrorが出ないように範囲にお編めるには &lt;code&gt;sliceobj.indices(len(s))&lt;/code&gt; を使う&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;1.12&lt;/td&gt;
&lt;td class="org-left"&gt;Counterオブジェクトを使ってアイテムの登場回数を管理する&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;most_common(n)メソッド。 &lt;code&gt;+, -&lt;/code&gt; での複数Counter操作&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;1.13&lt;/td&gt;
&lt;td class="org-left"&gt;ディクショナリのリストをソートするのに、ソートキーkey=itemgetter(キー)を使う&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;lambda関数も使える。ソートだけでなくmin(), max()でも指定可能&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;1.14&lt;/td&gt;
&lt;td class="org-left"&gt;比較をサポートしないオブジェクトをソートする。キーにattrgetter()を指定する&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;1.15&lt;/td&gt;
&lt;td class="org-left"&gt;ディクショナリのリストをフィールド値でグループ分けしたい&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;フィールドでソート(itemgetter())し、groupby()でグループ分けする&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;1.16&lt;/td&gt;
&lt;td class="org-left"&gt;シーケンスをフィルタするにはlistcomp/genexpを使う&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;filter()やcompress()の使い方。compressはbooleanのシーケンスを受ける&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;1.17&lt;/td&gt;
&lt;td class="org-left"&gt;ディクショナリをフィルタしてサブセットのディクショナリを取り出すにはdictcompを使う&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;1.18&lt;/td&gt;
&lt;td class="org-left"&gt;namedtupleの使い方。dict &amp;rarr; namedtuple変換レシピ&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;デフォルト値からなるnamedtupleを作り、_replace(**dic)でアップデートする&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;1.19&lt;/td&gt;
&lt;td class="org-left"&gt;変換/フィルタしてからsum(),min(),max()等するのにgenexpを使う(値のみ返す)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;genexpの代わりに、min(), max()等にkey引数を渡すレシピ(全体を返す)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;1.20&lt;/td&gt;
&lt;td class="org-left"&gt;collections.ChainMapは複数のマッピングを仮想的に一つにまとめる&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;ChainMapへのアップデートは、最初のマップにのみ反映される&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;div id="outline-container-org555aa91" class="outline-4"&gt;
&lt;h4 id="org555aa91"&gt;&lt;span class="section-number-4"&gt;2.1.1&lt;/span&gt; defaultdictとsetdefault(1.6)&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-1-1"&gt;
&lt;p&gt;
&lt;code&gt;defaultdict&lt;/code&gt; は以下のように使う
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; collections &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; defaultdict
&lt;span style="font-weight: bold; font-style: italic;"&gt;d&lt;/span&gt; = defaultdict(&lt;span style="font-weight: bold;"&gt;list&lt;/span&gt;)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;list, set&amp;#31561;&amp;#12434;&amp;#25351;&amp;#23450;&lt;/span&gt;
d[&lt;span style="font-style: italic;"&gt;'a'&lt;/span&gt;].append(1)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;set&amp;#12398;&amp;#22580;&amp;#21512;&amp;#12399;.add(1)&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
defaultdictは、間違えてアクセス(値の取得でも)をした場合にも空きリスト/セットが設定されてしまう。
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;setdefault&lt;/code&gt; は通常のディクショナリに対して使える
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;d&lt;/span&gt; = {}  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#26222;&amp;#36890;&amp;#12398;&amp;#12487;&amp;#12451;&amp;#12463;&amp;#12471;&amp;#12519;&amp;#12490;&amp;#12522;&lt;/span&gt;
d.setdeault(&lt;span style="font-style: italic;"&gt;'a'&lt;/span&gt;, []).append(1)
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgc0a2b18" class="outline-4"&gt;
&lt;h4 id="orgc0a2b18"&gt;&lt;span class="section-number-4"&gt;2.1.2&lt;/span&gt; itemgetter()関数(1.13)&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-1-2"&gt;
&lt;p&gt;
&lt;code&gt;operator.itemgetter(item), itemgetter(*items)&lt;/code&gt; は引数に &lt;code&gt;__getitem__()&lt;/code&gt; に渡せるインデックスを取り、callableを返す。 &lt;code&gt;f = itemgetter(2)&lt;/code&gt; の後で &lt;code&gt;f(r)&lt;/code&gt; をコールすると &lt;code&gt;r[2]&lt;/code&gt; を返す。同様に、 &lt;code&gt;g = itemgetter(2, 5, 3)&lt;/code&gt; の後で &lt;code&gt;g(r)&lt;/code&gt; をコールすると &lt;code&gt;(r[2], r[5], r[3])&lt;/code&gt; のタプルを返す。
&lt;/p&gt;

&lt;p&gt;
sort等の関数に &lt;code&gt;key=itemgetter('some_key')&lt;/code&gt; のように指定する。レシピ1.14の &lt;code&gt;attrgetter()&lt;/code&gt; も同様。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgc5addab" class="outline-4"&gt;
&lt;h4 id="orgc5addab"&gt;&lt;span class="section-number-4"&gt;2.1.3&lt;/span&gt; dictcompを使ってフィルタする(1.17)&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-1-3"&gt;
&lt;p&gt;
以下のようなパターンで使う。
&lt;/p&gt;
&lt;pre class="example"&gt;
{ key:value for key,value in prices.items() if value &amp;gt; 200}
{ key:value for key,value in prices.items() if key in tech_names }
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org276d4b1" class="outline-3"&gt;
&lt;h3 id="org276d4b1"&gt;&lt;span class="section-number-3"&gt;2.2&lt;/span&gt; Chapter 2: 文字列とテキスト&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-2"&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-right" /&gt;

&lt;col  class="org-left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;2.1&lt;/td&gt;
&lt;td class="org-left"&gt;混在するdelimitersに対処 &lt;code&gt;re.split(r'[;,\s]\s*', line)&lt;/code&gt; のように使う&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;2.2&lt;/td&gt;
&lt;td class="org-left"&gt;文字列の先頭または末尾を調べるのにstartswith(), endswith()を使う&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;複数選択肢がある場合はタプルを渡す &lt;code&gt;name.endswith(('.py', 'html'))&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;2.3&lt;/td&gt;
&lt;td class="org-left"&gt;fnmatch(), fnmatchcase()の使い方 &lt;code&gt;fnmatch('foo.txt', '*.txt')&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;ワイルドカードを使いたいとき。正規表現未満。ファイル名以外でも&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;2.4&lt;/td&gt;
&lt;td class="org-left"&gt;正規表現 re.compile(), match(), findall(), finditer()の使い方&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;2.5&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;str.replace('before', 'after')&lt;/code&gt; re.sub()/subn()使い方&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;re.sub(r'(\d+)/(\d+)/(\d+)', r'\3-\1-\2', text)&lt;/code&gt; コールバック指定可&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;2.6&lt;/td&gt;
&lt;td class="org-left"&gt;re.findall()等にflags=re.IGNORECASEを付ける&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;置き換え単語のケースを維持する、closureのヘルプ関数を使ったレシピ&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;2.7&lt;/td&gt;
&lt;td class="org-left"&gt;正規表現で最短マッチ &lt;code&gt;re.compile(r'\"(.*?)\"')&lt;/code&gt; のように?を付ける&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;2.8&lt;/td&gt;
&lt;td class="org-left"&gt;複数行にわたるマッチ &lt;code&gt;re.compile(r'/\*((?:.¦\n)*?)\*/')&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;re.DOTALLよりも自分でマッチパターンを書いた方が融通が利く&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;2.9&lt;/td&gt;
&lt;td class="org-left"&gt;unicode textをnormalizeする &lt;code&gt;unicodedata.normalize('NFC', text)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;combining文字を含むテキストをasciiに変換するレシピ。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;2.10&lt;/td&gt;
&lt;td class="org-left"&gt;uniocde文字を正規表現で扱う場合、case foldに注意&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;本格的にやるなら3rd partyのregexライブラリ等を使う&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;2.11&lt;/td&gt;
&lt;td class="org-left"&gt;strip(), lstrip(), rstrip() スペース以外の文字も指定可能 &lt;code&gt;strip('-=')&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;先頭、末尾以外もstripしたい場合 &lt;code&gt;re.sub('\s+', ' ', text)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;2.12&lt;/td&gt;
&lt;td class="org-left"&gt;テキストをsanitize, clean upするのにtranslate()を使うレシピ&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;NFDにnormalizeして &lt;code&gt;b.encode('ascii', 'ignore').decode('ascii')&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;速度ではstr.replace()メソッドが一番速い&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;2.13&lt;/td&gt;
&lt;td class="org-left"&gt;ljust(), rjust(), center()を使ったallignment &lt;code&gt;text.rjust(20, '=')&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;format()も使える。ストリング以外でも &lt;code&gt;format(x, '10.2f')&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;2.14&lt;/td&gt;
&lt;td class="org-left"&gt;str.join()の使い方 &lt;code&gt;+&lt;/code&gt; は文字列をコピーするので非効率(遅い)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;print文のセパレーター指定は使える &lt;code&gt;print(a,b,c,sep=' ')&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;多くの文字列小片をyieldするgenerator関数を使うレシピ&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;2.15&lt;/td&gt;
&lt;td class="org-left"&gt;文字列に変数を入れ込む &lt;code&gt;s.format_map(vars())&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;dictを継承し、__missing__()を持つクラスを作って例外にならないように&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;vars()の代わりにsys._getframe(1).f_localsを使うframe hackレシピ&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;2.16&lt;/td&gt;
&lt;td class="org-left"&gt;1行の文字数を制限して表示するためにtextwrapモジュールを使う&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;textwrap.fill(s, 40, initial_indent='    ')&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;2.17&lt;/td&gt;
&lt;td class="org-left"&gt;HTML/XMLエンティティーの扱い html.escape(), html.unescape()&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;2.18&lt;/td&gt;
&lt;td class="org-left"&gt;token化する &lt;code&gt;(?P&amp;lt;grp_name&amp;gt;...)&lt;/code&gt; でグループ名を付け、scanner()を使う&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;2.19&lt;/td&gt;
&lt;td class="org-left"&gt;(パーサーを書く。BNFとかEBNFとか)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;2.20&lt;/td&gt;
&lt;td class="org-left"&gt;byte stringsにテキスト操作が意外と使える。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;正規表現も使えるが、パターンをbyte string b'&amp;#x2026;'で指定する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;div id="outline-container-org957360b" class="outline-4"&gt;
&lt;h4 id="org957360b"&gt;&lt;span class="section-number-4"&gt;2.2.1&lt;/span&gt; noncaptureグループ(2.1)&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-2-1"&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&amp;gt;&amp;gt;&amp;gt; re.split(r&lt;span style="font-style: italic;"&gt;'[;,\s]\s*'&lt;/span&gt;, line)
[&lt;span style="font-style: italic;"&gt;'asdf'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'fjdk'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'afed'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'fjek'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'asdf'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'foo'&lt;/span&gt;]
&amp;gt;&amp;gt;&amp;gt; re.split(r&lt;span style="font-style: italic;"&gt;'(;|,|\s)\s*'&lt;/span&gt;, line)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;capture&amp;#12464;&amp;#12523;&amp;#12540;&amp;#12503;(&amp;#32080;&amp;#26524;&amp;#12398;&amp;#12522;&amp;#12473;&amp;#12488;&amp;#12395;&amp;#20986;&amp;#21147;&amp;#12373;&amp;#12428;&amp;#12427;)&lt;/span&gt;
[&lt;span style="font-style: italic;"&gt;'asdf'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;' '&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'fjdk'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;';'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'afed'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;','&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'fjek'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;','&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'asdf'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;','&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'foo'&lt;/span&gt;]
&amp;gt;&amp;gt;&amp;gt; re.split(r&lt;span style="font-style: italic;"&gt;'(?:;|,|\s)\s*'&lt;/span&gt;, line)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;noncapture&amp;#12464;&amp;#12523;&amp;#12540;&amp;#12503; (?: ...)&lt;/span&gt;
[&lt;span style="font-style: italic;"&gt;'asdf'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'fjdk'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'afed'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'fjek'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'asdf'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'foo'&lt;/span&gt;]
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0938309" class="outline-4"&gt;
&lt;h4 id="org0938309"&gt;&lt;span class="section-number-4"&gt;2.2.2&lt;/span&gt; テキストファイル全体をstripする(2.11)&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-2-2"&gt;
&lt;p&gt;
ファイル内の行を全てstripしたい場合、genexpで効率よく実現できる。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;with&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;open&lt;/span&gt;(filename) &lt;span style="font-weight: bold;"&gt;as&lt;/span&gt; f:
    &lt;span style="font-weight: bold; font-style: italic;"&gt;lines&lt;/span&gt; = (line.strip() &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; line &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; f)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;iterator&amp;#12434;&amp;#20316;&amp;#12427;&amp;#12384;&amp;#12369;&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; line &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; lines:
        ...
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6e858ab" class="outline-4"&gt;
&lt;h4 id="org6e858ab"&gt;&lt;span class="section-number-4"&gt;2.2.3&lt;/span&gt; (2.14)&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-2-3"&gt;
&lt;p&gt;
genexpを使ってリストを文字列に変換するレシピ。文字列化と連結を一括で実施する。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold; font-style: italic;"&gt;data&lt;/span&gt; = [&lt;span style="font-style: italic;"&gt;'ACME'&lt;/span&gt;, 50, 91.1]
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-style: italic;"&gt;','&lt;/span&gt;.join(&lt;span style="font-weight: bold;"&gt;str&lt;/span&gt;(d) &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; d &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; data)
&lt;span style="font-style: italic;"&gt;'ACME,50,91.1'&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3600816" class="outline-3"&gt;
&lt;h3 id="org3600816"&gt;&lt;span class="section-number-3"&gt;2.3&lt;/span&gt; Chapter 3: 数、日にちと時間&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-3"&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-right" /&gt;

&lt;col  class="org-left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;3.1&lt;/td&gt;
&lt;td class="org-left"&gt;数字を四捨五入するのにround()を使う。 &lt;code&gt;round(-1.27, 1) &amp;gt;&amp;gt;&amp;gt; -1.3&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;マイナス値も使える &lt;code&gt;round(7734, -2) &amp;gt;&amp;gt;&amp;gt; 7700&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;3.2&lt;/td&gt;
&lt;td class="org-left"&gt;浮動小数点の誤差が許せない場合は Decimal('4.2') を使う&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;with localcontext() as ctx: のように精度等を制御できる&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;3.3&lt;/td&gt;
&lt;td class="org-left"&gt;formatの使い方 &lt;code&gt;format(x, '^10.1f'), format(x, '0.2e')&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;3.4&lt;/td&gt;
&lt;td class="org-left"&gt;2進、8進、16進での表記 &lt;code&gt;oct(x), format(x, 'o')&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;10進に直すにはintを使う &lt;code&gt;int('4d2', 16)&lt;/code&gt;  8進は0o755のように&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;3.5&lt;/td&gt;
&lt;td class="org-left"&gt;バイト列から大きなintegerをパック、アンパックする&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;int.from_bytes(data, 'little'), x.to_bytes(16, 'little')&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;x.bit_length()&lt;/code&gt; でビット長取得&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;3.6&lt;/td&gt;
&lt;td class="org-left"&gt;複素数を使う &lt;code&gt;complex(2, 4), 3-5j, cmath.sqrt(-1)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;3.7&lt;/td&gt;
&lt;td class="org-left"&gt;無限とNaN(not a number) &lt;code&gt;float('inf'), float('-inf'), float('nan')&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;3.8&lt;/td&gt;
&lt;td class="org-left"&gt;分数 fractions.Fraction &lt;code&gt;Fraction(5, 4)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;3.9&lt;/td&gt;
&lt;td class="org-left"&gt;numpyの基本的な使い方 カラム &lt;code&gt;a[:,2]&lt;/code&gt;, subregion &lt;code&gt;a[1:3, 1:3]&lt;/code&gt; 選択&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;3.10&lt;/td&gt;
&lt;td class="org-left"&gt;numpyでの線形代数計算(パス)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;3.11&lt;/td&gt;
&lt;td class="org-left"&gt;ランダム値を得る randint(0, 10)は0も10も含む。random()&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;3.12&lt;/td&gt;
&lt;td class="org-left"&gt;時間の変換 &lt;code&gt;timedelta(hours=4.5), datetime(2021, 1, 26)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;dateutil.relativedelta()&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;3.13&lt;/td&gt;
&lt;td class="org-left"&gt;先週の火曜日は何日、のレシピ。 dateutil.relativedeltaで簡単に。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;relativedelta(weekday=FR), relativedelta(weekday=FR(-1)&lt;/code&gt; 先週&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;3.14&lt;/td&gt;
&lt;td class="org-left"&gt;今月をリストするレシピ。ビルトインrange()の日にち版レシピ&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;date.today().replace(day=1), calendar.monthrange(yr, mon)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;3.15&lt;/td&gt;
&lt;td class="org-left"&gt;文字列で表記された日にちをdatetimeに変換するレシピ&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&lt;code&gt;datetime.strptime(text, '%Y-%m-%d')&lt;/code&gt; strftimeで逆変換&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;3.16&lt;/td&gt;
&lt;td class="org-left"&gt;タイムゾーンの変換はpytzモジュールを使う&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;ローカル時間を操作するレシピ。いったんUTCに変換する&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;div id="outline-container-org91d96c0" class="outline-4"&gt;
&lt;h4 id="org91d96c0"&gt;&lt;span class="section-number-4"&gt;2.3.1&lt;/span&gt; ランダム値を得る(3.11)&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-3-1"&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; random
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold; font-style: italic;"&gt;values&lt;/span&gt; = [1,2,3,4,5,6]
&amp;gt;&amp;gt;&amp;gt; random.choice(values)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#19968;&amp;#12388;&amp;#36984;&amp;#12406;&lt;/span&gt;
2
&amp;gt;&amp;gt;&amp;gt; random.sample(values, 3)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;3&amp;#12388;&amp;#36984;&amp;#12406;&lt;/span&gt;
[4, 3, 1]
&amp;gt;&amp;gt;&amp;gt; random.shuffle(values)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12521;&amp;#12531;&amp;#12480;&amp;#12512;&amp;#12395;&amp;#20006;&amp;#12403;&amp;#26367;&amp;#12360;&amp;#12427;&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; values
[5, 2, 3, 1, 4, 6]
&amp;gt;&amp;gt;&amp;gt; random.random()  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;0-1&amp;#12398;float&amp;#20516;&amp;#12434;&amp;#24471;&amp;#12427;&lt;/span&gt;
0.14043684176026439
&amp;gt;&amp;gt;&amp;gt; random.seed()  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12471;&amp;#12473;&amp;#12486;&amp;#12512;&amp;#26178;&amp;#38291;&amp;#12420;os.random()&amp;#12505;&amp;#12540;&amp;#12473;&amp;#12398;&amp;#12471;&amp;#12540;&amp;#12489;&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; random.seed(12345)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
暗号に使う厳密なランダム値は ssl.RAND_byes() 等を使うこと。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org688330c" class="outline-4"&gt;
&lt;h4 id="org688330c"&gt;&lt;span class="section-number-4"&gt;2.3.2&lt;/span&gt; タイムゾーンの扱い(3.16)&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-3-2"&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; datetime &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; datetime
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; pytz
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold; font-style: italic;"&gt;d&lt;/span&gt; = datetime(2021, 1, 27, 21, 30,0)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;(1) datetime&amp;#12391;&amp;#26085;&amp;#26178;&amp;#12434;&amp;#34920;&amp;#35352;&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(d)
2021-01-27 21:30:00
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold; font-style: italic;"&gt;boston&lt;/span&gt; = timezone(&lt;span style="font-style: italic;"&gt;'America/New_York'&lt;/span&gt;)
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold; font-style: italic;"&gt;bos_d&lt;/span&gt; = boston.localize(d)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;(2) &amp;#26481;&amp;#28023;&amp;#23736;&amp;#26178;&amp;#38291;&amp;#12395;&amp;#25351;&amp;#23450;&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(bos_d)
2021-01-27 21:30:00-05:00
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold; font-style: italic;"&gt;utc_d&lt;/span&gt; = bos_d.astimezone(pytz.utc)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;(3) UTC&amp;#12395;&amp;#22793;&amp;#25563;&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(utc_d)
2021-01-28 02:30:00+00:00
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold; font-style: italic;"&gt;later_utc_d&lt;/span&gt; = utc_d + timedelta(minutes=30)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;(4) UTC&amp;#12391;&amp;#26178;&amp;#38291;&amp;#35336;&amp;#31639;&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold; font-style: italic;"&gt;japan&lt;/span&gt; = timezone(&lt;span style="font-style: italic;"&gt;'Asia/Tokyo'&lt;/span&gt;)
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(later_utc_d.astimezone(japan))  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;(5) JST&amp;#26178;&amp;#38291;&amp;#12391;&amp;#34920;&amp;#31034;&lt;/span&gt;
2021-01-28 12:00:00+09:00
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
国のタイムゾーンを取得する方法。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&amp;gt;&amp;gt;&amp;gt; pytz.country_timezones[&lt;span style="font-style: italic;"&gt;'JP'&lt;/span&gt;]
[&lt;span style="font-style: italic;"&gt;'Asia/Tokyo'&lt;/span&gt;]
&amp;gt;&amp;gt;&amp;gt; pytz.country_timezones[&lt;span style="font-style: italic;"&gt;'US'&lt;/span&gt;]
[&lt;span style="font-style: italic;"&gt;'America/New_York'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'America/Detroit'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'America/Kentucky/Louisville'&lt;/span&gt;, 
&lt;span style="font-style: italic;"&gt;'America/Kentucky/Monticello'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'America/Indiana/Indianapolis'&lt;/span&gt;, 
&lt;span style="font-style: italic;"&gt;'America/Indiana/Vincennes'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'America/Indiana/Winamac'&lt;/span&gt;, 
&lt;span style="font-style: italic;"&gt;'America/Indiana/Marengo'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'America/Indiana/Petersburg'&lt;/span&gt;, 
&lt;span style="font-style: italic;"&gt;'America/Indiana/Vevay'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'America/Chicago'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'America/Indiana/Tell_City'&lt;/span&gt;, 
&lt;span style="font-style: italic;"&gt;'America/Indiana/Knox'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'America/Menominee'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'America/North_Dakota/Center'&lt;/span&gt;, 
&lt;span style="font-style: italic;"&gt;'America/North_Dakota/New_Salem'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'America/North_Dakota/Beulah'&lt;/span&gt;, 
&lt;span style="font-style: italic;"&gt;'America/Denver'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'America/Boise'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'America/Phoenix'&lt;/span&gt;, 
&lt;span style="font-style: italic;"&gt;'America/Los_Angeles'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'America/Anchorage'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'America/Juneau'&lt;/span&gt;, 
&lt;span style="font-style: italic;"&gt;'America/Sitka'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'America/Metlakatla'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'America/Yakutat'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'America/Nome'&lt;/span&gt;, 
&lt;span style="font-style: italic;"&gt;'America/Adak'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'Pacific/Honolulu'&lt;/span&gt;]
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org8e1f4f2" class="outline-3"&gt;
&lt;h3 id="org8e1f4f2"&gt;&lt;span class="section-number-3"&gt;2.4&lt;/span&gt; Chapter 4: アイテレーターとジェネレーター&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-4"&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-right" /&gt;

&lt;col  class="org-left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;4.1&lt;/td&gt;
&lt;td class="org-left"&gt;for文を使わずにiterateする&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;4.2&lt;/td&gt;
&lt;td class="org-left"&gt;カスタムコンテナオブジェクトにiteratorプロトコルを実装する&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;__iter__()は__next__()を実装するiteratorオブジェクトを返す&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;iter(s)はs.__iter__()と同じ&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;4.3&lt;/td&gt;
&lt;td class="org-left"&gt;新たなiterationパターンはジェネレーター関数で実装する&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;4.4&lt;/td&gt;
&lt;td class="org-left"&gt;オブジェクトに再帰呼び出しするジェネレーター関数を定義してiterateする&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;4.5&lt;/td&gt;
&lt;td class="org-left"&gt;シーケンスを逆にiterateする。reverse()を使う。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;__reverse__()を実装する(効率よい)か、いったんリストにする&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;4.6&lt;/td&gt;
&lt;td class="org-left"&gt;ジェネレーター関数にステートを持たせるには、クラスにすればよい&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;4.7&lt;/td&gt;
&lt;td class="org-left"&gt;iteratorをスライス(eg, [1:5])するにはitertools.islice()を使う&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;4.8&lt;/td&gt;
&lt;td class="org-left"&gt;iterableの最初の部分をスキップするにはitertools.dropwhile()を使う&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;4.9&lt;/td&gt;
&lt;td class="org-left"&gt;itertools.permutations, combinations, combinations_with_replacement&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;4.10&lt;/td&gt;
&lt;td class="org-left"&gt;シーケンスに行番号やインデックス番号を付けるにはenumerateを使う&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;4.11&lt;/td&gt;
&lt;td class="org-left"&gt;複数のシーケンスを同時にたどるにはzip()を使う zip_longest()&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;4.12&lt;/td&gt;
&lt;td class="org-left"&gt;複数のシーケンスを一つにつなげるのはchain()を使う&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;シーケンスを+でつなげるのは、同じタイプでないといけない&amp;amp; inefficient&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;4.13&lt;/td&gt;
&lt;td class="org-left"&gt;ジェネレーター関数をパイプラインでつなぐ&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;4.14&lt;/td&gt;
&lt;td class="org-left"&gt;ネストされたシーケンスをflattenするのに、ジェネレーター関数を&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;yield fromで再帰呼び出しするレシピ&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;4.15&lt;/td&gt;
&lt;td class="org-left"&gt;ソートされた複数のリストをマージするのにheapq.mergeが使える&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;4.16&lt;/td&gt;
&lt;td class="org-left"&gt;sentinelが出るまでストリームをiterateするiter(lambda: xx, sentinel)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;を使うレシピ&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3959fa7" class="outline-4"&gt;
&lt;h4 id="org3959fa7"&gt;&lt;span class="section-number-4"&gt;2.4.1&lt;/span&gt; iterate可能なオブジェクト (4.4)&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-4-1"&gt;
&lt;p&gt;
ルートノードから世代をiterateするオブジェクトの実装例。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;Node&lt;/span&gt;:
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__init__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, value)
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;._value = value
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;._children = []
&amp;lt;snip&amp;gt;
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__iter__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
        &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;iter&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;._children)
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;depth_first&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12472;&amp;#12455;&amp;#12493;&amp;#12524;&amp;#12540;&amp;#12479;&amp;#12540;&amp;#38306;&amp;#25968;&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;yield&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; c &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;:
            &lt;span style="font-weight: bold;"&gt;yield&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; c.depth_first()  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#20877;&amp;#24112;&amp;#21628;&amp;#12403;&amp;#20986;&amp;#12375;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org15bc220" class="outline-4"&gt;
&lt;h4 id="org15bc220"&gt;&lt;span class="section-number-4"&gt;2.4.2&lt;/span&gt; iter()の特別な用法(4.16)&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-4-2"&gt;
&lt;p&gt;
iter()に引数を取らないcallableとsentinelを与えると、sentinelが出るまで指定callableを繰り返し呼ぶiteratorを返す。引数を取らないcallableを作るためにlambdaを使う。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;reader&lt;/span&gt;(s):
    &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; chunk &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;iter&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;lambda&lt;/span&gt;: s.recv(CHUNKSIZE), b&lt;span style="font-style: italic;"&gt;''&lt;/span&gt;):
        process_data(chunk)

&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; sys
&lt;span style="font-weight: bold; font-style: italic;"&gt;f&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;open&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'/etc/passwd'&lt;/span&gt;)
&lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; chunk &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;iter&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;lambda&lt;/span&gt;: f.read(10), &lt;span style="font-style: italic;"&gt;''&lt;/span&gt;):
    &lt;span style="font-weight: bold; font-style: italic;"&gt;n&lt;/span&gt; = sys.stdout.write(chunk)
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org27dbfd2" class="outline-3"&gt;
&lt;h3 id="org27dbfd2"&gt;&lt;span class="section-number-3"&gt;2.5&lt;/span&gt; Chapter 5: ファイルとI/O&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-5"&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-right" /&gt;

&lt;col  class="org-left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;5.1&lt;/td&gt;
&lt;td class="org-left"&gt;テキストファイルを読み書きするにはopenする。withを使うと便利。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;リターンコード、エンコードエラーの扱い&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;5.2&lt;/td&gt;
&lt;td class="org-left"&gt;print('&amp;#x2026;', file=fd)を使ってファイルにリダイレクトする&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;5.3&lt;/td&gt;
&lt;td class="org-left"&gt;print('&amp;#x2026;', sep=',', end='!!\n')&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;str.join()と異なり、文字列以外にも使える&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;5.4&lt;/td&gt;
&lt;td class="org-left"&gt;open('filename', 'rb') 'wb' でバイナリモードでオープン&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;配列やC構造体はいったんバイナリに変換しなくてよい&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;readinto()はメモリに直接読み可能&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;5.5&lt;/td&gt;
&lt;td class="org-left"&gt;既存ファイルがあるとライトを失敗させるには'xb' 'xt'を指定する&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;with open('file', 'xt') as f:&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;5.6&lt;/td&gt;
&lt;td class="org-left"&gt;文字列やバイト列をファイルライクなオブジェクトとして扱うレシピ&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;io.StringIO(), io.BytesIO()&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;5.7&lt;/td&gt;
&lt;td class="org-left"&gt;gzip.open(), bz2.open()を使って圧縮ファイルを読み書きする&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;正しいファイルモード(テキスト/バイナリ)を使う事が重要&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;5.8&lt;/td&gt;
&lt;td class="org-left"&gt;固定サイズずつバイナリファイルをiterateするレシピ&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;iter(partial(f.read, REC_SZ), b'')を使う b'': sentinel&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;5.9&lt;/td&gt;
&lt;td class="org-left"&gt;mutableなバッファにバイナリデータを読む f.readinto(buf)を使う&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;memoryviewを使っても。bytes(mv)で中身を見る&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;5.10&lt;/td&gt;
&lt;td class="org-left"&gt;mmapを使うレシピ。コンテキストマネージャとしても使える&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;5.11&lt;/td&gt;
&lt;td class="org-left"&gt;パス名の操作にはos.pathモジュールを使う&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;5.12&lt;/td&gt;
&lt;td class="org-left"&gt;os.pathの関数 exists(), isfile(), islink(), realpath(), getsize(), etc.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;5.13&lt;/td&gt;
&lt;td class="org-left"&gt;ディレクトリのリスティング。os.listdir(), endswith(), glob, fnmatch等&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;os.stat(file)でメタデータ一括取得&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;5.14&lt;/td&gt;
&lt;td class="org-left"&gt;listdir(b'.'), open(b'..txt')でファイル名エンコーディングをバイパスする&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;5.15&lt;/td&gt;
&lt;td class="org-left"&gt;デコードできないファイル名をどう扱うか&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;5.16&lt;/td&gt;
&lt;td class="org-left"&gt;オープンしているファイルのエンコーディングを変えるレシピ&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;f.detach()してTextIOWrapperレイヤーを別エンコードで付け直す&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;5.17&lt;/td&gt;
&lt;td class="org-left"&gt;テキストファイルにバイトを書き込む。 f.buffer.write(b'&amp;#x2026;')&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;5.18&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1d59159" class="outline-4"&gt;
&lt;h4 id="org1d59159"&gt;&lt;span class="section-number-4"&gt;2.5.1&lt;/span&gt; バッファインタフェース(5.4)&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-5-1"&gt;
&lt;p&gt;
配列(アレイ)等はバッファインタフェースを持ち、いったんバイトに変換せずにバイトとして読み書きできる。配列等にバイトを直接読み出すのにfd.readinto(array)が使える。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; array
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold; font-style: italic;"&gt;nums&lt;/span&gt; = array.array(&lt;span style="font-style: italic;"&gt;'i'&lt;/span&gt;, [1,2,3,4])
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold;"&gt;with&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;open&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'tt.bin'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'wb'&lt;/span&gt;) &lt;span style="font-weight: bold;"&gt;as&lt;/span&gt; f:
...     f.write(nums)
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold; font-style: italic;"&gt;a&lt;/span&gt; = array.array(&lt;span style="font-style: italic;"&gt;'i'&lt;/span&gt;,[0,0,0,0,0,0])
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold;"&gt;with&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;open&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'tt.bin'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'rb'&lt;/span&gt;) &lt;span style="font-weight: bold;"&gt;as&lt;/span&gt; f:
...     f.readinto(a)
&amp;gt;&amp;gt;&amp;gt; a
array(&lt;span style="font-style: italic;"&gt;'i'&lt;/span&gt;, [1, 2, 3, 4, 0, 0])
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb03a621" class="outline-4"&gt;
&lt;h4 id="orgb03a621"&gt;&lt;span class="section-number-4"&gt;2.5.2&lt;/span&gt; 圧縮ファイルの読み書き(5.7)&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-5-2"&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; gzip
&lt;span style="font-weight: bold;"&gt;with&lt;/span&gt; gzip.&lt;span style="font-weight: bold;"&gt;open&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'file.gz'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'rt'&lt;/span&gt;) &lt;span style="font-weight: bold;"&gt;as&lt;/span&gt; f:
    &lt;span style="font-weight: bold; font-style: italic;"&gt;text&lt;/span&gt; = f.read()

&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; bz2
&lt;span style="font-weight: bold;"&gt;with&lt;/span&gt; bz2.&lt;span style="font-weight: bold;"&gt;open&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'file.bz2'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'wb'&lt;/span&gt;) &lt;span style="font-weight: bold;"&gt;as&lt;/span&gt; f:
    f.write(&lt;span style="font-weight: bold;"&gt;bytes&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
バイナリモードでオープンした既存ファイルに重ねることが可能。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;f&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;open&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'file.gz'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'rb'&lt;/span&gt;)
&lt;span style="font-weight: bold;"&gt;with&lt;/span&gt; gzip.&lt;span style="font-weight: bold;"&gt;open&lt;/span&gt;(f, &lt;span style="font-style: italic;"&gt;'rt'&lt;/span&gt;) &lt;span style="font-weight: bold;"&gt;as&lt;/span&gt; g:
    &lt;span style="font-weight: bold; font-style: italic;"&gt;text&lt;/span&gt; = g.read()
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
これは、ソケット、パイプ、インメモリファイル等のファイルライクなオブジェクトに対して使えるということ。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb14798f" class="outline-4"&gt;
&lt;h4 id="orgb14798f"&gt;&lt;span class="section-number-4"&gt;2.5.3&lt;/span&gt; mmapを使う(5.10)&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-5-3"&gt;
&lt;p&gt;
mmapを使うユーティリティ関数。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; os                                                                              
&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; mmap                                                                            
&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;memory_map&lt;/span&gt;(filename, access=mmap.ACCESS_WRITE):                                    
    &lt;span style="font-weight: bold; font-style: italic;"&gt;size&lt;/span&gt; = os.path.getsize(filename)                                                   
    &lt;span style="font-weight: bold; font-style: italic;"&gt;fd&lt;/span&gt; = os.&lt;span style="font-weight: bold;"&gt;open&lt;/span&gt;(filename, os.O_RDWR)                                                  
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; mmap.mmap(fd, size, access=access)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
mmapするファイルを用意する。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;size&lt;/span&gt; = 10000
&lt;span style="font-weight: bold;"&gt;with&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;open&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'tt.bin'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'wb'&lt;/span&gt;) &lt;span style="font-weight: bold;"&gt;as&lt;/span&gt; f:
    f.seek(size-1)
    f.write(b&lt;span style="font-style: italic;"&gt;'\x00'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
使い方。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold; font-style: italic;"&gt;m&lt;/span&gt; = memory_map(&lt;span style="font-style: italic;"&gt;'tt.bin'&lt;/span&gt;)
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold;"&gt;len&lt;/span&gt;(m)
10000
&amp;gt;&amp;gt;&amp;gt; m[:10]
b&lt;span style="font-style: italic;"&gt;'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; m[0]
0
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold; font-style: italic;"&gt;m&lt;/span&gt;[:11] = b&lt;span style="font-style: italic;"&gt;'Hello World'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; m
&amp;lt;mmap.mmap &lt;span style="font-weight: bold; font-style: italic;"&gt;closed&lt;/span&gt;=&lt;span style="font-weight: bold; text-decoration: underline;"&gt;False&lt;/span&gt;, &lt;span style="font-weight: bold; font-style: italic;"&gt;access&lt;/span&gt;=&lt;span style="font-weight: bold; font-style: italic;"&gt;ACCESS_WRITE&lt;/span&gt;, &lt;span style="font-weight: bold; font-style: italic;"&gt;length&lt;/span&gt;=&lt;span style="font-weight: bold; font-style: italic;"&gt;10000&lt;/span&gt;, &lt;span style="font-weight: bold; font-style: italic;"&gt;pos&lt;/span&gt;=&lt;span style="font-weight: bold; font-style: italic;"&gt;0&lt;/span&gt;, &lt;span style="font-weight: bold; font-style: italic;"&gt;offset&lt;/span&gt;=0&amp;gt;
&amp;gt;&amp;gt;&amp;gt; m.close()  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#24517;&amp;#38920;!&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; m
&amp;lt;mmap.mmap &lt;span style="font-weight: bold; font-style: italic;"&gt;closed&lt;/span&gt;=&lt;span style="font-weight: bold; text-decoration: underline;"&gt;True&lt;/span&gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold;"&gt;with&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;open&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'tt.bin'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'rb'&lt;/span&gt;) &lt;span style="font-weight: bold;"&gt;as&lt;/span&gt; f:
...     &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(f.read(11))
... 
b&lt;span style="font-style: italic;"&gt;'Hello World'&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
コンテキストマネージャとしても使える。close()不要。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;with&lt;/span&gt; memory_map(&lt;span style="font-style: italic;"&gt;'tt.bin'&lt;/span&gt;) &lt;span style="font-weight: bold;"&gt;as&lt;/span&gt; m:
    &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;len&lt;/span&gt;(m))
    &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(m[0:10])
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1480057" class="outline-4"&gt;
&lt;h4 id="org1480057"&gt;&lt;span class="section-number-4"&gt;2.5.4&lt;/span&gt; テキスト操作の3つのレイヤー(5.16)&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-5-4"&gt;
&lt;p&gt;
テキストファイルは3つのレイヤーでアクセスする。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold; font-style: italic;"&gt;f&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;open&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'tt.txt'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'w'&lt;/span&gt;)
&amp;gt;&amp;gt;&amp;gt; f  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12486;&amp;#12461;&amp;#12473;&amp;#12488;&amp;#12495;&amp;#12531;&amp;#12489;&amp;#12522;&amp;#12531;&amp;#12464;&amp;#12524;&amp;#12452;&amp;#12516;&amp;#12540;&lt;/span&gt;
&amp;lt;_io.TextIOWrapper &lt;span style="font-weight: bold; font-style: italic;"&gt;name&lt;/span&gt;=&lt;span style="font-style: italic;"&gt;'tt.txt'&lt;/span&gt; &lt;span style="font-weight: bold; font-style: italic;"&gt;mode&lt;/span&gt;=&lt;span style="font-style: italic;"&gt;'w'&lt;/span&gt; &lt;span style="font-weight: bold; font-style: italic;"&gt;encoding&lt;/span&gt;=&lt;span style="font-style: italic;"&gt;'UTF-8'&lt;/span&gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; f.&lt;span style="font-weight: bold;"&gt;buffer&lt;/span&gt;  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;buffered I/O&amp;#12524;&amp;#12452;&amp;#12516;&amp;#12540;&lt;/span&gt;
&amp;lt;_io.BufferedWriter &lt;span style="font-weight: bold; font-style: italic;"&gt;name&lt;/span&gt;=&lt;span style="font-style: italic;"&gt;'tt.txt'&lt;/span&gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; f.&lt;span style="font-weight: bold;"&gt;buffer&lt;/span&gt;.raw  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;OS&amp;#12398;&amp;#20302;&amp;#12524;&amp;#12505;&amp;#12523;&amp;#12501;&amp;#12449;&amp;#12452;&amp;#12523;&amp;#12487;&amp;#12473;&amp;#12463;&amp;#12522;&amp;#12503;&amp;#12479;&amp;#12540;&lt;/span&gt;
&amp;lt;_io.FileIO &lt;span style="font-weight: bold; font-style: italic;"&gt;name&lt;/span&gt;=&lt;span style="font-style: italic;"&gt;'tt.txt'&lt;/span&gt; &lt;span style="font-weight: bold; font-style: italic;"&gt;mode&lt;/span&gt;=&lt;span style="font-style: italic;"&gt;'wb'&lt;/span&gt; &lt;span style="font-weight: bold; font-style: italic;"&gt;closefd&lt;/span&gt;=&lt;span style="font-weight: bold; text-decoration: underline;"&gt;True&lt;/span&gt;&amp;gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Python"></category><category term="Python"></category></entry><entry><title>Python Cookbook 3rd Editionを読みました</title><link href="http://achiwa912.github.io/cookbook.html" rel="alternate"></link><published>2021-01-09T00:00:00-05:00</published><updated>2021-01-10T00:00:00-05:00</updated><author><name>きょうす</name></author><id>tag:achiwa912.github.io,2021-01-09:/cookbook.html</id><summary type="html">Python Cookbook by David Beazley, Brian K. Jones</summary><content type="html">&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org442ac91"&gt;1. はじめに&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org39a580f"&gt;2. Python Cookbook&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org7272dd0"&gt;2.1. 内容&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org255e1b9"&gt;2.2. 難易度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org9a7088d"&gt;2.3. 感想&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#org9e51896"&gt;3. 久々のアップデート&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org442ac91" class="outline-2"&gt;
&lt;h2 id="org442ac91"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; はじめに&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Python修行のために中級向けのPython本3冊を4ヶ月かけて立て続けに読みました。
Python Cookbook 3rd Editionはその3冊目になります。
これまで以下の本を読んできましたが、初心者向けではなかった最初の一冊を除いて、なかなか良いセレクションと順番だったと思います。
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Introducing Python&lt;/li&gt;
&lt;li&gt;Python Crash Course&lt;/li&gt;
&lt;li&gt;Effective Python&lt;/li&gt;
&lt;li&gt;Fluent Python&lt;/li&gt;
&lt;li&gt;Python Cookbook&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;



&lt;div id="outline-container-org39a580f" class="outline-2"&gt;
&lt;h2 id="org39a580f"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; Python Cookbook&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
Python Cookbook 3rd Edition, David Beazley, Brian K. Jones
野ウサギが表紙のO'Reilly本です。
&lt;/p&gt;


&lt;div id="org5ba25fe" class="figure"&gt;
&lt;p&gt;&lt;img src="./images/cookbook.jpg" alt="cookbook.jpg" /&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7272dd0" class="outline-3"&gt;
&lt;h3 id="org7272dd0"&gt;&lt;span class="section-number-3"&gt;2.1&lt;/span&gt; 内容&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-1"&gt;
&lt;p&gt;
Pythonicなコードで書かれたレシピ集です。リファレンス本として推薦されていることも多いですが、解説が優秀で学習本としても役に立ちます。私はcover-to-coverで読みました。最後のC extensionsの章は飛ばしても良かった気もしますが、今後役に立つ時が来るかもしれません。
&lt;/p&gt;

&lt;p&gt;
載っているコードは、レシピとして使うにはやや清廉され過ぎていている気もします。Pythonicなコードに慣れるという意味ではよいのですが、レシピとして使い回す以前に腰を落ち着けて書いてある内容を理解する必要がありそうです。そういう意味で、この本はいったん全て読んでから、リファレンス的なレシピ集として活用するのが良いように思います。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org255e1b9" class="outline-3"&gt;
&lt;h3 id="org255e1b9"&gt;&lt;span class="section-number-3"&gt;2.2&lt;/span&gt; 難易度&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-2"&gt;
&lt;p&gt;
Intermediate(中級)向けの本として紹介されていることもありますが、この本は本当に難しいです。Effective Python &amp;rarr; Fluent Python &amp;rarr; Python Cookbookの順で読むと良い、とどこかに書いてあったのでその通りにしましたが、正解でした。特にFluent Pythonを読んで知識の底上げをしていなかったら、最初の100ページで挫折していたと思います。
&lt;/p&gt;

&lt;p&gt;
レシピによってだいぶ難易度に差があります。中でも、スレッドの代わりにジェネレーターを使ってコンカレンシーを実現するレシピ(12.12)は、一週間ほど悩み、ノートに流れを整理してやっと理解できました。何度も挫折しそうになりつつ、2ヶ月かけてようやくcover-to-coverで読み終えることができました。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org9a7088d" class="outline-3"&gt;
&lt;h3 id="org9a7088d"&gt;&lt;span class="section-number-3"&gt;2.3&lt;/span&gt; 感想&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-3"&gt;
&lt;p&gt;
レシピ集ということで、実際に使用可能なコードを読み込んで実力を付けたい、と思ってあえてcover-to-coverで読みましたが、サンプルコードが高度すぎて読むのに手間取ったこともあり、運用能力はあまり上がった気がしません。今回はサンプルコードを実際に動かさなかったこともあるかもしれません。
&lt;/p&gt;

&lt;p&gt;
一方で、一通り読んだ割にはどんなレシピがあったかあまり覚えておらず、このままでは本来のレシピ集として活用できる気もしません。。。。というわけで、Appendixとしてレシピ一覧を自分用に作っておこうと思います。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org9e51896" class="outline-2"&gt;
&lt;h2 id="org9e51896"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; 久々のアップデート&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
またもや3ヶ月ぶりのアップデートです。この記事は12月に書いていたのですが、Python
やブログ開発環境が壊れていて、更に1ヶ月ほど放置してしまいました。その間にSQLの勉強をしていたので、こちらも後で記事にしたいと思います。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Python"></category><category term="Python"></category></entry><entry><title>Fluent Pythonを読みました</title><link href="http://achiwa912.github.io/fluent.html" rel="alternate"></link><published>2020-10-21T00:00:00-04:00</published><updated>2020-10-21T00:00:00-04:00</updated><author><name>きょうす</name></author><id>tag:achiwa912.github.io,2020-10-21:/fluent.html</id><summary type="html">Fluent Pythonの感想</summary><content type="html">&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org04daf57"&gt;1. Preface&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orgdc74bf8"&gt;1.1. 経過&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#org5478524"&gt;2. Fluent Python&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org1979696"&gt;2.1. 読みやすさ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org57d6e37"&gt;2.2. 古さと間違い&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org3cf6b7c"&gt;2.3. 内容&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgd3123b8"&gt;2.4. 対象読者とレベル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org5a4f1e4"&gt;2.5. 効果と結論&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org04daf57" class="outline-2"&gt;
&lt;h2 id="org04daf57"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Preface&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
久々の更新です。これまで何をやっていたのかというと、&lt;a href="https://www.amazon.com/Fluent-Python-Concise-Effective-Programming/dp/1491946008"&gt;Fluent Python&lt;/a&gt; を読んでいたのです。最初はEffective Pythonの時のように読書メモをブログに上げようと思ったのですが、あまりに本の内容そのままになっていたので、個人的なメモにしました。
&lt;/p&gt;

&lt;p&gt;
更にPCを変えたので、環境を作り直しています。pelicanは動くようになりましたが、うまくgithubにアップロードできるでしょうか。。。試したところ、なんとかできたようです。本題に入ります。
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgdc74bf8" class="outline-3"&gt;
&lt;h3 id="orgdc74bf8"&gt;&lt;span class="section-number-3"&gt;1.1&lt;/span&gt; 経過&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-1"&gt;
&lt;p&gt;
英語でPython中上級者向けの推薦本を検索すると、次の3冊がよく出てきます。
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://effectivepython.com/"&gt;Effective Python Second Edition&lt;/a&gt; Brett Slatkin著&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.amazon.com/Fluent-Python-Concise-Effective-Programming/dp/1491946008"&gt;Fluent Python: Clear, Concise, and Effective Programming&lt;/a&gt; Luciano Ramalho著&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.amazon.com/Python-Cookbook-Third-David-Beazley/dp/1449340377"&gt;Python Cookbook, Third Edition&lt;/a&gt; David Beazley, Brian K. Jones著&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Introducing Python, Python Crash Courseと読んできて、更に次のレベルにステップアップしたいと考えていたので、評判の良い上記の3冊をその順番で読んでしばらく修行することにしました。
&lt;/p&gt;

&lt;p&gt;
どれも難易度が高そうなので、単にさらっと読むと消化不良に陥りそうです。そこで、日本語でメモを取りながら読むことにしました。Effective Pythonの読書メモはこのブログで公開しています。
&lt;/p&gt;

&lt;p&gt;
Effective Pythonを読了して気を良くした私は、そのままFluent Pythonに入りました。しかしこちらは700ページの大作です。果たして最後まで行き着くでしょうか。。。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5478524" class="outline-2"&gt;
&lt;h2 id="org5478524"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; Fluent Python&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org1979696" class="outline-3"&gt;
&lt;h3 id="org1979696"&gt;&lt;span class="section-number-3"&gt;2.1&lt;/span&gt; 読みやすさ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-1"&gt;
&lt;p&gt;
意外にも、Fluent PythonはEffective Pythonよりもすんなり読み進めることができました。もちろん内容は高度で、Effective Pythonが踏み込めていない詳細な説明もたくさんありましたが、その分、検索をして一通り周辺知識を底上げしてからでないと読み進められない箇所はあまりありませんでした。
&lt;/p&gt;

&lt;p&gt;
ほとんどのページ登場するソースコードスニペットも、それほど苦労せずに理解できたと思います。ただ、ソースコードには番号だけが振ってあって、その説明が後で出てくるので、ソースコードと説明を行ったり来たりしなくてはならず、読みづらかったです。また、ページの切り替わりでインデントがわからなくなる点もやや困りました。手動入力して実行するときにエラーになるので。
&lt;/p&gt;

&lt;p&gt;
全般的に、高度な内容を中級者でもわかる程度までかみ砕いてよく説明されていると思いました。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org57d6e37" class="outline-3"&gt;
&lt;h3 id="org57d6e37"&gt;&lt;span class="section-number-3"&gt;2.2&lt;/span&gt; 古さと間違い&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-2"&gt;
&lt;p&gt;
この本は2015年の出版で、Python 3.4時点の内容で書かれています。このため、f-stringやwalrusオペレーター(&lt;code&gt;:=&lt;/code&gt;)を使っていないことと、コルーチン、asyncio周りの説明に古さを感じました。特に今ではawaitと書くべきところがyield fromとなっているのは、混乱するので何とかして欲しかったところです。せめてオンラインの&lt;a href="https://www.oreilly.com/catalog/errata.csp?isbn=0636920032519"&gt;errata&lt;/a&gt;でそのあたりの補足があればよかったのですが。ちなみに、Python Crash Courseには、古くなった内容をケアするサイトが用意されていて助かりました。
&lt;/p&gt;

&lt;p&gt;
errataが用意されているところからわかるように、誤字脱字の間違いは意外と多かったです。しかし、読み進めることが困難になるようなミスはありませんでした。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3cf6b7c" class="outline-3"&gt;
&lt;h3 id="org3cf6b7c"&gt;&lt;span class="section-number-3"&gt;2.3&lt;/span&gt; 内容&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-3"&gt;
&lt;p&gt;
肝心の内容は、素晴らしいの一言です。さすがに700ページあるだけあって、私が説明して欲しいことはほぼ全てカバーされていましたし、初めて見るようなこともたくさんありました。Effective Pythonで消化不要気味に感じていたところが詳しく説明されているのはありがたかったです。
&lt;/p&gt;

&lt;p&gt;
iterator, iterable, ジェネレーター関数の違いは、本書を読んで初めて腹に落ちた気がします。スペシャルメソッドの役割と、それらを実装することによる効果が理解できたのもよかったです。
&lt;/p&gt;

&lt;p&gt;
一点、最後に出てくるメタプログラミングだけはもう少し説明が欲しかったです。再三「使うな」と言われるので、深く理解する必要は無いのかもしれませんが。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd3123b8" class="outline-3"&gt;
&lt;h3 id="orgd3123b8"&gt;&lt;span class="section-number-3"&gt;2.4&lt;/span&gt; 対象読者とレベル&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-4"&gt;
&lt;p&gt;
対象となる読者は中級レベルで、上級者を目指す人向けだと思います。入門書を一冊読んだばかりで、例えばリストとタプル、セットの違いが漠然としかわかっていない人には厳しいでしょう。
&lt;/p&gt;

&lt;p&gt;
コンピューターサイエンスの基本的な知識も多少は無いと読み進められないと思います。スレッドとプロセスの違い、コンテキストスイッチの仕方、ロックの必要性といった知識が無いと、コンカレント処理の説明は厳しいです。それでも、コルーチンやasyncioの説明は、だいぶ想像力を働かせないといけません。。。
&lt;/p&gt;

&lt;p&gt;
何か他のスクリプトでない言語、例えばC/C++やJavaの経験も欲しいところです。
&lt;/p&gt;

&lt;p&gt;
Pythonは入門者に優しい、敷居の低い言語ですが、結局、やることが高度になると、それなりの知識が要求されます。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5a4f1e4" class="outline-3"&gt;
&lt;h3 id="org5a4f1e4"&gt;&lt;span class="section-number-3"&gt;2.5&lt;/span&gt; 効果と結論&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-5"&gt;
&lt;p&gt;
Effective PythonもFluent Pythonも中上級(intermediate-advanced)向けと言われているようです。私がこれらの本を読む前は初中級くらいだったと思いますが、2冊比較的じっくり(ie, メモを取りながら)読み終わってみて、中上級になれたのかというと、やや怪しいように感じます。おまけして中級になれたくらいでしょうか。
&lt;/p&gt;

&lt;p&gt;
コルーチンやメタプログラミングのような高度な知識が多少なりとも付いた一方で、Pythonでコーディングする能力が劇的に伸びた気はしません。実践不足のため基礎がしっかりしておらず、所々抜けがあるものと思われます。更に、読んだことの多くは既に忘れてしまっているでしょう。Effective Python分も含めて、読書メモを使って何度も復習したいと思います。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Python"></category><category term="Python"></category></entry><entry><title>Effective Python一人輪読会(Item 75 to 90)</title><link href="http://achiwa912.github.io/effective5.html" rel="alternate"></link><published>2020-08-31T00:00:00-04:00</published><updated>2020-10-24T00:00:00-04:00</updated><author><name>きょうす</name></author><id>tag:achiwa912.github.io,2020-08-31:/effective5.html</id><summary type="html">Effective Python読書メモ5</summary><content type="html">&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org5cbea73"&gt;1. Chapter 9: テストとデバッグ&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org242a2f6"&gt;1.1. Item 75: デバッグ用表示にはreprを使え&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org20348f6"&gt;1.2. Item 76: TestCaseのサブクラスを使って関連する挙動を検証せよ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org5bd7a35"&gt;1.3. Item 77: setUp, tearDown, setUpModule, tearDownModuleを使って各テストを独立させよ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org21cfcfa"&gt;1.4. Item 78: 複雑な依存関係を持つコードをテストするために Mocks を使え&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org443b510"&gt;1.5. Item 79: Mockingとテストを容易にするため依存関係をカプセル化せよ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org051f31c"&gt;1.6. Item 80: pdbを使って対話的にデバッグせよ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org178e96f"&gt;1.7. Item 81: メモリの利用状況とリークを調べるためtracemallocを使え&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgaf422a1"&gt;2. Chapter 10: コラボレーション&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org0a8957d"&gt;2.1. Item 82: コミュニティーが作るモジュールをどこで見つけるかを知れ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgdd5ef80"&gt;2.2. Item 83: 隔離された、再現可能な依存関係のために仮想環境を使え&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgfcabe33"&gt;2.3. Item 84: 全ての関数、クラス、モジュールにdocstringsを書け&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org7922027"&gt;2.4. Item 85: モジュールを管理し、安定したAPIを提供するためにパッケージを使え&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org8549b09"&gt;2.5. Item 86: デプロイ環境をconfigureするためにモジュールスコープのコードを検討せよ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgbd2c13c"&gt;2.6. Item 87: APIから呼び主をinsulateするためにルート例外を定義せよ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgec0fa56"&gt;2.7. Item 88: 循環依存を断ち切る方法を知れ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org4bc48ca"&gt;2.8. Item 89: リファクタリングと利用の移行促進のために warningを検討せよ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgbb599ec"&gt;2.9. Item 90: バグを取り除くためにtypingを使った静的解析を検討せよ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#org64cd370"&gt;3. 終わりに&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org0c38e71"&gt;3.1. 感想&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org75234b7"&gt;3.1.1. 内容全般&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgaeb0030"&gt;3.1.2. この本の読み方&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org9f270ed"&gt;3.1.3. 第2版について&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org952b159"&gt;3.1.4. 前後参照の多さ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orge6b5884"&gt;3.1.5. Kindle版&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#org44552a2"&gt;3.2. その次&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5cbea73" class="outline-2"&gt;
&lt;h2 id="org5cbea73"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Chapter 9: テストとデバッグ&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org242a2f6" class="outline-3"&gt;
&lt;h3 id="org242a2f6"&gt;&lt;span class="section-number-3"&gt;1.1&lt;/span&gt; Item 75: デバッグ用表示にはreprを使え&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-1"&gt;
&lt;p&gt;
print文を使ったデバッグは有用です。デバッグにおいてはintの5とstrの'5'の違いが重要になってくるので、reprを使って表示するべきです。
&lt;/p&gt;

&lt;p&gt;
普通に作ったクラスを表示しても有用な情報は表示されないので、 &lt;code&gt;__repr__&lt;/code&gt; を用意するか &lt;code&gt;__dict__&lt;/code&gt; を表示します。本書には自分で作ったクラスなら前者をするように書いてありますが、 &lt;code&gt;__repr__&lt;/code&gt; 自体が信用できないケースもあるような気がするので、 &lt;code&gt;__dict__&lt;/code&gt; だけで十分なような。いや、__dict__は見づらいですね。
&lt;/p&gt;

&lt;p&gt;
F-Stringsの &lt;code&gt;{}&lt;/code&gt; は &lt;code&gt;f'...{..!r}...'&lt;/code&gt; のように &lt;code&gt;!r&lt;/code&gt; サフィックスを付けるとrepr扱いになります。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org20348f6" class="outline-3"&gt;
&lt;h3 id="org20348f6"&gt;&lt;span class="section-number-3"&gt;1.2&lt;/span&gt; Item 76: TestCaseのサブクラスを使って関連する挙動を検証せよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-2"&gt;
&lt;p&gt;
ここではunittestを勧めていますが、&lt;a href="https://realpython.com/pytest-python-testing/"&gt;pytest&lt;/a&gt;の方が良さそうです。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5bd7a35" class="outline-3"&gt;
&lt;h3 id="org5bd7a35"&gt;&lt;span class="section-number-3"&gt;1.3&lt;/span&gt; Item 77: setUp, tearDown, setUpModule, tearDownModuleを使って各テストを独立させよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-3"&gt;
&lt;p&gt;
pytestにも&lt;a href="https://docs.pytest.org/en/stable/xunit_setup.html"&gt;同様の機能&lt;/a&gt;がありますが、よりパワフルなfixtureメカニズムが使えるかも知れません。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;setup_module&lt;/span&gt;(module):
&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;teardown_module&lt;/span&gt;(module):

@&lt;span style="font-weight: bold;"&gt;classmethod&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;setup_clas&lt;/span&gt;(cls):
@&lt;span style="font-weight: bold;"&gt;classmethod&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;teardown_class&lt;/span&gt;(cls):

&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;setup_method&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, method):
&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;teardown_method&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, method):

&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;setup_function&lt;/span&gt;(function):
&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;teardown_function&lt;/span&gt;(function):
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org21cfcfa" class="outline-3"&gt;
&lt;h3 id="org21cfcfa"&gt;&lt;span class="section-number-3"&gt;1.4&lt;/span&gt; Item 78: 複雑な依存関係を持つコードをテストするために Mocks を使え&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-4"&gt;
&lt;p&gt;
pytestの&lt;a href="https://docs.pytest.org/en/stable/monkeypatch.html"&gt;monkeypatch&lt;/a&gt; fixtureが相当するようです。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org443b510" class="outline-3"&gt;
&lt;h3 id="org443b510"&gt;&lt;span class="section-number-3"&gt;1.5&lt;/span&gt; Item 79: Mockingとテストを容易にするため依存関係をカプセル化せよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-5"&gt;
&lt;p&gt;
この節もunittestをベースに話が進むため、斜め読みです。
&lt;/p&gt;

&lt;p&gt;
独立した関数をクラスメソッドにしたりすると、テストが容易になる場合があるそうです。テストを読みやすくするためにもリファクタリングするとよい、とのこと。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org051f31c" class="outline-3"&gt;
&lt;h3 id="org051f31c"&gt;&lt;span class="section-number-3"&gt;1.6&lt;/span&gt; Item 80: pdbを使って対話的にデバッグせよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-6"&gt;
&lt;p&gt;
pdbの使い方が衝撃的です。コードの止めたい部分に &lt;code&gt;breakpoint()&lt;/code&gt; を埋め込みます。
以下の例では、 &lt;code&gt;if err_2 &amp;gt;= 1:&lt;/code&gt; で止めたい条件を絞り込んでいます。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; math

&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;compute_rmse&lt;/span&gt;(observed, ideal):
    &lt;span style="font-weight: bold; font-style: italic;"&gt;total_err_2&lt;/span&gt; = 0
    &lt;span style="font-weight: bold; font-style: italic;"&gt;count&lt;/span&gt; = 0
    &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; got, wanted &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;zip&lt;/span&gt;(observed, ideal):
        &lt;span style="font-weight: bold; font-style: italic;"&gt;err_2&lt;/span&gt; = (got - wanted) ** 2
        &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; err_2 &amp;gt;= 1:  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;Injected for pdb&lt;/span&gt;
            &lt;span style="font-weight: bold;"&gt;breakpoint&lt;/span&gt;()  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;Breakpoint will trigger pdb &lt;/span&gt;
        &lt;span style="font-weight: bold; font-style: italic;"&gt;total_err_2&lt;/span&gt; += err_2
        &lt;span style="font-weight: bold; font-style: italic;"&gt;count&lt;/span&gt; += 1
    &lt;span style="font-weight: bold; font-style: italic;"&gt;mean_err&lt;/span&gt; = total_err_2 / count
    &lt;span style="font-weight: bold; font-style: italic;"&gt;rmse&lt;/span&gt; = math.sqrt(mean_err)
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; rmse

&lt;span style="font-weight: bold; font-style: italic;"&gt;result&lt;/span&gt; = compute_rmse(
    [1.8, 1.7, 3.2, 6],
    [2, 1.5, 3, 5])
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(result)
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
この状態で普通に実行すると、 &lt;code&gt;breakpoint()&lt;/code&gt; の次の行(の直前)でpdbが起動します。変数を見るなり、ステップ実行するなりします。
&lt;/p&gt;

&lt;p&gt;
pdbコマンドチートシート:
&lt;/p&gt;
&lt;pre class="example"&gt;
s - step; ステップ実行
n - next; 1行実行。関数だったら戻るまで実行。
c - continue; 次のブレークポイントまで実行再開
locals() - ローカル変数表示
help
q - quit
&lt;/pre&gt;

&lt;p&gt;
post-mortemデバッグは以下のように実行します。例外が出たらpdbが起動します。変数の値を見るくらいしかできませんが。。。
&lt;/p&gt;
&lt;pre class="example"&gt;
python -m pdb -c continue &amp;lt;filename&amp;gt;.py
あるいは、
&amp;gt;&amp;gt;&amp;gt; import my_module
&amp;gt;&amp;gt;&amp;gt; my_module.some_func()
Traceback ...&amp;lt;snip&amp;gt;
&amp;gt;&amp;gt;&amp;gt; import pdb; pdb.pm()
&lt;/pre&gt;

&lt;p&gt;
これまでprint文デバッグばかりでしたが、pdbも使うようにしたいと思います。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org178e96f" class="outline-3"&gt;
&lt;h3 id="org178e96f"&gt;&lt;span class="section-number-3"&gt;1.7&lt;/span&gt; Item 81: メモリの利用状況とリークを調べるためtracemallocを使え&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-7"&gt;
&lt;p&gt;
まずはメモリを浪費する準備です。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; os
&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;MyObject&lt;/span&gt;:
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__init__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.data = os.urandom(100)

&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;get_data&lt;/span&gt;():
    &lt;span style="font-weight: bold; font-style: italic;"&gt;values&lt;/span&gt; = []
    &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; _ &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;range&lt;/span&gt;(100):
        &lt;span style="font-weight: bold; font-style: italic;"&gt;obj&lt;/span&gt; = MyObject()
        values.append(obj)
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; values

&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;run&lt;/span&gt;():
    &lt;span style="font-weight: bold; font-style: italic;"&gt;deep_values&lt;/span&gt; = []
    &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; _ &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;range&lt;/span&gt;(100):
        deep_values.append(get_data())
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; deep_values
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
tracemallocを使います。メモリ浪費関数(&lt;code&gt;run()&lt;/code&gt;)の前後でメモリのスナップショットを取り、差分を見ます。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; tracemalloc
tracemalloc.start(10)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;Set stack depth&lt;/span&gt;
&lt;span style="font-weight: bold; font-style: italic;"&gt;time1&lt;/span&gt; = tracemalloc.take_snapshot()
&lt;span style="font-weight: bold; font-style: italic;"&gt;x&lt;/span&gt; = run()
&lt;span style="font-weight: bold; font-style: italic;"&gt;time2&lt;/span&gt; = tracemalloc.take_snapshot()
&lt;span style="font-weight: bold; font-style: italic;"&gt;stats&lt;/span&gt; = time2.compare_to(time1, &lt;span style="font-style: italic;"&gt;'lineno'&lt;/span&gt;)
&lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; stat &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; stats[:3]:
    &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(stat)
&amp;gt;&amp;gt;&amp;gt;
t.py:4: &lt;span style="font-weight: bold; font-style: italic;"&gt;size&lt;/span&gt;=2314 KiB (+2314 KiB), &lt;span style="font-weight: bold; font-style: italic;"&gt;count&lt;/span&gt;=29993 (+29993), &lt;span style="font-weight: bold; font-style: italic;"&gt;average&lt;/span&gt;=79 B
t.py:9: &lt;span style="font-weight: bold; font-style: italic;"&gt;size&lt;/span&gt;=469 KiB (+469 KiB), &lt;span style="font-weight: bold; font-style: italic;"&gt;count&lt;/span&gt;=10001 (+10001), &lt;span style="font-weight: bold; font-style: italic;"&gt;average&lt;/span&gt;=48 B
t.py:10: &lt;span style="font-weight: bold; font-style: italic;"&gt;size&lt;/span&gt;=82.8 KiB (+82.8 KiB), &lt;span style="font-weight: bold; font-style: italic;"&gt;count&lt;/span&gt;=100 (+100), &lt;span style="font-weight: bold; font-style: italic;"&gt;average&lt;/span&gt;=848 B
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgaf422a1" class="outline-2"&gt;
&lt;h2 id="orgaf422a1"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; Chapter 10: コラボレーション&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org0a8957d" class="outline-3"&gt;
&lt;h3 id="org0a8957d"&gt;&lt;span class="section-number-3"&gt;2.1&lt;/span&gt; Item 82: コミュニティーが作るモジュールをどこで見つけるかを知れ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-1"&gt;
&lt;p&gt;
Python Package Index (PyPI)はPythonパッケージのセントラルレポジトリです。PyPIからパッケージをインストールするには pip を使います。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgdd5ef80" class="outline-3"&gt;
&lt;h3 id="orgdd5ef80"&gt;&lt;span class="section-number-3"&gt;2.2&lt;/span&gt; Item 83: 隔離された、再現可能な依存関係のために仮想環境を使え&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-2"&gt;
&lt;p&gt;
はい、venvなら使っています。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgfcabe33" class="outline-3"&gt;
&lt;h3 id="orgfcabe33"&gt;&lt;span class="section-number-3"&gt;2.3&lt;/span&gt; Item 84: 全ての関数、クラス、モジュールにdocstringsを書け&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-3"&gt;
&lt;p&gt;
docstringsを書きましょう。ただし、type annotationsと重複する情報は不要です。
&lt;/p&gt;

&lt;p&gt;
docstringsは &lt;code&gt;__doc__&lt;/code&gt; でアクセスできます。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;repr&lt;/span&gt;(some_func.&lt;span style="font-weight: bold;"&gt;__doc__&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
ビルトインの &lt;code&gt;pydoc&lt;/code&gt; モジュールはWebサーバーを立ち上げ、自作のモジュールも含めてアクセス可能な全てのPythonドキュメントが見られるようになります。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;$ python -m pydoc -p 1234
Server ready at http://localhost:1234/
Server commands: [b]rowser, [q]uit
server&amp;gt; b
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7922027" class="outline-3"&gt;
&lt;h3 id="org7922027"&gt;&lt;span class="section-number-3"&gt;2.4&lt;/span&gt; Item 85: モジュールを管理し、安定したAPIを提供するためにパッケージを使え&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-4"&gt;
&lt;p&gt;
ディレクトリに &lt;code&gt;__init__.py&lt;/code&gt; を入れることでパッケージが定義されます。パッケージの第1の目的は、ネームスペースを分けることです。モジュールは一つのファイルです。
&lt;/p&gt;

&lt;p&gt;
異なるパッケージやモジュールから同名のファイルを import する場合、 &lt;code&gt;as&lt;/code&gt; で区別しないと後のimportで上書きされてしまいます。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; xxxx.xxxx &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; inspect &lt;span style="font-weight: bold;"&gt;as&lt;/span&gt; xxxx_inspect
&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; yyyy.yyyy &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; inspect &lt;span style="font-weight: bold;"&gt;as&lt;/span&gt; yyyy_inspect
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
公開するAPIを限定したい場合に &lt;code&gt;__all__&lt;/code&gt; のスペシャルアトリビュートが使えます。 &lt;code&gt;__all__&lt;/code&gt; の値がパブリックAPIとして公開する名前のリストになっています。かなりの規模にならない限り &lt;code&gt;__all__&lt;/code&gt; は不要です。
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;__init__.py&lt;/code&gt; で &lt;code&gt;__all__&lt;/code&gt; をaggregateする例:
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;__all__&lt;/span&gt; = []
&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; . models &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; *
&lt;span style="font-weight: bold;"&gt;__all__&lt;/span&gt; += models.&lt;span style="font-weight: bold;"&gt;__all__&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; . utils &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; *
&lt;span style="font-weight: bold;"&gt;__all__&lt;/span&gt; += utils.&lt;span style="font-weight: bold;"&gt;__all__&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org8549b09" class="outline-3"&gt;
&lt;h3 id="org8549b09"&gt;&lt;span class="section-number-3"&gt;2.5&lt;/span&gt; Item 86: デプロイ環境をconfigureするためにモジュールスコープのコードを検討せよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-5"&gt;
&lt;p&gt;
複数の種類のデプロイ環境が考えられます。OSの種類、開発環境、テスト環境、等。これらはモジュールスコープの普通のPythonステートメントにて区別します。例えば os.environ 環境変数を見るなど。複雑になってきたら、設定ファイルで区別するようにします。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgbd2c13c" class="outline-3"&gt;
&lt;h3 id="orgbd2c13c"&gt;&lt;span class="section-number-3"&gt;2.6&lt;/span&gt; Item 87: APIから呼び主をinsulateするためにルート例外を定義せよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-6"&gt;
&lt;p&gt;
モジュールにおいてルート例外を定義するメリットは2つあります。
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;APIの呼び側のエラーハンドリングミスがわかる&lt;/li&gt;
&lt;li&gt;API提供側の検討漏れがわかる&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
API側でルート例外を定義した例:
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;RootError&lt;/span&gt;(&lt;span style="font-weight: bold; text-decoration: underline;"&gt;Exception&lt;/span&gt;):
    &lt;span style="font-weight: bold;"&gt;pass&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;InvalidValueError&lt;/span&gt;(RootError):
    &lt;span style="font-weight: bold;"&gt;pass&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;InvalidLengthError&lt;/span&gt;(RootError):
    &lt;span style="font-weight: bold;"&gt;pass&lt;/span&gt;

&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;some_func&lt;/span&gt;(name, value):
    &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;len&lt;/span&gt;(name) &amp;gt;= 10:
        &lt;span style="font-weight: bold;"&gt;raise&lt;/span&gt; InvalidLengthError(&lt;span style="font-style: italic;"&gt;'name length must be 9 or less'&lt;/span&gt;)
    &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; value &amp;lt; 0:
        &lt;span style="font-weight: bold;"&gt;raise&lt;/span&gt; InvalidValueError(&lt;span style="font-style: italic;"&gt;'value must be 0 or higher'&lt;/span&gt;)
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; name + &lt;span style="font-weight: bold;"&gt;str&lt;/span&gt;(value)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
上記において、API利用側が &lt;code&gt;InvalidValueError&lt;/code&gt; のハンドリングしかしていない時に &lt;code&gt;InvalidLengthError&lt;/code&gt; 例外が上がると、利用側のエラーハンドリングミスであることがわかります。
&lt;/p&gt;

&lt;p&gt;
もしPython標準の &lt;code&gt;Exception&lt;/code&gt; が上がったときには、API提供側のコードに検討漏れがあったことがわかります。
&lt;/p&gt;

&lt;p&gt;
更に、中間の例外を定義すると例外のカテゴリー分けが可能です。実際に上げるエラーは中間例外を継承した具体的な例外です。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;RootError&lt;/span&gt;(&lt;span style="font-weight: bold; text-decoration: underline;"&gt;Exception&lt;/span&gt;):  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12523;&amp;#12540;&amp;#12488;&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;pass&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;ValueError&lt;/span&gt;(RootError):  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#20013;&amp;#38291;&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;pass&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;NameError&lt;/span&gt;(RootError):  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#20013;&amp;#38291;&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;pass&lt;/span&gt;
...
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgec0fa56" class="outline-3"&gt;
&lt;h3 id="orgec0fa56"&gt;&lt;span class="section-number-3"&gt;2.7&lt;/span&gt; Item 88: 循環依存を断ち切る方法を知れ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-7"&gt;
&lt;p&gt;
循環依存(import)になったら、相互依存部分を別のモジュールに切り出して依存ツリーのbottomに置くようにリファクタリングすることが望ましいです。
&lt;/p&gt;

&lt;p&gt;
そこまでやらずに済む手っ取り早い方法としては、関数等の中に問題のimportを持ってくるダイナミックインポートをすることが考えられます。実行速度が低下する、エラーが出るタイミングが遅くなるなどの副作用があります。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org4bc48ca" class="outline-3"&gt;
&lt;h3 id="org4bc48ca"&gt;&lt;span class="section-number-3"&gt;2.8&lt;/span&gt; Item 89: リファクタリングと利用の移行促進のために warningを検討せよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-8"&gt;
&lt;p&gt;
APIのI/Fに変更を入れた場合、warningを使って利用者に移行の促進をすることができます。 &lt;code&gt;warnings.warn()&lt;/code&gt; の &lt;code&gt;stacklevel&lt;/code&gt; 引数により、どのレベルの呼び主にwarningを出力するかを指定できます。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; warnings
&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;require&lt;/span&gt;(name, value, default):
    &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; value &lt;span style="font-weight: bold;"&gt;is&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;not&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;None&lt;/span&gt;:
        &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; value
    warnings.warn(
        f&lt;span style="font-style: italic;"&gt;'{name} will be required soon, update your code'&lt;/span&gt;,
        &lt;span style="font-weight: bold; text-decoration: underline;"&gt;DeprecationWarning&lt;/span&gt;,
        stacklevel=3)
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; default

&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;print_distance&lt;/span&gt;(speed, duration, *,
                   speed_units=&lt;span style="font-weight: bold; text-decoration: underline;"&gt;None&lt;/span&gt;,
                   time_units=&lt;span style="font-weight: bold; text-decoration: underline;"&gt;None&lt;/span&gt;,
                   distance_units=&lt;span style="font-weight: bold; text-decoration: underline;"&gt;None&lt;/span&gt;):
    &lt;span style="font-weight: bold; font-style: italic;"&gt;speed_units&lt;/span&gt; = require(&lt;span style="font-style: italic;"&gt;'speed_units'&lt;/span&gt;, speed_units, &lt;span style="font-style: italic;"&gt;'mph'&lt;/span&gt;)
    &lt;span style="font-weight: bold; font-style: italic;"&gt;time_units&lt;/span&gt; = require(&lt;span style="font-style: italic;"&gt;'time_units'&lt;/span&gt;, time_units, &lt;span style="font-style: italic;"&gt;'hours'&lt;/span&gt;)
    &lt;span style="font-weight: bold; font-style: italic;"&gt;distance_units&lt;/span&gt; = require(&lt;span style="font-style: italic;"&gt;'distance_units'&lt;/span&gt;, distance_units, &lt;span style="font-style: italic;"&gt;'miles'&lt;/span&gt;)

    &lt;span style="font-weight: bold; font-style: italic;"&gt;norm_speed&lt;/span&gt; = convert(speed, speed_units)
    &lt;span style="font-weight: bold; font-style: italic;"&gt;norm_duration&lt;/span&gt; = convert(duration, time_units)
    &lt;span style="font-weight: bold; font-style: italic;"&gt;norm_distance&lt;/span&gt; = norm_speed * norm_duration
    &lt;span style="font-weight: bold; font-style: italic;"&gt;distance&lt;/span&gt; = localize(norm_distance, distance_units)
    &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(f&lt;span style="font-style: italic;"&gt;'{distance} {distance_units}'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
実行すると以下のようになりました。エラーと違って、コードの挙動には影響しません。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; contextlib
&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; io
&lt;span style="font-weight: bold; font-style: italic;"&gt;fake_stderr&lt;/span&gt; = io.StringIO()
&lt;span style="font-weight: bold;"&gt;with&lt;/span&gt; contextlib.redirect_stderr(fake_stderr):
    print_distance(1000, 3,
                   speed_units=&lt;span style="font-style: italic;"&gt;'meters'&lt;/span&gt;,
                   time_units=&lt;span style="font-style: italic;"&gt;'seconds'&lt;/span&gt;)
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(fake_stderr.getvalue())
&amp;gt;&amp;gt;&amp;gt;
1.8641182099494205 miles
t.py:46: &lt;span style="font-weight: bold; text-decoration: underline;"&gt;DeprecationWarning&lt;/span&gt;: distance_units will be required soon, update your code
  print_distance(1000, 3,
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
warningはエラーにすることもできます。 &lt;code&gt;-W error&lt;/code&gt; を指定します。指定した場合には、実行が途中で終わって最後のdoneメッセージが表示されないことがわかります。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; warnings
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'begin'&lt;/span&gt;)
warnings.warn(&lt;span style="font-style: italic;"&gt;'This usage is deprecated'&lt;/span&gt;,
              &lt;span style="font-weight: bold; text-decoration: underline;"&gt;DeprecationWarning&lt;/span&gt;)
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'done'&lt;/span&gt;)
&amp;gt;&amp;gt;&amp;gt;
(blg) ~/Documents/AW/py/blg % python t.py  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#26222;&amp;#36890;&amp;#12395;&amp;#36215;&amp;#21205;&lt;/span&gt;
begin
t.py:3: &lt;span style="font-weight: bold; text-decoration: underline;"&gt;DeprecationWarning&lt;/span&gt;: This usage &lt;span style="font-weight: bold;"&gt;is&lt;/span&gt; deprecated
  warnings.warn(&lt;span style="font-style: italic;"&gt;'This usage is deprecated'&lt;/span&gt;,
done
(blg) ~/Documents/AW/py/blg % python -W error t.py  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12456;&amp;#12521;&amp;#12540;&amp;#12434;&amp;#25351;&amp;#23450;&lt;/span&gt;
begin
Traceback (most recent call last):
  File &lt;span style="font-style: italic;"&gt;"t.py"&lt;/span&gt;, line 3, &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;
    warnings.warn(&lt;span style="font-style: italic;"&gt;'This usage is deprecated'&lt;/span&gt;,
&lt;span style="font-weight: bold; text-decoration: underline;"&gt;DeprecationWarning&lt;/span&gt;: This usage &lt;span style="font-weight: bold;"&gt;is&lt;/span&gt; deprecated
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
warningを抑止することもできます。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;warnings.simplefilter(&lt;span style="font-style: italic;"&gt;'ignore'&lt;/span&gt;)
warnings.warn(&lt;span style="font-style: italic;"&gt;'How about this?'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
よりよいアプローチは、ログにリダイレクトすることです。logging.captureWarningsを呼んで、対応するpy.warningsロガーを設定します。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; io
&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; logging
&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; warnings
&lt;span style="font-weight: bold; font-style: italic;"&gt;fake_stderr&lt;/span&gt; = io.StringIO()
&lt;span style="font-weight: bold; font-style: italic;"&gt;handler&lt;/span&gt; = logging.StreamHandler(fake_stderr)
&lt;span style="font-weight: bold; font-style: italic;"&gt;formatter&lt;/span&gt; = logging.Formatter(
    &lt;span style="font-style: italic;"&gt;'%(asctime)-15s WARNING] %(message)s'&lt;/span&gt;)
handler.setFormatter(formatter)

logging.captureWarnings(&lt;span style="font-weight: bold; text-decoration: underline;"&gt;True&lt;/span&gt;)
&lt;span style="font-weight: bold; font-style: italic;"&gt;logger&lt;/span&gt; = logging.getLogger(&lt;span style="font-style: italic;"&gt;'py.warnings'&lt;/span&gt;)
logger.addHandler(handler)
logger.setLevel(logging.DEBUG)

warnings.resetwarnings()
warnings.simplefilter(&lt;span style="font-style: italic;"&gt;'default'&lt;/span&gt;)
warnings.warn(&lt;span style="font-style: italic;"&gt;'This will go to the logs output'&lt;/span&gt;)

&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(fake_stderr.getvalue())
&amp;gt;&amp;gt;&amp;gt;
2020-09-01 08:00:24,490 WARNING] t.py:17: &lt;span style="font-weight: bold; text-decoration: underline;"&gt;UserWarning&lt;/span&gt;: This will go to the logs output
  warnings.warn(&lt;span style="font-style: italic;"&gt;'This will go to the logs output'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
あれ、どこのファイルに出力されているのでしょう??? /var/log/system.logには無さそうですが。。。(macOSです)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgbb599ec" class="outline-3"&gt;
&lt;h3 id="orgbb599ec"&gt;&lt;span class="section-number-3"&gt;2.9&lt;/span&gt; Item 90: バグを取り除くためにtypingを使った静的解析を検討せよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-9"&gt;
&lt;p&gt;
type annotationsはコードの実行にはほとんど関係しませんが、静的解析でタイプエラーを見つけるのに役に立ちます。これまで何度か出てきていますが、こういうやつです:
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;subtract&lt;/span&gt;(a: &lt;span style="font-weight: bold;"&gt;int&lt;/span&gt;, b: &lt;span style="font-weight: bold;"&gt;int&lt;/span&gt;) -&amp;gt; &lt;span style="font-weight: bold;"&gt;int&lt;/span&gt;:
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; a - b
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
mypyのようなツールで実行前の静的解析が可能です。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;python -m mypy --strict t.py
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
type annotationsには性能的な副作用もあるので、全てに付ける必要はありません。公開しているAPIや最も重要な部分だけに絞った方が良さそうです。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org64cd370" class="outline-2"&gt;
&lt;h2 id="org64cd370"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; 終わりに&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
Effective Pythonはなかなか難しい本でしたが、なんとか読み終えることができました。Effective Javaで挫折した経験があるので、少しほっとしています。2冊を比べると、もしかしてEffective Javaの方が難しいのでしょうか。
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0c38e71" class="outline-3"&gt;
&lt;h3 id="org0c38e71"&gt;&lt;span class="section-number-3"&gt;3.1&lt;/span&gt; 感想&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-3-1"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org75234b7" class="outline-4"&gt;
&lt;h4 id="org75234b7"&gt;&lt;span class="section-number-4"&gt;3.1.1&lt;/span&gt; 内容全般&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-3-1-1"&gt;
&lt;p&gt;
評判に違わず良書でした。位置づけとしては初中級くらいの人をターゲットにしていると思われますが、それにしては要求される前提知識のレベルが高めだと感じました。本書は、これをしろ、これをするな、という書き方が多いのですが、その理由を実際のコード例で示してくれるため、納得のいく内容になっています。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgaeb0030" class="outline-4"&gt;
&lt;h4 id="orgaeb0030"&gt;&lt;span class="section-number-4"&gt;3.1.2&lt;/span&gt; この本の読み方&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-3-1-2"&gt;
&lt;p&gt;
この本はわからないところが出てきたときに、自分でどれらけ調べられるかで、読み進められるかどうかが決まってくると思います。その際に&lt;a href="https://realpython.com/"&gt;Real Pythonのサイト&lt;/a&gt;にはとてもお世話になりました。フレンドリーな見かけによらず意外と中上級向けの解説記事があって助かりました。
&lt;/p&gt;

&lt;p&gt;
この本のコードは半分くらい写経して、実際に動かしてみました。実際に動かしてみると(主にTYPOですが)エラーがたくさん出ます。これらのエラーを直すのに改めてコードを読み直したりして、結構勉強になりました。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org9f270ed" class="outline-4"&gt;
&lt;h4 id="org9f270ed"&gt;&lt;span class="section-number-4"&gt;3.1.3&lt;/span&gt; 第2版について&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-3-1-3"&gt;
&lt;p&gt;
第2版を読んだのは正解でした。この版ではPython 3.8までの機能を普通に使っています。asyncio周りは動きが速く、最新の情報を元にしないとすぐに陳腐化してしまいますし、特にWalrus operator(&lt;code&gt;:=&lt;/code&gt;)はエレガントなコードを書くために必須と思いました。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org952b159" class="outline-4"&gt;
&lt;h4 id="org952b159"&gt;&lt;span class="section-number-4"&gt;3.1.4&lt;/span&gt; 前後参照の多さ&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-3-1-4"&gt;
&lt;p&gt;
この本は前後の項目への参照が非常に多く、最初は読みづらかったのですが、後半になってくると以前に読んだ内容が多くなり、逆に読みやすくなりました。ただ、後で説明する内容を前の項目で使うことが多く、この構成はどうにならないものかと感じます。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orge6b5884" class="outline-4"&gt;
&lt;h4 id="orge6b5884"&gt;&lt;span class="section-number-4"&gt;3.1.5&lt;/span&gt; Kindle版&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-3-1-5"&gt;
&lt;p&gt;
何度も書きましたが、Kindle版はコードのインデントが崩れており、非常に読みづらいです。そのためにビットマップイメージへのリンクがある筈ですが、ビットマップでもインデントがずれている箇所がたくさんあり、辟易しました。Kindle版の技術書は2度と買いません。
&lt;/p&gt;

&lt;p&gt;
また、ビットマップのリンクを見たり、前に出てきたコードを見返したりを多様するためか、Kindleデバイスの電池の減りがとても速かったです。
&lt;/p&gt;

&lt;p&gt;
繰り返しますが、Kindle版は勧めません。紙かPDF版にしておけばよかったです。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org44552a2" class="outline-3"&gt;
&lt;h3 id="org44552a2"&gt;&lt;span class="section-number-3"&gt;3.2&lt;/span&gt; その次&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-3-2"&gt;
&lt;p&gt;
fluent pythonに行くか、python cookbookに行くかでまだ悩んでいます。。。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Python"></category><category term="Python"></category></entry><entry><title>Effective Python一人輪読会(Item 52 to 74)</title><link href="http://achiwa912.github.io/effective4.html" rel="alternate"></link><published>2020-08-26T00:00:00-04:00</published><updated>2020-10-24T00:00:00-04:00</updated><author><name>きょうす</name></author><id>tag:achiwa912.github.io,2020-08-26:/effective4.html</id><summary type="html">Effective Python読書メモ4</summary><content type="html">&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org5c176e7"&gt;1. Chapter 7: コンカレンシーと並列実行&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org2a7ae69"&gt;1.1. Item 52: 子プロセスを管理するために subprosess を使え&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org7515de3"&gt;1.2. Item 53: ブロックするI/Oにはスレッドを使い、parallelismを避けよ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org8da98bf"&gt;1.3. Item 54: スレッド間のデータレースを避けるために Lock を使え&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgaff0985"&gt;1.4. Item 55: スレッド間のワークアサインの調整には Queue を使え&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org88c44bc"&gt;1.5. Item 56: いつコンカレンシーが必要になるかをどう理解するか知れ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgdda86ff"&gt;1.6. Item 57: オンデマンドのfan-outで新たなスレッドインスタンスを作るのは避けろ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org87497b8"&gt;1.7. Item 58: コンカレンシーのためにQueueを使うにはリファクタリングが必要なことを理解せよ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org01a1220"&gt;1.8. Item 59: コンカレンシーでスレッドが必要なら ThreadPoolExecutorを検討せよ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org8af14bd"&gt;1.9. Item 60: コルーチン(Coroutines)を使って高コンカレントI/Oを実現せよ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org6f6475b"&gt;1.10. Item 61: スレッド化されたI/Oをasyncioにポートする方法を知れ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgfdcbadf"&gt;1.11. Item 62: asyncioへの移行を楽にするため、スレッドとコルーチンを混在させよ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgd578482"&gt;1.12. Item 63: レスポンスを最大化するためにはasyncioのイベントループをブロックするな&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orga5e4754"&gt;1.13. Item 64: 真の並行動作にはconcurrent.futuresを検討せよ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#org0930f1f"&gt;2. Chapter 8: 堅牢性(robustness)と性能&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org96215c0"&gt;2.1. Item 65: try/except/else/finallyで各ブロックを有効に使え&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgbf0282d"&gt;2.2. Item 66: try/finally挙動を再利用するためにcontextlibとwithステートメントを考えよ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orga555eae"&gt;2.3. Item 67: ローカル時間にはtimeの代わりにdatetimeを使え&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org320bcd5"&gt;2.4. Item 68: copyregでpickleをreliableにせよ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org94b3ed9"&gt;2.5. Item 69: 精度が重要なら decimal を使え&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org63ba8cb"&gt;2.6. Item 70: 最適化の前にプロファイルせよ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgbc7ce26"&gt;2.7. Item 71: 生産者-消費者キューにはdequeを使え&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org80d9ffb"&gt;2.8. Item 72: ソートされたシーケンス内をサーチするにはbisectを使え&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgb70e1cb"&gt;2.9. Item 73: 優先度キューのために heapq をどう使うかを知れ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgebbaeda"&gt;2.10. Item 74: bytesとゼロコピーでinteractするにはmemoryviewとbytearrayを使え&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5c176e7" class="outline-2"&gt;
&lt;h2 id="org5c176e7"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Chapter 7: コンカレンシーと並列実行&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org2a7ae69" class="outline-3"&gt;
&lt;h3 id="org2a7ae69"&gt;&lt;span class="section-number-3"&gt;1.1&lt;/span&gt; Item 52: 子プロセスを管理するために subprosess を使え&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-1"&gt;
&lt;p&gt;
Pythonから子プロセスを呼び出すシンプルな方法。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; subprocess

&lt;span style="font-weight: bold; font-style: italic;"&gt;result&lt;/span&gt; = subprocess.run(
    [&lt;span style="font-style: italic;"&gt;'echo'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'Hello from the child!'&lt;/span&gt;],
    capture_output=&lt;span style="font-weight: bold; text-decoration: underline;"&gt;True&lt;/span&gt;,  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;stdout/stderr&amp;#12434;&amp;#12461;&amp;#12515;&amp;#12503;&amp;#12481;&amp;#12515;&amp;#12540;&amp;#12377;&amp;#12427;&lt;/span&gt;
    encoding=&lt;span style="font-style: italic;"&gt;'utf-8'&lt;/span&gt;)

result.check_returncode()
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(result.stdout)
&amp;gt;&amp;gt;&amp;gt;
Hello &lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; the child!
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
Python 3.5で導入された &lt;code&gt;subprocess.run&lt;/code&gt; は子プロセスの実行完了を待ちます。&lt;a href="https://docs.python.org/3/library/subprocess.html"&gt;公式サイト&lt;/a&gt;によると、基本的にはこれを使うのが推奨だそうです。
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
subprocess.run(args, *, stdin=None, input=None, stdout=None, stderr=None, capture_output=False, shell=False, cwd=None, timeout=None, check=False, encoding=None, errors=None, text=None, env=None, universal_newlines=None, **other_popen_kwargs)
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
タイムアウトも指定できそうです。
&lt;/p&gt;

&lt;p&gt;
次は、 &lt;code&gt;subprocess.Popen&lt;/code&gt; を使ってブロックされずに子プロセスを10個起動したあと、 &lt;code&gt;&amp;lt;process&amp;gt;.communicate&lt;/code&gt; で実行完了した各子プロセスを終了(terminate)させる処理です。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; subprocess
&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; time

&lt;span style="font-weight: bold; font-style: italic;"&gt;start&lt;/span&gt; = time.time()
&lt;span style="font-weight: bold; font-style: italic;"&gt;sleep_procs&lt;/span&gt; = []
&lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; _ &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;range&lt;/span&gt;(10):
    &lt;span style="font-weight: bold; font-style: italic;"&gt;proc&lt;/span&gt; = subprocess.Popen([&lt;span style="font-style: italic;"&gt;'sleep'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'1'&lt;/span&gt;])
    sleep_procs.append(proc)

time.sleep(0.3)

&lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; proc &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; sleep_procs:
    proc.communicate()

&lt;span style="font-weight: bold; font-style: italic;"&gt;end&lt;/span&gt; = time.time()
&lt;span style="font-weight: bold; font-style: italic;"&gt;delta&lt;/span&gt; = end - start
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(f&lt;span style="font-style: italic;"&gt;'Finished in {delta:.3} seconds'&lt;/span&gt;)
&amp;gt;&amp;gt;&amp;gt;
Finished &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; 1.02 seconds
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
並列に実行するため10秒かからず、1秒強で終わっています。
&lt;/p&gt;

&lt;p&gt;
次の例は、外部コマンドの openssl にランダムな10バイトのバイト列を暗号化させる処理です。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; subprocess
&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; os
&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;run_encrypt&lt;/span&gt;(data):
    &lt;span style="font-weight: bold; font-style: italic;"&gt;env&lt;/span&gt; = os.environ.copy()
    &lt;span style="font-weight: bold; font-style: italic;"&gt;env&lt;/span&gt;[&lt;span style="font-style: italic;"&gt;'password'&lt;/span&gt;] = &lt;span style="font-style: italic;"&gt;'start123'&lt;/span&gt;
    &lt;span style="font-weight: bold; font-style: italic;"&gt;proc&lt;/span&gt; = subprocess.Popen(
        [&lt;span style="font-style: italic;"&gt;'openssl'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'enc'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'-des3'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'-pass'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'env:password'&lt;/span&gt;],
        env=env,
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE)
    proc.stdin.write(data)
    proc.stdin.flush()
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; proc

&lt;span style="font-weight: bold; font-style: italic;"&gt;procs&lt;/span&gt; = []
&lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; _ &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;range&lt;/span&gt;(3):
    &lt;span style="font-weight: bold; font-style: italic;"&gt;data&lt;/span&gt; = os.urandom(10)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12521;&amp;#12531;&amp;#12480;&amp;#12512;&amp;#12394;10&amp;#12496;&amp;#12452;&amp;#12488;&amp;#12434;&amp;#29983;&amp;#25104;&lt;/span&gt;
    &lt;span style="font-weight: bold; font-style: italic;"&gt;proc&lt;/span&gt; = run_encrypt(data)
    procs.append(proc)

&lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; proc &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; procs:
    &lt;span style="font-weight: bold; font-style: italic;"&gt;out&lt;/span&gt;, &lt;span style="font-weight: bold; font-style: italic;"&gt;_&lt;/span&gt; = proc.communicate()
    &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(out[-10:])  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#24460;&amp;#12429;&amp;#12363;&amp;#12425;10&amp;#12496;&amp;#12452;&amp;#12488;&amp;#12434;&amp;#12473;&amp;#12521;&amp;#12452;&amp;#12473;&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt;
b&lt;span style="font-style: italic;"&gt;'\x0f\xbc4\x94O\x93\xa5G\xbe\xe3'&lt;/span&gt;
b&lt;span style="font-style: italic;"&gt;'m\xb3\x89\r\xc9pP7\xdc\xeb'&lt;/span&gt;
b&lt;span style="font-style: italic;"&gt;"\xda\x16z N=\x850v'"&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
結果は、ランダムなバイト列を暗号化したバイト列なので、意味は特にありません。
&lt;/p&gt;

&lt;p&gt;
複数の外部コマンドを呼び出し、それらをパイプでつなぐこともできます。次の例で、 &lt;code&gt;run_hash&lt;/code&gt; は &lt;code&gt;openssl&lt;/code&gt; を使って入力バイト列のハッシュを求める関数です。 &lt;code&gt;for&lt;/code&gt; 文以下では、100バイトのランダムな文字列を生成し、それからハッシュを求めることを3つのサブプロセスで並列実行します。 &lt;code&gt;run_hash&lt;/code&gt; 関数呼び出しの引数に &lt;code&gt;encrypt_proc.stdout&lt;/code&gt; を指定することで、これらの処理をパイプでつなげています。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;run_hash&lt;/span&gt;(input_stdin):
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; subprocess.Popen(
        [&lt;span style="font-style: italic;"&gt;'openssl'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'dgst'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'-whirlpool'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'-binary'&lt;/span&gt;],
        stdin=input_stdin,  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;stdin&amp;#12434;&amp;#25351;&amp;#23450;&lt;/span&gt;
        stdout=subprocess.PIPE)

&lt;span style="font-weight: bold; font-style: italic;"&gt;encrypt_procs&lt;/span&gt; = []
&lt;span style="font-weight: bold; font-style: italic;"&gt;hash_procs&lt;/span&gt; = []
&lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; _ &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;range&lt;/span&gt;(3):
    &lt;span style="font-weight: bold; font-style: italic;"&gt;data&lt;/span&gt; = os.urandom(100)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12521;&amp;#12531;&amp;#12480;&amp;#12512;&amp;#12394;100&amp;#12496;&amp;#12452;&amp;#12488;&amp;#12434;&amp;#29983;&amp;#25104;&lt;/span&gt;

    &lt;span style="font-weight: bold; font-style: italic;"&gt;encrypt_proc&lt;/span&gt; = run_encrypt(data)
    encrypt_procs.append(encrypt_proc)
    &lt;span style="font-weight: bold; font-style: italic;"&gt;hash_proc&lt;/span&gt; = run_hash(encrypt_proc.stdout)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;stdout&amp;#12434;&amp;#25351;&amp;#23450;&lt;/span&gt;
    hash_procs.append(hash_proc)

    encrypt_proc.stdout.close()  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#38281;&amp;#12376;&amp;#12390;&amp;#12375;&amp;#12414;&amp;#12387;&amp;#12390;&amp;#12424;&amp;#12356;???&lt;/span&gt;
    &lt;span style="font-weight: bold; font-style: italic;"&gt;encrypt_proc.stdout&lt;/span&gt; = &lt;span style="font-weight: bold; text-decoration: underline;"&gt;None&lt;/span&gt;

&lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; proc &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; encrypt_procs:
    proc.communicate()
    &lt;span style="font-weight: bold;"&gt;assert&lt;/span&gt; proc.returncode == 0

&lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; proc &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; hash_procs:
    &lt;span style="font-weight: bold; font-style: italic;"&gt;out&lt;/span&gt;, &lt;span style="font-weight: bold; font-style: italic;"&gt;_&lt;/span&gt; = proc.communicate()
    &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(out[-10:])
    &lt;span style="font-weight: bold;"&gt;assert&lt;/span&gt; proc.returncode == 0
&amp;gt;&amp;gt;&amp;gt;
&lt;span style="font-style: italic;"&gt;'\x99\xd8*\x15~\x88\xd4\x89\x1c3'&lt;/span&gt;
b&lt;span style="font-style: italic;"&gt;'\x00\x87\xd3\x93Ti\x12v\x01\xaa'&lt;/span&gt;
b&lt;span style="font-style: italic;"&gt;'\x1b\x85\xdf\x94z\x96\xd3\xb0\x91\x9a'&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
結果の文字列に特に意味はありません。
&lt;/p&gt;

&lt;p&gt;
子プロセスが終わらない場合が気になるなら、タイムアウト値を指定することも出来ます。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; subprocess
&lt;span style="font-weight: bold; font-style: italic;"&gt;proc&lt;/span&gt; = subprocess.Popen([&lt;span style="font-style: italic;"&gt;'sleep'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'10'&lt;/span&gt;])
&lt;span style="font-weight: bold;"&gt;try&lt;/span&gt;:
    proc.communicate(timeout=0.1)
&lt;span style="font-weight: bold;"&gt;except&lt;/span&gt; subprocess.TimeoutExpired:
    proc.terminate()
    proc.wait()

&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'Exist status'&lt;/span&gt;, proc.poll())
&amp;gt;&amp;gt;&amp;gt;
Exist status -15
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
タイムアウト例外が発生したら子プロセスを終わらせます。 &lt;code&gt;proc.poll()&lt;/code&gt; でexit codeが得られるようです。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7515de3" class="outline-3"&gt;
&lt;h3 id="org7515de3"&gt;&lt;span class="section-number-3"&gt;1.2&lt;/span&gt; Item 53: ブロックするI/Oにはスレッドを使い、parallelismを避けよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-2"&gt;
&lt;p&gt;
普通使うPythonはCPythonですが、CPythonはglobal interpreter lock (GIL)のために複数コアでの並列実行ができません。知りませんでした。衝撃的な事実。。。I/Oによる待ちが無ければ複数スレッド使っても実行時間は短縮されません。
&lt;/p&gt;

&lt;p&gt;
更に、ネットワーク等の非同期I/Oでは、より効率の良いasyncio(後で出てきます)を使うことになるため、Pythonでのスレッドの出番はブロックする(ie, 非同期システムコールが無い)ディスクI/Oくらいしか無さそうです。。。というのは言い過ぎでした。キュー等でも使えますね。
&lt;/p&gt;

&lt;p&gt;
Pythonでのスレッドの使い方例:
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; select
&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; socket
&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; time
&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; threading &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; Thread
&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;slow_systemcall&lt;/span&gt;():
    select.select([socket.socket()],[],[],0.1)

&lt;span style="font-weight: bold; font-style: italic;"&gt;start&lt;/span&gt; = time.time()
&lt;span style="font-weight: bold; font-style: italic;"&gt;threads&lt;/span&gt; = []
&lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; _ &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;range&lt;/span&gt;(5):
    &lt;span style="font-weight: bold; font-style: italic;"&gt;thread&lt;/span&gt; = Thread(target=slow_systemcall)
    thread.start()
    threads.append(thread)

&lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; thread &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; threads:
    thread.join()

&lt;span style="font-weight: bold; font-style: italic;"&gt;end&lt;/span&gt; = time.time()
&lt;span style="font-weight: bold; font-style: italic;"&gt;delta&lt;/span&gt; = end - start
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(f&lt;span style="font-style: italic;"&gt;'Took {delta:.3f} seconds'&lt;/span&gt;)
&amp;gt;&amp;gt;&amp;gt;
Took 0.103 seconds
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org8da98bf" class="outline-3"&gt;
&lt;h3 id="org8da98bf"&gt;&lt;span class="section-number-3"&gt;1.3&lt;/span&gt; Item 54: スレッド間のデータレースを避けるために Lock を使え&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-3"&gt;
&lt;p&gt;
単一コアで動くマルチスレッドにもロックは必要という話。
Pythonでmutexを用意する例:
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; threading &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; Lock
&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;LockingCounter&lt;/span&gt;:
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__init__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.lock = Lock()
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.count = 0  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12525;&amp;#12483;&amp;#12463;&amp;#23550;&amp;#35937;&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;increment&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, offset):
        &lt;span style="font-weight: bold;"&gt;with&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.lock:
            &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.count += offset
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;code&gt;Lock&lt;/code&gt; クラスを使うと &lt;code&gt;with&lt;/code&gt; でクリティカルリージョン(ie, ロック範囲)の指定ができるのが便利ですね。
&lt;/p&gt;

&lt;p&gt;
おさらいです。mutexとbinary semaphoreは一見とても似ていますが、用途が違います。
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;mutexは資源の排他(ロック)のため&lt;/li&gt;
&lt;li&gt;binary semaphoreはイベントが起きたことを通知(シグナル)するため&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
スピンロックと違って、両方とも待ちスレッドはスリープします。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgaff0985" class="outline-3"&gt;
&lt;h3 id="orgaff0985"&gt;&lt;span class="section-number-3"&gt;1.4&lt;/span&gt; Item 55: スレッド間のワークアサインの調整には Queue を使え&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-4"&gt;
&lt;p&gt;
&lt;code&gt;Queue&lt;/code&gt; クラスはパイプラインを実装するのに便利です。 &lt;code&gt;Queue&lt;/code&gt; の getメソッドは新データが来るまでブロックするため、自前でbusyウエイトを実装する必要がありません。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; threading &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; Thread
&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; queue &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; Queue

&lt;span style="font-weight: bold; font-style: italic;"&gt;my_queue&lt;/span&gt; = Queue()  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12461;&amp;#12517;&amp;#12540;&amp;#12398;&amp;#12463;&amp;#12521;&amp;#12473;&amp;#12364;&amp;#29992;&amp;#24847;&amp;#12373;&amp;#12428;&amp;#12390;&amp;#12356;&amp;#12414;&amp;#12377;&lt;/span&gt;

&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;consumer&lt;/span&gt;():
    &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'Consumer waiting'&lt;/span&gt;)
    my_queue.get()  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12502;&amp;#12525;&amp;#12483;&amp;#12463;&amp;#12373;&amp;#12428;&amp;#12414;&amp;#12377;&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'Consumer done'&lt;/span&gt;)

&lt;span style="font-weight: bold; font-style: italic;"&gt;thread&lt;/span&gt; = Thread(target=consumer)
thread.start()

&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'Producer putting'&lt;/span&gt;)
my_queue.put(&lt;span style="font-weight: bold;"&gt;object&lt;/span&gt;())
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'Producer done'&lt;/span&gt;)
thread.join()
&amp;gt;&amp;gt;&amp;gt;
Consumer waiting  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12450;&amp;#12452;&amp;#12486;&amp;#12512;(object)&amp;#12364;&amp;#20837;&amp;#12387;&amp;#12390;&amp;#12367;&amp;#12427;&amp;#12414;&amp;#12391;&amp;#24453;&amp;#12385;&amp;#12414;&amp;#12377;&lt;/span&gt;
Producer putting
Producer done
Consumer done
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
最初に consumer がキューに来た後、producerが &lt;code&gt;put&lt;/code&gt; するまで consumer は動き出さないことがわかります。。
&lt;/p&gt;

&lt;p&gt;
キューを作るときにキューバッファのサイズを指定することもできます。いくつのconsumerがキューに入れるかを示し、それ以上のconsumerが来ても &lt;code&gt;put&lt;/code&gt; でブロックします。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; threading &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; Thread
&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; queue &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; Queue
&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; time

&lt;span style="font-weight: bold; font-style: italic;"&gt;my_queue&lt;/span&gt; = Queue(1)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12496;&amp;#12483;&amp;#12501;&amp;#12449;&amp;#12469;&amp;#12452;&amp;#12474;&amp;#12364;1&lt;/span&gt;

&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;consumer&lt;/span&gt;():
    time.sleep(0.1)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12414;&amp;#12378;0.1&amp;#31186;&amp;#12473;&amp;#12522;&amp;#12540;&amp;#12503;&amp;#12377;&amp;#12427;&lt;/span&gt;
    my_queue.get()
    &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'Consumer got 1'&lt;/span&gt;)
    my_queue.get()
    &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'Consumer got 2'&lt;/span&gt;)
    &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'Consumer done'&lt;/span&gt;)

&lt;span style="font-weight: bold; font-style: italic;"&gt;thread&lt;/span&gt; = Thread(target=consumer)
thread.start()

my_queue.put(&lt;span style="font-weight: bold;"&gt;object&lt;/span&gt;())  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;producer&amp;#12399;&amp;#31435;&amp;#12390;&amp;#32154;&amp;#12369;&amp;#12395;&amp;#20108;&amp;#12388;put&amp;#12375;&amp;#12424;&amp;#12358;&amp;#12392;&amp;#12377;&amp;#12427;&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'Producer put 1'&lt;/span&gt;)
my_queue.put(&lt;span style="font-weight: bold;"&gt;object&lt;/span&gt;())  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12371;&amp;#12371;&amp;#12391;&amp;#12502;&amp;#12525;&amp;#12483;&amp;#12463;&amp;#12377;&amp;#12427;&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'Producer put 2'&lt;/span&gt;)
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'Producer done'&lt;/span&gt;)
thread.join()
&amp;gt;&amp;gt;&amp;gt;
Producer put 1  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#26368;&amp;#21021;&amp;#12395;producer&amp;#12364;put&amp;#12377;&amp;#12427;&amp;#12398;&amp;#12399;&amp;#21069;&amp;#22238;&amp;#12392;&amp;#21516;&amp;#12376;&lt;/span&gt;
Consumer got 1  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;0.1&amp;#31186;&amp;#24453;&amp;#12387;&amp;#12390;&amp;#12363;&amp;#12425;get&amp;#12377;&amp;#12427;&lt;/span&gt;
Producer put 2  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;consumer&amp;#12364;get&amp;#12375;&amp;#12390;&amp;#12289;&amp;#12420;&amp;#12387;&amp;#12392;put&amp;#12363;&amp;#12425;&amp;#25147;&amp;#12427;&lt;/span&gt;
Producer done
Consumer got 2
Consumer done
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
この例でのポイントは put 2のメッセージが got 1の後に来ているところです。consumerスレッドはスタートしてからまず0.1秒スリープしますが、その間にメインスレッドのproducerはputできずにブロックされていることがわかります。
&lt;/p&gt;

&lt;p&gt;
次に、 &lt;code&gt;Queue.task_done()&lt;/code&gt; はそのキューに対してそのタスクが完了したことを宣言します。全てのタスクの完了を待つにはそのキューに対して &lt;code&gt;Queue.join()&lt;/code&gt; を呼べばよく、それまでブロックされます。これはスレッドのjoinとは別なことに注意です。
&lt;/p&gt;

&lt;p&gt;
キューのタスクが完了するというのは、そのキューからgetしてきた仕事(アイテム)を最後の1個まで、全て処理し終わったという意味です。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; threading &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; Thread
&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; queue &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; Queue
&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; time

&lt;span style="font-weight: bold; font-style: italic;"&gt;in_queue&lt;/span&gt; = Queue()
&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;consumer&lt;/span&gt;():
    &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'Consumer waiting'&lt;/span&gt;)
    &lt;span style="font-weight: bold; font-style: italic;"&gt;work&lt;/span&gt; = in_queue.get()
    &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'Consumer working'&lt;/span&gt;)
    time.sleep(1)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12371;&amp;#12398;&amp;#20363;&amp;#12391;&amp;#12398;&amp;#12479;&amp;#12473;&amp;#12463;&amp;#12399;&amp;#12473;&amp;#12522;&amp;#12540;&amp;#12503;&amp;#12377;&amp;#12427;&amp;#12371;&amp;#12392;&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'Consumer done'&lt;/span&gt;)
    in_queue.task_done()  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12479;&amp;#12473;&amp;#12463;&amp;#23436;&amp;#20102;&amp;#12434;&amp;#23459;&amp;#35328;&amp;#12377;&amp;#12427;&lt;/span&gt;

&lt;span style="font-weight: bold; font-style: italic;"&gt;thread&lt;/span&gt; = Thread(target=consumer)
thread.start()

&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'Producer putting'&lt;/span&gt;)
in_queue.put(&lt;span style="font-weight: bold;"&gt;object&lt;/span&gt;())
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'Producer waiting'&lt;/span&gt;)
in_queue.join()  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;in_queue&amp;#12398;&amp;#23436;&amp;#20102;(=task_done&amp;#12364;&amp;#21628;&amp;#12400;&amp;#12428;&amp;#12427;)&amp;#12414;&amp;#12391;&amp;#12502;&amp;#12525;&amp;#12483;&amp;#12463;&amp;#12373;&amp;#12428;&amp;#12427;&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'Producer done'&lt;/span&gt;)
thread.join()
&amp;gt;&amp;gt;&amp;gt;
Consumer waiting
Producer putting
Producer waiting
Consumer working
&lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12371;&amp;#12371;&amp;#12391;1&amp;#31186;&amp;#12473;&amp;#12522;&amp;#12540;&amp;#12503;&amp;#12377;&amp;#12427;&lt;/span&gt;
Consumer done
Producer done
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
この例でのポイントはもちろん、consumer doneまでproducer doneが出ないところです。
&lt;/p&gt;

&lt;p&gt;
さて、これらの知識を使ってパイプラインを実装します。パイプラインはdownload, resize, uploadの3ステージからなるとします。写真をカメラからダウンロードして、サイズを変えてまたアップロードする場合を想定しています。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; threading &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; Thread
&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; queue &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; Queue
&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; time

&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;download&lt;/span&gt;(item):
    &lt;span style="font-weight: bold;"&gt;pass&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;resize&lt;/span&gt;(item):
    &lt;span style="font-weight: bold;"&gt;pass&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;upload&lt;/span&gt;(item):
    &lt;span style="font-weight: bold;"&gt;pass&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;code&gt;Queue&lt;/code&gt; を継承した &lt;code&gt;ClosableQueue&lt;/code&gt; を定義します。これはメソッド &lt;code&gt;close&lt;/code&gt; を持ち、キューにこれ以降の入力が無いことを示す sentinel を入れます。sentinel は歩哨・見張りの意味で、終わりの印です。&lt;a href="./effective1.html"&gt;Item 10&lt;/a&gt;で出てきましたね。
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;__iter__&lt;/code&gt; を準備したことで、このキューを iterate することができます。 &lt;code&gt;get()&lt;/code&gt; でキューから写真を取り出し、sentinel以外ならyieldして写真を返します。キューに何も入っていなかったら &lt;code&gt;get()&lt;/code&gt; がブロックします。キューから取ってきたアイテムが写真でなくsentinelだったら、終わりの印なのでリターンしています。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;ClosableQueue&lt;/span&gt;(Queue):
    &lt;span style="font-weight: bold; font-style: italic;"&gt;SENTINEL&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;object&lt;/span&gt;()
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;close&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.put(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.SENTINEL)
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__iter__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
        &lt;span style="font-weight: bold;"&gt;while&lt;/span&gt;(&lt;span style="font-weight: bold; text-decoration: underline;"&gt;True&lt;/span&gt;):
            &lt;span style="font-weight: bold; font-style: italic;"&gt;item&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.get()  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#20889;&amp;#30495;&amp;#12434;&amp;#19968;&amp;#12388;&amp;#21462;&amp;#12426;&amp;#20986;&amp;#12377;&amp;#12290;&amp;#28961;&amp;#12363;&amp;#12387;&amp;#12383;&amp;#12425;&amp;#12502;&amp;#12525;&amp;#12483;&amp;#12463;&amp;#12377;&amp;#12427;&lt;/span&gt;
            &lt;span style="font-weight: bold;"&gt;try&lt;/span&gt;:
                &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; item &lt;span style="font-weight: bold;"&gt;is&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.SENTINEL:
                    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt;
                &lt;span style="font-weight: bold;"&gt;yield&lt;/span&gt; item  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12414;&amp;#12384;finally&amp;#12399;&amp;#23455;&amp;#34892;&amp;#12375;&amp;#12394;&amp;#12356;&lt;/span&gt;
            &lt;span style="font-weight: bold;"&gt;finally&lt;/span&gt;:
                &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.task_done()  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12371;&amp;#12398;&amp;#20889;&amp;#30495;&amp;#12398;&amp;#20966;&amp;#29702;&amp;#12364;&amp;#23436;&amp;#20102;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
ここのtry - finallyの使い方に注目します。exceptで例外処理を行わないtry - finallyは、tryブロックの中で何が起こったとしてもfinallyブロックで取得しているロックを解放する(後始末する)ようなユースケースで使うようです。
&lt;/p&gt;

&lt;p&gt;
この例ではロックは使っていませんが、Queue.task_doneをロック解放、Queue.joinをロック解放待ちのアナロジーとして考えると、似たユースケースと言えそうです。
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;StoppableWorker&lt;/code&gt; は &lt;code&gt;ClosableQueue&lt;/code&gt; に対応した新ワーカースレッドです。スレッドは写真ではなくステージ(で作業する人)に対応します。 &lt;code&gt;in_queue&lt;/code&gt; から写真(&lt;code&gt;item&lt;/code&gt;)を取り出し、処理をして、処理後の写真(&lt;code&gt;result&lt;/code&gt;)を &lt;code&gt;out_queue&lt;/code&gt; に入れます。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;StoppableWorker&lt;/span&gt;(Thread):
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__init__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, func, in_queue, out_queue):
        &lt;span style="font-weight: bold;"&gt;super&lt;/span&gt;().__init__()
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.func = func  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12420;&amp;#12427;&amp;#20316;&amp;#26989;&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.in_queue = in_queue
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.out_queue = out_queue

    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;run&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
        &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; item &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.in_queue:  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;queue&amp;#12434;iterate&amp;#12377;&amp;#12427;&lt;/span&gt;
            &lt;span style="font-weight: bold; font-style: italic;"&gt;result&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.func(item)
            &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.out_queue.put(result)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
キューとスレッドを用意します。キューとキューの間にワーカー(スレッド)がいるイメージですね。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;download_queue&lt;/span&gt; = ClosableQueue()
&lt;span style="font-weight: bold; font-style: italic;"&gt;resize_queue&lt;/span&gt; = ClosableQueue()
&lt;span style="font-weight: bold; font-style: italic;"&gt;upload_queue&lt;/span&gt; = ClosableQueue()
&lt;span style="font-weight: bold; font-style: italic;"&gt;done_queue&lt;/span&gt; = ClosableQueue()
&lt;span style="font-weight: bold; font-style: italic;"&gt;threads&lt;/span&gt; = [
    StoppableWorker(download, download_queue, resize_queue),
    StoppableWorker(resize, resize_queue, upload_queue),
    StoppableWorker(upload, upload_queue, done_queue),
    ]
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
最後にこれらをまとめます。SENTINELを投入する &lt;code&gt;Queue.close()&lt;/code&gt; はここで呼んでいるのですね。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; thread &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; threads:
    thread.start()

&lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; _ &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;range&lt;/span&gt;(1000):
    download_queue.put(&lt;span style="font-weight: bold;"&gt;object&lt;/span&gt;())  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;object()=&amp;#20889;&amp;#30495;&amp;#12434;&amp;#20837;&amp;#12428;&amp;#12427;&lt;/span&gt;

download_queue.close()  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;SENTINEL&amp;#25237;&amp;#20837;&lt;/span&gt;
download_queue.join()  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;task_done()&amp;#12364;&amp;#21628;&amp;#12400;&amp;#12428;&amp;#12427;&amp;#12414;&amp;#12391;&amp;#12371;&amp;#12371;&amp;#12391;&amp;#12502;&amp;#12525;&amp;#12483;&amp;#12463;&amp;#12373;&amp;#12428;&amp;#12427;&lt;/span&gt;
resize_queue.close()  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;SENTINEL&amp;#25237;&amp;#20837;&lt;/span&gt;
resize_queue.join()  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;task_done()&amp;#12364;&amp;#21628;&amp;#12400;&amp;#12428;&amp;#12427;&amp;#12414;&amp;#12391;&amp;#12371;&amp;#12371;&amp;#12391;&amp;#12502;&amp;#12525;&amp;#12483;&amp;#12463;&amp;#12373;&amp;#12428;&amp;#12427;&lt;/span&gt;
upload_queue.close()  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;SENTINEL&amp;#25237;&amp;#20837;&lt;/span&gt;
upload_queue.join()  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;task_done()&amp;#12364;&amp;#21628;&amp;#12400;&amp;#12428;&amp;#12427;&amp;#12414;&amp;#12391;&amp;#12371;&amp;#12371;&amp;#12391;&amp;#12502;&amp;#12525;&amp;#12483;&amp;#12463;&amp;#12373;&amp;#12428;&amp;#12427;&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(done_queue.qsize(), &lt;span style="font-style: italic;"&gt;'items finished'&lt;/span&gt;)
&lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; thread &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; threads:
    thread.join()
&amp;gt;&amp;gt;&amp;gt;
1000 items finished
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
あれ、まだ終わりじゃありませんでした。。。次は、ステージ毎に複数のワーカースレッドを用意してI/Oの並列度を上げることを考えます。
&lt;/p&gt;

&lt;p&gt;
まず、複数スレッドをスタート、ストップさせるヘルパー関数を用意します。 &lt;code&gt;start_threads&lt;/code&gt; 関数では引数 &lt;code&gt;count&lt;/code&gt; の数だけ &lt;code&gt;StoppableWorker&lt;/code&gt; スレッドを作ってスタートし、そのリストを返します。 &lt;code&gt;stop_threads&lt;/code&gt; 関数ではキューの &lt;code&gt;close&lt;/code&gt; を呼んでsentinelを投入し、キューの &lt;code&gt;join&lt;/code&gt; でタスクの完了を待ってからスレッドを完了させます。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;start_threads&lt;/span&gt;(count, *args):
    &lt;span style="font-weight: bold; font-style: italic;"&gt;threads&lt;/span&gt; = [StoppableWorker(*args) &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; _ &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;range&lt;/span&gt;(count)]
    &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; thread &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; threads:
        thread.start()  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12473;&amp;#12524;&amp;#12483;&amp;#12489;&amp;#12434;&amp;#12473;&amp;#12479;&amp;#12540;&amp;#12488;&amp;#12373;&amp;#12379;&amp;#12427;&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; threads

&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;stop_threads&lt;/span&gt;(closable_queue, threads):
    &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; _ &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; threads:
        closable_queue.close()  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;SENTINEL&amp;#25237;&amp;#20837;&lt;/span&gt;
    closable_queue.join()  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#20840;&amp;#12390;&amp;#12398;task_done()&amp;#12434;&amp;#24453;&amp;#12385;&amp;#12289;&amp;#12461;&amp;#12517;&amp;#12540;&amp;#12434;&amp;#12463;&amp;#12525;&amp;#12540;&amp;#12474;&amp;#12377;&amp;#12427;&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; thread &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; threads:
        thread.join()  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#20840;&amp;#12390;&amp;#12398;&amp;#12473;&amp;#12524;&amp;#12483;&amp;#12489;&amp;#12398;&amp;#23436;&amp;#20102;&amp;#12434;&amp;#24453;&amp;#12388;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
最後にこれらをまとめます。ダウンロードスレッドは3多重、リサイズは4多重、アップロードは5多重を指定してスレッドを作成しています。後は1000個の写真を投入し、スレッドを1種類ずつ止めていきます。ポイントは、 &lt;code&gt;stop_threads&lt;/code&gt; はsentinelを投入し、それが出てくるまでブロックするところでしょうか。このお陰で、後片付けが中途半端な状態で次の &lt;code&gt;stop_threads&lt;/code&gt; に行くことはありません。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;download_queue&lt;/span&gt; = ClosableQueue()
&lt;span style="font-weight: bold; font-style: italic;"&gt;resize_queue&lt;/span&gt; = ClosableQueue()
&lt;span style="font-weight: bold; font-style: italic;"&gt;upload_queue&lt;/span&gt; = ClosableQueue()
&lt;span style="font-weight: bold; font-style: italic;"&gt;done_queue&lt;/span&gt; = ClosableQueue()

&lt;span style="font-weight: bold; font-style: italic;"&gt;download_threads&lt;/span&gt; = start_threads(
    3, download, download_queue, resize_queue)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12480;&amp;#12454;&amp;#12531;&amp;#12525;&amp;#12540;&amp;#12489;&amp;#12399;3&amp;#22810;&amp;#37325;&lt;/span&gt;
&lt;span style="font-weight: bold; font-style: italic;"&gt;resize_threads&lt;/span&gt; = start_threads(
    4, resize, resize_queue, upload_queue)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12522;&amp;#12469;&amp;#12452;&amp;#12474;&amp;#12399;4&amp;#22810;&amp;#37325;&lt;/span&gt;
&lt;span style="font-weight: bold; font-style: italic;"&gt;upload_threads&lt;/span&gt; = start_threads(
    5, upload, upload_queue, done_queue)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12450;&amp;#12483;&amp;#12503;&amp;#12525;&amp;#12540;&amp;#12489;&amp;#12399;5&amp;#22810;&amp;#37325;&lt;/span&gt;

&lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; _ &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;range&lt;/span&gt;(1000):  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;1000&amp;#20491;(&amp;#26522;)&amp;#12398;&amp;#20889;&amp;#30495;&amp;#12434;&amp;#25237;&amp;#20837;&lt;/span&gt;
    download_queue.put(&lt;span style="font-weight: bold;"&gt;object&lt;/span&gt;())

stop_threads(download_queue, download_threads)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#23436;&amp;#20102;&amp;#24453;&amp;#12385;&amp;#12377;&amp;#12427;&lt;/span&gt;
stop_threads(resize_queue, resize_threads)
stop_threads(upload_queue, upload_threads)

&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(done_queue.qsize(), &lt;span style="font-style: italic;"&gt;'items finished'&lt;/span&gt;)
&amp;gt;&amp;gt;&amp;gt;
1000 items finished
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org88c44bc" class="outline-3"&gt;
&lt;h3 id="org88c44bc"&gt;&lt;span class="section-number-3"&gt;1.5&lt;/span&gt; Item 56: いつコンカレンシーが必要になるかをどう理解するか知れ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-5"&gt;
&lt;p&gt;
あるワークを、コンカレントに実行できるものにばらまくことを fan-out、ばらまいたものを回収することを fan-inと言うそうです。Pythonにはこれらを実現するツールがたくさんあって、それぞれトレードオフがあります。次の節以降で説明していきます。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgdda86ff" class="outline-3"&gt;
&lt;h3 id="orgdda86ff"&gt;&lt;span class="section-number-3"&gt;1.6&lt;/span&gt; Item 57: オンデマンドのfan-outで新たなスレッドインスタンスを作るのは避けろ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-6"&gt;
&lt;p&gt;
ダイナミックにfan-out/fan-inを繰り返すような用途や、非常に多くにfan-outするケースにはスレッドは合いません。
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;1スレッドあたり8MBのメモリを消費する&lt;/li&gt;
&lt;li&gt;スレッドの作成、開始、ロックなどでオーバーヘッドが大きい&lt;/li&gt;
&lt;li&gt;複雑になりデバッグが大変&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org87497b8" class="outline-3"&gt;
&lt;h3 id="org87497b8"&gt;&lt;span class="section-number-3"&gt;1.7&lt;/span&gt; Item 58: コンカレンシーのためにQueueを使うにはリファクタリングが必要なことを理解せよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-7"&gt;
&lt;p&gt;
Queueを使うとスレッド数はワーカーの数に限定されるので、上限を定めないスレッドよりはマシですが、仕組みが複雑なことと、仕様変更によっては大きなリファクタリングが必要になるため、よい方法とは言えません。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org01a1220" class="outline-3"&gt;
&lt;h3 id="org01a1220"&gt;&lt;span class="section-number-3"&gt;1.8&lt;/span&gt; Item 59: コンカレンシーでスレッドが必要なら ThreadPoolExecutorを検討せよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-8"&gt;
&lt;p&gt;
スレッドプールはなかなか良さそうです。例外を呼び元に伝搬する仕組みもあります。ただ、 &lt;code&gt;max_workers&lt;/code&gt; をあらかじめ決めておく必要があることがネックです
&lt;/p&gt;

&lt;p&gt;
&lt;a href="https://docs.python.org/3/library/concurrent.futures.html"&gt;公式サイト&lt;/a&gt;から実装例です。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; concurrent.futures
&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; urllib.request

&lt;span style="font-weight: bold; font-style: italic;"&gt;URLS&lt;/span&gt; = [&lt;span style="font-style: italic;"&gt;'http://www.foxnews.com/'&lt;/span&gt;,
        &lt;span style="font-style: italic;"&gt;'http://www.cnn.com/'&lt;/span&gt;,
        &lt;span style="font-style: italic;"&gt;'http://europe.wsj.com/'&lt;/span&gt;,
        &lt;span style="font-style: italic;"&gt;'http://www.bbc.co.uk/'&lt;/span&gt;,
        &lt;span style="font-style: italic;"&gt;'http://some-made-up-domain.com/'&lt;/span&gt;]

&lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;Retrieve a single page and report the URL and contents&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;load_url&lt;/span&gt;(url, timeout):
    &lt;span style="font-weight: bold;"&gt;with&lt;/span&gt; urllib.request.urlopen(url, timeout=timeout) &lt;span style="font-weight: bold;"&gt;as&lt;/span&gt; conn:
        &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; conn.read()

&lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;We can use a with statement to ensure threads are cleaned up promptly&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;with&lt;/span&gt; concurrent.futures.ThreadPoolExecutor(max_workers=5) &lt;span style="font-weight: bold;"&gt;as&lt;/span&gt; executor:
    &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;{future: url, ...}&amp;#12398;&amp;#36766;&amp;#26360;&amp;#12364;future_to_url&amp;#12395;&amp;#20837;&amp;#12426;&amp;#12414;&amp;#12377;&amp;#12290;&lt;/span&gt;
    &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;future&amp;#12399;&amp;#12381;&amp;#12398;callable&amp;#12398;&amp;#23455;&amp;#34892;&amp;#12434;&amp;#34920;&amp;#12377;&amp;#12458;&amp;#12502;&amp;#12472;&amp;#12455;&amp;#12463;&amp;#12488;&amp;#12391;&amp;#12377;&amp;#12290;&lt;/span&gt;
    &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;...&amp;#12371;&amp;#12398;&amp;#22580;&amp;#21512;&amp;#12399;&amp;#12527;&amp;#12540;&amp;#12459;&amp;#12540;&amp;#12473;&amp;#12524;&amp;#12483;&amp;#12489;&amp;#12391;&amp;#12377;&amp;#12397;&amp;#12290;&lt;/span&gt;
    &lt;span style="font-weight: bold; font-style: italic;"&gt;future_to_url&lt;/span&gt; = {executor.submit(load_url, url, 60): url &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; url &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; URLS}
    &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;as_completed&amp;#12399;future_to_url&amp;#12398;futures&amp;#12398;&amp;#23436;&amp;#20102;(&amp;#12414;&amp;#12383;&amp;#12399;&amp;#12461;&amp;#12515;&amp;#12531;&amp;#12475;&amp;#12523;)&amp;#12375;&amp;#12383;&lt;/span&gt;
    &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12452;&amp;#12531;&amp;#12473;&amp;#12479;&amp;#12531;&amp;#12473;&amp;#12398;iterator&amp;#12434;&amp;#36820;&amp;#12375;&amp;#12414;&amp;#12377;&amp;#12290;&amp;#12381;&amp;#12428;&amp;#12434;iterate&amp;#12375;&amp;#12390;future&lt;/span&gt;
    &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;= &amp;#12473;&amp;#12524;&amp;#12483;&amp;#12489;&amp;#12434;&amp;#24471;&amp;#12414;&amp;#12377;&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; future &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; concurrent.futures.as_completed(future_to_url):
        &lt;span style="font-weight: bold; font-style: italic;"&gt;url&lt;/span&gt; = future_to_url[future]
        &lt;span style="font-weight: bold;"&gt;try&lt;/span&gt;:
            &lt;span style="font-weight: bold; font-style: italic;"&gt;data&lt;/span&gt; = future.result()
        &lt;span style="font-weight: bold;"&gt;except&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;Exception&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;as&lt;/span&gt; exc:
            &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'%r generated an exception: %s'&lt;/span&gt; % (url, exc))
        &lt;span style="font-weight: bold;"&gt;else&lt;/span&gt;:
            &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'%r page is %d bytes'&lt;/span&gt; % (url, &lt;span style="font-weight: bold;"&gt;len&lt;/span&gt;(data)))
&amp;gt;&amp;gt;&amp;gt;
&lt;span style="font-style: italic;"&gt;'http://www.foxnews.com/'&lt;/span&gt; page &lt;span style="font-weight: bold;"&gt;is&lt;/span&gt; 323006 &lt;span style="font-weight: bold;"&gt;bytes&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;'http://www.cnn.com/'&lt;/span&gt; page &lt;span style="font-weight: bold;"&gt;is&lt;/span&gt; 1131345 &lt;span style="font-weight: bold;"&gt;bytes&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;'http://europe.wsj.com/'&lt;/span&gt; generated an exception: HTTP Error 404: Not Found
&lt;span style="font-style: italic;"&gt;'http://some-made-up-domain.com/'&lt;/span&gt; page &lt;span style="font-weight: bold;"&gt;is&lt;/span&gt; 64668 &lt;span style="font-weight: bold;"&gt;bytes&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;'http://www.bbc.co.uk/'&lt;/span&gt; page &lt;span style="font-weight: bold;"&gt;is&lt;/span&gt; 300118 &lt;span style="font-weight: bold;"&gt;bytes&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
上の例で、 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; によるスレッドプールを &lt;code&gt;executor&lt;/code&gt; としています。次の行で &lt;code&gt;URLS&lt;/code&gt; リストに入っているURLに対して、複数のスレッドで関数 &lt;code&gt;load_url&lt;/code&gt; を実行するようにfan-outしています。そして次の行の &lt;code&gt;for&lt;/code&gt; 文で完了したスレッドを刈り取っています(fan-in)。スレッド内で発生した例外は、呼び元で &lt;code&gt;future.result()&lt;/code&gt; を呼んで結果を刈り取る時に伝わるようです。意外と簡単に使えるのですね。
&lt;/p&gt;

&lt;p&gt;
実際の実行結果で例外が発生したのはsome-made-up-domainではなくeurope.wsj.comの方だったのが笑えます。ブラウザーで見ると、前者はドメインが売りに出されており、後者はwsj.comにフォワードされました。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org8af14bd" class="outline-3"&gt;
&lt;h3 id="org8af14bd"&gt;&lt;span class="section-number-3"&gt;1.9&lt;/span&gt; Item 60: コルーチン(Coroutines)を使って高コンカレントI/Oを実現せよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-9"&gt;
&lt;p&gt;
&lt;a href="https://docs.python.org/3/library/asyncio.html"&gt;Asyncronus I/O&lt;/a&gt;です。これは1スレッド内で、スレッドとは異なる仕組みを使ってコンテキストスイッチを行います。スレッドはOSカーネルの仕組みを使って、プリエンプティブにコンテキストスイッチしますが、Async I/Oでは長い待ちが発生する時(eg, ネットワーク待ち)に自発的に処理の実行を明け渡します。Async I/OはCPUネックの処理では効果がありません。Async I/Oの仕組みはスレッドよりもずっと軽く、数千のコンテキストをコンカレントに処理することができます。
&lt;/p&gt;

&lt;p&gt;
PythonのAsynchronous I/Oについては、Real Pythonの&lt;a href="https://realpython.com/async-io-python/"&gt;この記事&lt;/a&gt;が最新(Python 3.7)の情報を元に、わかりやすく詳細に解説しています。PythonのAsynchronous I/Oの仕組みはまだ整備されている途中であり、ネット上には古い情報が多く混乱しがちですが、この記事は情報を整理する意味でもお勧めです。
&lt;/p&gt;

&lt;p&gt;
&lt;a href="./effective2.html"&gt;Item 33&lt;/a&gt;にてジェネレーターとコルーチンについて書きました。コルーチンはジェネレーターの &lt;code&gt;yield&lt;/code&gt; 等の仕組みを使って、ルーチンの途中で他のコルーチンにコンテキストスイッチを行い、後で再び中断した行から処理を再開することができます。
&lt;/p&gt;

&lt;p&gt;
最新のPythonではジェネレーターは表に出ず、新たに導入した &lt;code&gt;async/await&lt;/code&gt; のシンタックスを使ってコルーチンを使います。Pythonでは、 &lt;code&gt;async def&lt;/code&gt; で定義された関数がコルーチンです。コルーチン内の &lt;code&gt;await&lt;/code&gt; 文でコンテキストスイッチを行います。ジェネレーターのyield文がそうであったように、コルーチンではawait文のところから、以前のコンテキストのまま処理が再開されます。(実は、 &lt;code&gt;await&lt;/code&gt; は &lt;code&gt;yield from&lt;/code&gt; と等価だそうです)
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; asyncio
&lt;span style="font-weight: bold;"&gt;async def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;some_coroutine&lt;/span&gt;():
    ...
    &lt;span style="font-weight: bold;"&gt;await&lt;/span&gt; slow_io_disk_read()
    ...
    &lt;span style="font-weight: bold;"&gt;await&lt;/span&gt; slow_io_network_transfer()
    ...
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
上記のコルーチンの例では、 &lt;code&gt;await slow_io_disk_read(), await slow_io_network_transfer()&lt;/code&gt; で待ちが発生し、別のコルーチンにコンテキストスイッチします。
&lt;/p&gt;

&lt;p&gt;
以下にコルーチンの基本的な実装パターンを示します。(Real Pythonの記事より)
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;async def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;count&lt;/span&gt;():
    &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;"One"&lt;/span&gt;)
    &lt;span style="font-weight: bold;"&gt;await&lt;/span&gt; asyncio.sleep(1)
    &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;"Two"&lt;/span&gt;)

&lt;span style="font-weight: bold;"&gt;async def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;main&lt;/span&gt;():
    &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12467;&amp;#12523;&amp;#12540;&amp;#12481;&amp;#12531;count()&amp;#12434;3&amp;#12388;&amp;#23455;&amp;#34892;&amp;#12377;&amp;#12427;&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;await&lt;/span&gt; asyncio.gather(count(), count(), count())

&lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__name__&lt;/span&gt; == &lt;span style="font-style: italic;"&gt;"__main__"&lt;/span&gt;:
    &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; time
    &lt;span style="font-weight: bold; font-style: italic;"&gt;s&lt;/span&gt; = time.perf_counter()
    &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12467;&amp;#12523;&amp;#12540;&amp;#12481;&amp;#12531;&amp;#12513;&amp;#12452;&amp;#12531;&amp;#38306;&amp;#25968;&amp;#23455;&amp;#34892;(&amp;#23436;&amp;#20102;&amp;#12434;&amp;#24453;&amp;#12388;)&lt;/span&gt;
    asyncio.run(main())
    &lt;span style="font-weight: bold; font-style: italic;"&gt;elapsed&lt;/span&gt; = time.perf_counter() - s
    &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(f&lt;span style="font-style: italic;"&gt;"{__file__} executed in {elapsed:0.2f} seconds."&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;code&gt;asyncio.run&lt;/code&gt; でコルーチンの &lt;code&gt;main&lt;/code&gt; 関数を起動し、 &lt;code&gt;main&lt;/code&gt; の &lt;code&gt;await asyncio.gather&lt;/code&gt; からコルーチン &lt;code&gt;count&lt;/code&gt; を3つ起動〜回収します。 &lt;code&gt;asyncio.run&lt;/code&gt; はこれらが全て実行完了するまでブロックされて待ちます。
&lt;/p&gt;

&lt;p&gt;
コルーチンの &lt;code&gt;main&lt;/code&gt; を用意し、そこから個別のコルーチンを複数起動するやり方です。
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;asyncio.run&lt;/code&gt; 関数はPython 3.7で導入され、コルーチンを起動する標準の方法になりました。 &lt;code&gt;run&lt;/code&gt; 1行でイベントループを生成、タスクを起動〜完了〜回収、イベントループのクローズまで行います。以下の古い書式と同じ事をします。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;loop&lt;/span&gt; = asyncio.get_event_loop()
&lt;span style="font-weight: bold;"&gt;try&lt;/span&gt;:
    loop.run_until_complete(main())
&lt;span style="font-weight: bold;"&gt;finally&lt;/span&gt;:
    loop.close()
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;code&gt;run&lt;/code&gt; のお陰でイベントループを意識する必要が無く、使いやすくなりました。(&lt;code&gt;main&lt;/code&gt; 関数も隠蔽してくれるともっとすっきりする気がしますが)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6f6475b" class="outline-3"&gt;
&lt;h3 id="org6f6475b"&gt;&lt;span class="section-number-3"&gt;1.10&lt;/span&gt; Item 61: スレッド化されたI/Oをasyncioにポートする方法を知れ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-10"&gt;
&lt;p&gt;
主な作業
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;I/O待ちの発生する箇所に &lt;code&gt;await&lt;/code&gt; を付ける。&lt;/li&gt;
&lt;li&gt;待ちの発生する箇所を含む関数やfor, with等のブロックに &lt;code&gt;async&lt;/code&gt; を付ける&lt;/li&gt;
&lt;li&gt;関数名、クラス名を修正する&lt;/li&gt;
&lt;li&gt;asyncioのビルトインモジュールを使う&lt;/li&gt;
&lt;li&gt;スレッドの仕組みは全て置き換える&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
というところでしょうか。まだasyncioに未対応のモジュールもあることに注意。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgfdcbadf" class="outline-3"&gt;
&lt;h3 id="orgfdcbadf"&gt;&lt;span class="section-number-3"&gt;1.11&lt;/span&gt; Item 62: asyncioへの移行を楽にするため、スレッドとコルーチンを混在させよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-11"&gt;
&lt;p&gt;
asyncioへの移行はblocking I/Oには効果がありません。例えばディスクからリードするシステムコール &lt;code&gt;read&lt;/code&gt; は完了までスリープせずにブロックされるため、別タスクにコンテキストスイッチをする機会がありません。blocking I/Oにはスレッドが有効です。
&lt;/p&gt;

&lt;p&gt;
用途によってasyncioとスレッドを使い分ける(混在させる)ことが必要です。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd578482" class="outline-3"&gt;
&lt;h3 id="orgd578482"&gt;&lt;span class="section-number-3"&gt;1.12&lt;/span&gt; Item 63: レスポンスを最大化するためにはasyncioのイベントループをブロックするな&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-12"&gt;
&lt;p&gt;
以下の例のように、コルーチン用のイベントループ内でblocking I/Oをするとよくありません。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;async def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;run_tasks&lt;/span&gt;(handles, interval, output_path):
    &lt;span style="font-weight: bold;"&gt;with&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;open&lt;/span&gt;(output_path, &lt;span style="font-style: italic;"&gt;'wb'&lt;/span&gt;) &lt;span style="font-weight: bold;"&gt;as&lt;/span&gt; output:
        &lt;span style="font-weight: bold;"&gt;async def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;write_async&lt;/span&gt;(data):
            output.write(data)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12502;&amp;#12525;&amp;#12483;&amp;#12463;&amp;#12373;&amp;#12428;&amp;#12427;I/O&lt;/span&gt;
        &lt;span style="font-weight: bold; font-style: italic;"&gt;tasks&lt;/span&gt; = []
        &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; handle &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; handles:
            &lt;span style="font-weight: bold; font-style: italic;"&gt;coro&lt;/span&gt; = tail_async(handle, interval, write_async)
            &lt;span style="font-weight: bold; font-style: italic;"&gt;task&lt;/span&gt; = asyncio.create_task(coro)
            tasks.append(task)
        &lt;span style="font-weight: bold;"&gt;await&lt;/span&gt; asyncio.gather(*tasks)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
解決策として、ファイル操作を別スレッドとして独立させます。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;async def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;run_fully_async&lt;/span&gt;(handles, interval, output_path):
    &lt;span style="font-weight: bold;"&gt;async with&lt;/span&gt; WriteThread(output_path) &lt;span style="font-weight: bold;"&gt;as&lt;/span&gt; output:
        &lt;span style="font-weight: bold; font-style: italic;"&gt;tasks&lt;/span&gt; = []
        &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; handle &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; handles:
            &lt;span style="font-weight: bold; font-style: italic;"&gt;coro&lt;/span&gt; = tail_async(handle, interval, output.write)
            &lt;span style="font-weight: bold; font-style: italic;"&gt;task&lt;/span&gt; = asyncio.create_task(coro)
            tasks.append(task)
        &lt;span style="font-weight: bold;"&gt;await&lt;/span&gt; asyncio.gather(*tasks)
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
そしてそのために、スレッドのクラスを &lt;code&gt;async with&lt;/code&gt; 文で扱えるように &lt;code&gt;aenter, aexit&lt;/code&gt; を用意します(&lt;a href="https://www.python.org/dev/peps/pep-0492/"&gt;PEP 492&lt;/a&gt;)。このスレッドの使い方は便利そうです。
&lt;/p&gt;

&lt;p&gt;
ところで、ここではファイル操作系をスレッドとして独立させていますが、&lt;a href="https://github.com/Tinche/aiofiles"&gt;aiofiles&lt;/a&gt;を使えば、ファイル操作をasync化できそうです。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;async with&lt;/span&gt; aiofiles.&lt;span style="font-weight: bold;"&gt;open&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'filename'&lt;/span&gt;, mode=&lt;span style="font-style: italic;"&gt;'r'&lt;/span&gt;) &lt;span style="font-weight: bold;"&gt;as&lt;/span&gt; f:
    &lt;span style="font-weight: bold; font-style: italic;"&gt;contents&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;await&lt;/span&gt; f.read()
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(contents)
&lt;span style="font-style: italic;"&gt;'My file contents'&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
aiofilesのドキュメントを見ると、ファイル操作を別のスレッドプールにdelegateするとあります。
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
aiofiles helps with this by introducing asynchronous versions of files that support delegating operations to a separate thread pool.
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
こういうライブラリを使うのと、自分でスレッドを作るのと、どちらがいいのでしょうね。。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga5e4754" class="outline-3"&gt;
&lt;h3 id="orga5e4754"&gt;&lt;span class="section-number-3"&gt;1.13&lt;/span&gt; Item 64: 真の並行動作にはconcurrent.futuresを検討せよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-13"&gt;
&lt;p&gt;
Pythonのglobal interpreter lock (GIL)のせいで、マルチコアを使った真の並行動作は簡単には実現できません。Cエクステンションは高速化には適していますが、大きなコストがかかります。通常、遅くなる原因は多くの場所にあり、一部だけエクステンションとして抜き出して高速化する訳にはいかないようです。
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;concurrent.futures&lt;/code&gt; ビルトインモジュール経由でアクセスできる &lt;code&gt;multiprocessing&lt;/code&gt; ビルトインモジュールが使えるかもしれません。利用する側は &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; の代わりに &lt;code&gt;ProcessPoolExecutor&lt;/code&gt; で置き換えるだけでよいです。
&lt;/p&gt;

&lt;p&gt;
ただしこれは、自プロセスと子プロセスの間のデータのやりとりでpickleを使ったバイナリエンコード・デコードが必要で、オーバーヘッドが馬鹿になりません。よって &lt;code&gt;ProcessPoolExecutor&lt;/code&gt; で効果があるのは、プロセス間のデータ転送量及び頻度が少ない場合に限られます。
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;multiprocessing&lt;/code&gt; は共有メモリやプロセス間のロック、キュー、プロキシーといったより高度な手段を提供してはいますがが、これらは非常に複雑だそうです。
&lt;/p&gt;

&lt;p&gt;
こんなところでPythonの限界が見えてきてしまいました。。。(インタプリター言語に何を求めているのか、という話もありますが)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0930f1f" class="outline-2"&gt;
&lt;h2 id="org0930f1f"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; Chapter 8: 堅牢性(robustness)と性能&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org96215c0" class="outline-3"&gt;
&lt;h3 id="org96215c0"&gt;&lt;span class="section-number-3"&gt;2.1&lt;/span&gt; Item 65: try/except/else/finallyで各ブロックを有効に使え&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-1"&gt;
&lt;p&gt;
&lt;code&gt;try/except/else/finally&lt;/code&gt; ブロックを整理します。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;some_func&lt;/span&gt;():
    &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#20363;&amp;#12360;&amp;#12400;&amp;#12501;&amp;#12449;&amp;#12452;&amp;#12523;&amp;#12434;&amp;#12458;&amp;#12540;&amp;#12503;&amp;#12531;&amp;#12377;&amp;#12427;&amp;#20966;&amp;#29702;&lt;/span&gt;
    &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12371;&amp;#12371;&amp;#12391;&amp;#12398;&amp;#20363;&amp;#22806;&amp;#12399;&amp;#12377;&amp;#12368;&amp;#12395;&amp;#21628;&amp;#12403;&amp;#20803;&amp;#12395;&amp;#19978;&amp;#12364;&amp;#12427;&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;try&lt;/span&gt;:
        &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#20363;&amp;#22806;&amp;#12364;&amp;#19978;&amp;#12364;&amp;#12427;&amp;#21487;&amp;#33021;&amp;#24615;&amp;#12398;&amp;#12354;&amp;#12427;&amp;#12458;&amp;#12506;&amp;#12524;&amp;#12540;&amp;#12471;&amp;#12519;&amp;#12531;&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;except&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;ZeroDivisionError&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;as&lt;/span&gt; e:
        &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#24819;&amp;#23450;&amp;#12375;&amp;#12383;&amp;#20363;&amp;#22806;&amp;#12364;&amp;#19978;&amp;#12364;&amp;#12387;&amp;#12383;&amp;#22580;&amp;#21512;&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;else&lt;/span&gt;:
        &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;try&amp;#12391;&amp;#20363;&amp;#22806;&amp;#12364;&amp;#19978;&amp;#12364;&amp;#12425;&amp;#12394;&amp;#12363;&amp;#12387;&amp;#12383;&amp;#22580;&amp;#21512;&lt;/span&gt;
        &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12371;&amp;#12371;&amp;#12391;&amp;#12398;&amp;#20363;&amp;#22806;&amp;#12399;&amp;#21628;&amp;#12403;&amp;#20803;&amp;#12395;&amp;#20253;&amp;#25644;&amp;#12377;&amp;#12427;&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;finally&lt;/span&gt;:
        &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;(try&amp;#12395;&amp;#26469;&amp;#12390;&amp;#12356;&amp;#12383;&amp;#12425;)&amp;#38306;&amp;#25968;&amp;#12364;&amp;#12522;&amp;#12479;&amp;#12540;&amp;#12531;&amp;#12377;&amp;#12427;&amp;#21069;&amp;#12395;&amp;#24517;&amp;#12378;&amp;#23455;&amp;#34892;&amp;#12373;&amp;#12428;&amp;#12427;&lt;/span&gt;
        &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#20363;&amp;#12360;&amp;#12400;&amp;#12501;&amp;#12449;&amp;#12452;&amp;#12523;&amp;#12398;&amp;#12463;&amp;#12525;&amp;#12540;&amp;#12474;&amp;#20966;&amp;#29702;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgbf0282d" class="outline-3"&gt;
&lt;h3 id="orgbf0282d"&gt;&lt;span class="section-number-3"&gt;2.2&lt;/span&gt; Item 66: try/finally挙動を再利用するためにcontextlibとwithステートメントを考えよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-2"&gt;
&lt;p&gt;
&lt;code&gt;@contextmanager&lt;/code&gt; デコレーターで修飾した関数はコンテキストマネージャーとなり、 &lt;code&gt;with&lt;/code&gt; ステートメントで使えるようになります。正式に &lt;code&gt;__enter__&lt;/code&gt;, &lt;code&gt;__exit__&lt;/code&gt; を準備するよりも簡単です。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; contextlib &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; contextmanager
&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; logging

&lt;span style="font-weight: bold; text-decoration: underline;"&gt;@contextmanager&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;debug_logging&lt;/span&gt;(level):
    &lt;span style="font-weight: bold; font-style: italic;"&gt;logger&lt;/span&gt; = logging.getLogger()
    &lt;span style="font-weight: bold; font-style: italic;"&gt;old_level&lt;/span&gt; = logger.getEffectiveLevel()
    logger.setLevel(level)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#19968;&amp;#26178;&amp;#30340;&amp;#12395;&amp;#25351;&amp;#23450;&amp;#12525;&amp;#12464;&amp;#12524;&amp;#12505;&amp;#12523;&amp;#12434;&amp;#35373;&amp;#23450;&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;try&lt;/span&gt;:
        &lt;span style="font-weight: bold;"&gt;yield&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;finally&lt;/span&gt;:
        logger.setLevel(old_level)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12525;&amp;#12464;&amp;#12524;&amp;#12505;&amp;#12523;&amp;#12434;&amp;#25147;&amp;#12377;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
上記関数では(一時的に) &lt;code&gt;level&lt;/code&gt; にデバッグレベルを変更します。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;my_function&lt;/span&gt;():
    logging.debug(&lt;span style="font-style: italic;"&gt;'Some debug data'&lt;/span&gt;)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;DEBUG&lt;/span&gt;
    logging.error(&lt;span style="font-style: italic;"&gt;'Error log here'&lt;/span&gt;)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;ERROR &lt;/span&gt;
    logging.debug(&lt;span style="font-style: italic;"&gt;'More debug data'&lt;/span&gt;)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;DEBUG&lt;/span&gt;

&lt;span style="font-weight: bold;"&gt;with&lt;/span&gt; debug_logging(logging.DEBUG):  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;DEBUG&amp;#12524;&amp;#12505;&amp;#12523;&amp;#12398;&amp;#12502;&amp;#12525;&amp;#12483;&amp;#12463;&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'* Inside:'&lt;/span&gt;)
    my_function()

&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'* After:'&lt;/span&gt;)
my_function()
&amp;gt;&amp;gt;&amp;gt;
&amp;#8203;* Inside:
DEBUG:root:Some debug data  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;DEBUG&amp;#12524;&amp;#12505;&amp;#12523;&amp;#12364;&amp;#34920;&amp;#31034;&amp;#12373;&amp;#12428;&amp;#12390;&amp;#12356;&amp;#12427;&lt;/span&gt;
ERROR:root:Error log here
DEBUG:root:More debug data  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;DEBUG&amp;#12524;&amp;#12505;&amp;#12523;&amp;#12364;&amp;#34920;&amp;#31034;&amp;#12373;&amp;#12428;&amp;#12390;&amp;#12356;&amp;#12427;&lt;/span&gt;
&amp;#8203;* After:
ERROR:root:Error log here
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
上記 &lt;code&gt;with&lt;/code&gt; ブロックはデバッグレベルをDEBUGにします。出力結果から、実際にwithブロックでのみDEBUGレベルのメッセージ出力されていることがわかります。
&lt;/p&gt;

&lt;p&gt;
下の例で示すように、 &lt;code&gt;with&lt;/code&gt; ステートメントに渡されるコンテキストマネージャーは &lt;code&gt;yield&lt;/code&gt; でオブジェクトを返すことができ、 &lt;code&gt;as&lt;/code&gt; でローカル変数に入ります。これによって、 &lt;code&gt;with&lt;/code&gt; ブロック内のコードがそのコンテキストと直接interactできます。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; contextlib &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; contextmanager
&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; logging

&lt;span style="font-weight: bold; text-decoration: underline;"&gt;@contextmanager&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;log_level&lt;/span&gt;(level, name):
    &lt;span style="font-weight: bold; font-style: italic;"&gt;logger&lt;/span&gt; = logging.getLogger(name)
    &lt;span style="font-weight: bold; font-style: italic;"&gt;old_level&lt;/span&gt; = logger.getEffectiveLevel()
    logger.setLevel(level)
    &lt;span style="font-weight: bold;"&gt;try&lt;/span&gt;:
        &lt;span style="font-weight: bold;"&gt;yield&lt;/span&gt; logger  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12467;&amp;#12531;&amp;#12486;&amp;#12461;&amp;#12473;&amp;#12488;logger&amp;#12434;&amp;#36820;&amp;#12377;&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;finally&lt;/span&gt;:
        logger.setLevel(old_level)

logging.basicConfig()
&lt;span style="font-weight: bold;"&gt;with&lt;/span&gt; log_level(logging.DEBUG, &lt;span style="font-style: italic;"&gt;'my-log'&lt;/span&gt;) &lt;span style="font-weight: bold;"&gt;as&lt;/span&gt; logger:
    logger.debug(f&lt;span style="font-style: italic;"&gt;'This is a message for {logger.name}!'&lt;/span&gt;)
    logging.debug(&lt;span style="font-style: italic;"&gt;'This will not print'&lt;/span&gt;)
&amp;gt;&amp;gt;&amp;gt;
DEBUG:my-log:This &lt;span style="font-weight: bold;"&gt;is&lt;/span&gt; a message &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; my-log!
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;code&gt;with&lt;/code&gt; ブロック内で &lt;code&gt;logger.debug&lt;/code&gt; のメッセージは表示されましたが、 &lt;code&gt;logging.debug&lt;/code&gt; は表示されていません。なお、本には載っていませんが、 &lt;code&gt;logging.basicConfig()&lt;/code&gt; を呼ばないと &lt;code&gt;logger.debug&lt;/code&gt; の方も表示されませんでした。。。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga555eae" class="outline-3"&gt;
&lt;h3 id="orga555eae"&gt;&lt;span class="section-number-3"&gt;2.3&lt;/span&gt; Item 67: ローカル時間にはtimeの代わりにdatetimeを使え&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-3"&gt;
&lt;p&gt;
timeはUTCとローカルしか扱えないため、datatimeを使うべきです。pytzというコミュニティーが作っているライブラリを使うと世界中の時間が使えます。datetimeでは一度UTCに変換してから時間操作を行います。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; datetime &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; datetime, timezone
&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; pytz
&lt;span style="font-weight: bold; font-style: italic;"&gt;time_format&lt;/span&gt; = &lt;span style="font-style: italic;"&gt;'%Y-%m-%d %H:%M:%S'&lt;/span&gt;
&lt;span style="font-weight: bold; font-style: italic;"&gt;arrival_bos&lt;/span&gt; = &lt;span style="font-style: italic;"&gt;'2020-08-29 10:01:00'&lt;/span&gt;
&lt;span style="font-weight: bold; font-style: italic;"&gt;bos_dt_native&lt;/span&gt; = datetime.strptime(arrival_bos, time_format)
&lt;span style="font-weight: bold; font-style: italic;"&gt;edt&lt;/span&gt; = pytz.timezone(&lt;span style="font-style: italic;"&gt;'US/Eastern'&lt;/span&gt;)
&lt;span style="font-weight: bold; font-style: italic;"&gt;bos_dt&lt;/span&gt; = edt.localize(bos_dt_native)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;datetime&amp;#24418;&amp;#24335;&amp;#12398;&amp;#12508;&amp;#12473;&amp;#12488;&amp;#12531;&amp;#26178;&amp;#38291;&lt;/span&gt;
&lt;span style="font-weight: bold; font-style: italic;"&gt;utc_dt&lt;/span&gt; = pytz.utc.normalize(bos_dt.astimezone(pytz.utc))  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;UTC&amp;#12395;&amp;#22793;&amp;#25563;&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(utc_dt)
&amp;gt;&amp;gt;&amp;gt;
2020-08-29 14:01:00+00:00
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
UTCを日本時間に変換します。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;jst&lt;/span&gt; = pytz.timezone(&lt;span style="font-style: italic;"&gt;'Asia/Tokyo'&lt;/span&gt;)
&lt;span style="font-weight: bold; font-style: italic;"&gt;tokyo_dt&lt;/span&gt; = jst.normalize(utc_dt.astimezone(jst))  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;JST&amp;#12395;&amp;#22793;&amp;#25563;&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(tokyo_dt)
&amp;gt;&amp;gt;&amp;gt;
2020-08-29 23:01:00+09:00
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
このインタフェースだと、いったんUTCに変換しなくてもいいような???
単なるタイムゾーン間のコンバートならば、それでもいいかもしれません。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org320bcd5" class="outline-3"&gt;
&lt;h3 id="org320bcd5"&gt;&lt;span class="section-number-3"&gt;2.4&lt;/span&gt; Item 68: copyregでpickleをreliableにせよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-4"&gt;
&lt;p&gt;
Pythonでデータをシリアライズする場合、
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Python以外とデータ共有する場合はjson, xmlを使う&lt;/li&gt;
&lt;li&gt;Pythonとデータ共有する場合はpickleを使う&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
ことになると思います。
&lt;/p&gt;

&lt;p&gt;
pickleにcopyregを組み合わせると、以下のような場合に対応できるようになります。
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;pickleしたクラスのメンバーアトリビュートが追加された&lt;/li&gt;
&lt;li&gt;pickleしたクラスのメンバーアトリビュートが削除された&lt;/li&gt;
&lt;li&gt;pickleしたクラス名が変更になった&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
copyregは、pickle及びunpickleする時に呼ばれる関数を指定することで、そこでクラスのアトリビュート追加・削除の面倒を見ます。また、copyregを使うとクラス名がシリアライズされたデータに含まれないようになるため、クラス名の変更に対応できます。
&lt;/p&gt;

&lt;p&gt;
以下の例ではGameStateクラスをpickleすることを考えます。copyregを使うためのヘルパー関数を、pickle用とunpickle用の二つ用意します。pickle用の &lt;code&gt;pickle_game_state&lt;/code&gt; はunpickle用の &lt;code&gt;unpickle_game_state&lt;/code&gt; を引数の &lt;code&gt;kwargs&lt;/code&gt; とセットで返します。このためcopyregにはpickle用の関数(とpickleするクラス名)だけを登録すればよいです。 &lt;code&gt;copyreg.pickle&lt;/code&gt; で pickle 用の関数を登録しています。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; pickle
&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; copyreg
&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;GameState&lt;/span&gt;:
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__init__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, level=0, lives=4, points=0):
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.level = level
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.lives = lives
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.points = points

&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;pickle_game_state&lt;/span&gt;(game_state):  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;pickle.dumps&amp;#12377;&amp;#12427;&amp;#12392;&amp;#21628;&amp;#12400;&amp;#12428;&amp;#12427;&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;"pickling"&lt;/span&gt;)
    &lt;span style="font-weight: bold; font-style: italic;"&gt;kwargs&lt;/span&gt; = game_state.&lt;span style="font-weight: bold;"&gt;__dict__&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; unpickle_game_state, (kwargs,)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;unpickle&amp;#29992;&amp;#38306;&amp;#25968;&amp;#12434;&amp;#36820;&amp;#12377;&lt;/span&gt;

&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;unpickle_game_state&lt;/span&gt;(kwargs):  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;pickle.loads&amp;#12377;&amp;#12427;&amp;#12392;&amp;#21628;&amp;#12400;&amp;#12428;&amp;#12427;&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;"unpickling"&lt;/span&gt;)
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; GameState(**kwargs)

copyreg.pickle(GameState, pickle_game_state)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;pickle&amp;#29992;&amp;#38306;&amp;#25968;&amp;#12434;&amp;#30331;&amp;#37682;&amp;#12377;&amp;#12427;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
pickleしてみましょう。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;state&lt;/span&gt; = GameState()
&lt;span style="font-weight: bold; font-style: italic;"&gt;state.points&lt;/span&gt; += 1000
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;"call pickling"&lt;/span&gt;)
&lt;span style="font-weight: bold; font-style: italic;"&gt;serialized&lt;/span&gt; = pickle.dumps(state)
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;"call unpickling"&lt;/span&gt;)
&lt;span style="font-weight: bold; font-style: italic;"&gt;state_after&lt;/span&gt; = pickle.loads(serialized)
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(state_after.&lt;span style="font-weight: bold;"&gt;__dict__&lt;/span&gt;)
&amp;gt;&amp;gt;&amp;gt;
call pickling
pickling  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;pickle_game_state&amp;#12391;&amp;#34920;&amp;#31034;&amp;#12375;&amp;#12390;&amp;#12356;&amp;#12427;&lt;/span&gt;
b&lt;span style="font-style: italic;"&gt;'\x80\x04\x95L\x00\x00\x00\x00\x00\x00\x00\x8c\x08__main__\x94\x8c\x13unpickle_game_state\x94\x93\x94}\x94(\x8c\x05level\x94K\x00\x8c\x05lives\x94K\x04\x8c\x06points\x94M\xe8\x03u\x85\x94R\x94.'&lt;/span&gt;
call unpickling
unpickling  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;unpickle_game_state&amp;#12391;&amp;#34920;&amp;#31034;&amp;#12375;&amp;#12390;&amp;#12356;&amp;#12427;&lt;/span&gt;
{&lt;span style="font-style: italic;"&gt;'level'&lt;/span&gt;: 0, &lt;span style="font-style: italic;"&gt;'lives'&lt;/span&gt;: 4, &lt;span style="font-style: italic;"&gt;'points'&lt;/span&gt;: 1000}
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
実際に、pickleする際に &lt;code&gt;pickle_game_state&lt;/code&gt; が、unpickleする際に &lt;code&gt;unpickle_game_state&lt;/code&gt; が呼ばれていることがわかります。
&lt;/p&gt;

&lt;p&gt;
クラスへのアトリビュートの追加に対応できるのは、 &lt;code&gt;unpickle_game_state&lt;/code&gt; で GameState のインスタンスを作る際に、(追加後のクラスの)コンストラクターを呼ぶためです。この中で追加したアトリビュートのデフォルト値が設定されます。
&lt;/p&gt;

&lt;p&gt;
pickleするクラスのアトリビュートを削除するとbackward compatibilityが保てなくなります。この場合はバージョンを指定し、古いバージョンなら明示的に不要となったアトリビュートを削除します。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;pickle_game_state&lt;/span&gt;(game_state):
    &lt;span style="font-weight: bold; font-style: italic;"&gt;kwargs&lt;/span&gt; = game_state.&lt;span style="font-weight: bold;"&gt;__dict__&lt;/span&gt;
    &lt;span style="font-weight: bold; font-style: italic;"&gt;kwargs&lt;/span&gt;[&lt;span style="font-style: italic;"&gt;'version'&lt;/span&gt;] = 2
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; unpickle_game_state, (kwargs,)

&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;unpickle_game_state&lt;/span&gt;(kwargs):
    &lt;span style="font-weight: bold; font-style: italic;"&gt;version&lt;/span&gt; = kwargs.pop(&lt;span style="font-style: italic;"&gt;'version'&lt;/span&gt;, 1)
    &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; version == 1:  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#35501;&amp;#12435;&amp;#12391;&amp;#12365;&amp;#12383;&amp;#12496;&amp;#12540;&amp;#12472;&amp;#12519;&amp;#12531;&amp;#12364;1&amp;#12394;&amp;#12425;&amp;#21476;&amp;#12356;&amp;#12450;&amp;#12488;&amp;#12522;&amp;#12499;&amp;#12517;&amp;#12540;&amp;#12488;&amp;#12364;&amp;#12354;&amp;#12427;&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;del&lt;/span&gt; kwargs[&lt;span style="font-style: italic;"&gt;'deleted_attribute'&lt;/span&gt;]
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; GameState(**kwargs)
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org94b3ed9" class="outline-3"&gt;
&lt;h3 id="org94b3ed9"&gt;&lt;span class="section-number-3"&gt;2.5&lt;/span&gt; Item 69: 精度が重要なら decimal を使え&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-5"&gt;
&lt;p&gt;
Pythonのfloatの扱いで、1.44999999&amp;#x2026;のようになる場合があります。
これをきちっと1.45と見せたい場合、decimalを使うとよい、という話です。
&lt;/p&gt;

&lt;p&gt;
まずは、Decimalに小数点の付いた値を渡す際には文字列を使うと正確です。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; decimal &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; Decimal
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(Decimal(&lt;span style="font-style: italic;"&gt;'1.45'&lt;/span&gt;))  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#25991;&amp;#23383;&amp;#21015;&amp;#28193;&amp;#12375;&lt;/span&gt;
1.45
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(Decimal(1.45))  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;float&amp;#28193;&amp;#12375;&lt;/span&gt;
1.4499999999999999555910790149937383830547332763671875
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
お金の計算などで四捨五入してゼロにされると困るような場合にも対応可能です。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; decimal &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; Decimal, ROUND_UP
&lt;span style="font-weight: bold; font-style: italic;"&gt;rate&lt;/span&gt; = Decimal(&lt;span style="font-style: italic;"&gt;'0.05'&lt;/span&gt;)
&lt;span style="font-weight: bold; font-style: italic;"&gt;seconds&lt;/span&gt; = Decimal(&lt;span style="font-style: italic;"&gt;'5'&lt;/span&gt;)
&lt;span style="font-weight: bold; font-style: italic;"&gt;small_cost&lt;/span&gt; = rate * seconds / Decimal(60)
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;"&amp;#23455;&amp;#12398;&amp;#20516; - "&lt;/span&gt;, small_cost)
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;"&amp;#22235;&amp;#25448;&amp;#20116;&amp;#20837; - "&lt;/span&gt;, &lt;span style="font-weight: bold;"&gt;round&lt;/span&gt;(small_cost, 2))
&lt;span style="font-weight: bold; font-style: italic;"&gt;rounded&lt;/span&gt; = small_cost.quantize(Decimal(&lt;span style="font-style: italic;"&gt;'0.01'&lt;/span&gt;), rounding=ROUND_UP)
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;"&amp;#20999;&amp;#12426;&amp;#19978;&amp;#12370; - "&lt;/span&gt;, rounded)
&amp;gt;&amp;gt;&amp;gt;
&amp;#23455;&amp;#12398;&amp;#20516; -  0.004166666666666666666666666667
&amp;#22235;&amp;#25448;&amp;#20116;&amp;#20837; -  0.00
&amp;#20999;&amp;#12426;&amp;#19978;&amp;#12370; -  0.01
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org63ba8cb" class="outline-3"&gt;
&lt;h3 id="org63ba8cb"&gt;&lt;span class="section-number-3"&gt;2.6&lt;/span&gt; Item 70: 最適化の前にプロファイルせよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-6"&gt;
&lt;p&gt;
プロファイルにはCで書かれたcProfileを使うとよい、とのことです。
&lt;code&gt;test&lt;/code&gt; 関数をプロファイルして、統計を出す例:
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; cProfile &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; Profile
&lt;span style="font-weight: bold; font-style: italic;"&gt;profiler&lt;/span&gt; = Profile()
profiler.runcall(test)

&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; pstats &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; Stats
&lt;span style="font-weight: bold; font-style: italic;"&gt;stats&lt;/span&gt; = Stats(profiler)
stats.strip_dirs()
stats.sort_stats(&lt;span style="font-style: italic;"&gt;'cumulative'&lt;/span&gt;)
stats.print_stats()
&amp;gt;&amp;gt;&amp;gt;
         30003 function calls &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; 0.026 seconds

   Ordered by: cumulative time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    0.026    0.026 t.py:17(&amp;lt;&lt;span style="font-weight: bold;"&gt;lambda&lt;/span&gt;&amp;gt;)
        1    0.002    0.002    0.026    0.026 t.py:1(insertion_sort)
    10000    0.003    0.000    0.024    0.000 t.py:9(insert_value)
    10000    0.016    0.000    0.016    0.000 {method &lt;span style="font-style: italic;"&gt;'insert'&lt;/span&gt; of &lt;span style="font-style: italic;"&gt;'list'&lt;/span&gt; objects}
    10000    0.005    0.000    0.005    0.000 {built-&lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; method _bisect.bisect_left}
        1    0.000    0.000    0.000    0.000 {method &lt;span style="font-style: italic;"&gt;'disable'&lt;/span&gt; of &lt;span style="font-style: italic;"&gt;'_lsprof.Profiler'&lt;/span&gt; objects}
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgbc7ce26" class="outline-3"&gt;
&lt;h3 id="orgbc7ce26"&gt;&lt;span class="section-number-3"&gt;2.7&lt;/span&gt; Item 71: 生産者-消費者キューにはdequeを使え&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-7"&gt;
&lt;p&gt;
普通のリスト &lt;code&gt;[]&lt;/code&gt; はキューに使えますが、キューが長くなると特に &lt;code&gt;pop(0)&lt;/code&gt; が2乗のオーダーで遅くなるそうです。collectionsのdequeはリニアに遅くなるだけなので、キュー操作が性能ネックとなっているようなら、こちらを使った方が良いです。
&lt;/p&gt;

&lt;p&gt;
マイクロベンチマーク &lt;code&gt;timeit&lt;/code&gt; の使い方。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; collections
&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; timeit
&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;print_result&lt;/span&gt;(count, tests):
    &lt;span style="font-weight: bold; font-style: italic;"&gt;avg_iteration&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;sum&lt;/span&gt;(tests) / &lt;span style="font-weight: bold;"&gt;len&lt;/span&gt;(tests)
    &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(f&lt;span style="font-style: italic;"&gt;'Count {count:&amp;gt;5,} takes {avg_iteration:.4f}s'&lt;/span&gt;)
&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;deque_append_benchmark&lt;/span&gt;(count)
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;prepare&lt;/span&gt;():
        &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; collections.deque()
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;run&lt;/span&gt;(queue):
        &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; i &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;range&lt;/span&gt;(count):
            queue.append(i)
    &lt;span style="font-weight: bold; font-style: italic;"&gt;tests&lt;/span&gt; = timeit.repeat(
        setup=&lt;span style="font-style: italic;"&gt;'queue = prepare()'&lt;/span&gt;,
        stmt=&lt;span style="font-style: italic;"&gt;'run(queue)'&lt;/span&gt;,
        &lt;span style="font-weight: bold;"&gt;globals&lt;/span&gt;=&lt;span style="font-weight: bold;"&gt;locals&lt;/span&gt;(),
        repeat=1000
        number=1)
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; print_result(count, tests)
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
注意点として、timeitはループするのでキャッシュされて速くなってしまうようなことには使えません。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org80d9ffb" class="outline-3"&gt;
&lt;h3 id="org80d9ffb"&gt;&lt;span class="section-number-3"&gt;2.8&lt;/span&gt; Item 72: ソートされたシーケンス内をサーチするにはbisectを使え&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-8"&gt;
&lt;p&gt;
ソートされているリストなどの中で、指定の値がどこに来るかを調べるのに、 &lt;code&gt;bisect_left&lt;/code&gt; は速いのでいいですよ、ということでした。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb70e1cb" class="outline-3"&gt;
&lt;h3 id="orgb70e1cb"&gt;&lt;span class="section-number-3"&gt;2.9&lt;/span&gt; Item 73: 優先度キューのために heapq をどう使うかを知れ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-9"&gt;
&lt;p&gt;
FIFOでない、何かのアトリビュートの順番で処理する必要のあるキューを優先度キュー、プライオリティーキューと言います。優先度キューの実装に heapq が使えます。
&lt;/p&gt;

&lt;p&gt;
headqのアイテムは比較可能でnatural sort orderを持たなくてはいけません。これにはfunctoolsビルトインモジュールの &lt;code&gt;total_ordering&lt;/code&gt; クラスデコレーターを使い、 &lt;code&gt;__lt__&lt;/code&gt; (less than)スペシャルメソッドを実装する必要があります。
&lt;/p&gt;

&lt;p&gt;
以降は図書館の貸し出し本を管理する例です。キュー内の操作はコストがかかるため、なるべくキューには手を付けないようにします。本の返却は通常、キューから抜く操作が必要になりますが、ここではキューの中の返却された本には返却マークを付けるのみで、キューそのものは変更しないようにしています。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; functools
&lt;span style="font-weight: bold; text-decoration: underline;"&gt;@functools.total_ordering&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;Book&lt;/span&gt;:
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__init__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, title, due_date):
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.title = title
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.due_date = due_date
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.returnd = &lt;span style="font-weight: bold; text-decoration: underline;"&gt;False&lt;/span&gt;  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#36820;&amp;#21364;&amp;#12501;&amp;#12521;&amp;#12464;&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__lt__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, other):
        &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.due_date &amp;lt; other.due_date  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#36820;&amp;#21364;&amp;#26085;&amp;#12391;&amp;#27604;&amp;#36611;&amp;#12377;&amp;#12427;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
due_dateによるキューのソートは以下のようにできます。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; heapq &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; heapify
&lt;span style="font-weight: bold; font-style: italic;"&gt;queue&lt;/span&gt; = [
    Book(&lt;span style="font-style: italic;"&gt;'Pride and Prejudice'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'2019-06-10'&lt;/span&gt;),
    Book(&lt;span style="font-style: italic;"&gt;'The Time Machine'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'2019-05-30'&lt;/span&gt;),
    ...
    ]
queue.sort()
&amp;#12414;&amp;#12383;&amp;#12399;
heapify(queue)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
次は、期限切れの本を表示します。返却済みの本が出てきたら、ひっそりとキューから抜きます。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; heapq &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; heappop
&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;NoOverdueBooks&lt;/span&gt;(&lt;span style="font-weight: bold; text-decoration: underline;"&gt;Exception&lt;/span&gt;):
    &lt;span style="font-weight: bold;"&gt;pass&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;next_overdue_book&lt;/span&gt;(queue, now):
    &lt;span style="font-weight: bold;"&gt;while&lt;/span&gt; queue:
        &lt;span style="font-weight: bold; font-style: italic;"&gt;book&lt;/span&gt; = queue[0]  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;Most overdue first&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; book.returned:  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#36820;&amp;#21364;&amp;#28168;&amp;#12415;&amp;#12394;&amp;#12425;&amp;#12289;&amp;#12289;&lt;/span&gt;
            heappop(queue)
            &lt;span style="font-weight: bold;"&gt;continue&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; book.due_date &amp;lt; now:  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#26399;&amp;#38480;&amp;#20999;&amp;#12428;&amp;#12394;&amp;#12425;&lt;/span&gt;
            heappop(queue)
            &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; book
        &lt;span style="font-weight: bold;"&gt;break&lt;/span&gt;

    &lt;span style="font-weight: bold;"&gt;raise&lt;/span&gt; NoOverdueBooks
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
本の返却処理です。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;return_book&lt;/span&gt;(queue, book):
    &lt;span style="font-weight: bold; font-style: italic;"&gt;book.returned&lt;/span&gt; = &lt;span style="font-weight: bold; text-decoration: underline;"&gt;True&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
このやり方の欠点は、返却された本をキューから抜かないため、キューが大きくなりうることです。これはメモリを圧迫します。ワーストケースを想定して必要メモリ量等のシステム設計をする必要があります。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgebbaeda" class="outline-3"&gt;
&lt;h3 id="orgebbaeda"&gt;&lt;span class="section-number-3"&gt;2.10&lt;/span&gt; Item 74: bytesとゼロコピーでinteractするにはmemoryviewとbytearrayを使え&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-10"&gt;
&lt;p&gt;
出ました。ゼロコピーです。Pythonのバッファープロトコルとゼロコピーについては、&lt;a href="https://julien.danjou.info/high-performance-in-python-with-zero-copy-and-the-buffer-protocol/"&gt;ここ&lt;/a&gt;にわかりやすい説明がありました。
&lt;/p&gt;

&lt;p&gt;
bytesのデータを直接スライスするとメモリコピーが発生します。ビルトインの &lt;code&gt;memoryview&lt;/code&gt; タイプを使うとゼロコピーで行けます。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;data&lt;/span&gt; = b&lt;span style="font-style: italic;"&gt;'shave and a haircut, two bits'&lt;/span&gt;
&lt;span style="font-weight: bold; font-style: italic;"&gt;view&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;memoryview&lt;/span&gt;(data)
&lt;span style="font-weight: bold; font-style: italic;"&gt;chunk&lt;/span&gt; = view[12:19]
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;type&lt;/span&gt;(chunk))
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'Size: '&lt;/span&gt;, chunk.nbytes)
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'Data in view'&lt;/span&gt;, chunk.tobytes())
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'Underlying data:'&lt;/span&gt;, chunk.obj)
&amp;gt;&amp;gt;&amp;gt;
&amp;lt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-style: italic;"&gt;'memoryview'&lt;/span&gt;&amp;gt;
Size:  7
Data &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; view b&lt;span style="font-style: italic;"&gt;'haircut'&lt;/span&gt;
Underlying data: b&lt;span style="font-style: italic;"&gt;'shave and a haircut, two bits'&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
memoryview をスライスした &lt;code&gt;chunk&lt;/code&gt; のタイプはmemoryviewであることがわかります。
&lt;/p&gt;

&lt;p&gt;
bytesはリードオンリーのため、スライスした部分を上書きしたいなら &lt;code&gt;bytearray&lt;/code&gt; を使います。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;my_array&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;bytearray&lt;/span&gt;(b&lt;span style="font-style: italic;"&gt;'row, row, row your boat'&lt;/span&gt;)
&lt;span style="font-weight: bold; font-style: italic;"&gt;my_view&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;memoryview&lt;/span&gt;(my_array)
&lt;span style="font-weight: bold; font-style: italic;"&gt;write_view&lt;/span&gt; = my_view[3:13]
&lt;span style="font-weight: bold; font-style: italic;"&gt;write_view&lt;/span&gt;[:] = b&lt;span style="font-style: italic;"&gt;'1234567890'&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(my_array)
&amp;gt;&amp;gt;&amp;gt;
&lt;span style="font-weight: bold;"&gt;bytearray&lt;/span&gt;(b&lt;span style="font-style: italic;"&gt;'row1234567890 your boat'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
socket.recv_intoはゼロコピーに対応します。ビデオストリーミングデータを受け取る場合の例。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;socket&lt;/span&gt; = ... &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12463;&amp;#12521;&amp;#12452;&amp;#12450;&amp;#12531;&amp;#12488;&amp;#12408;&amp;#12398;&amp;#12477;&amp;#12465;&amp;#12483;&amp;#12488;&amp;#12467;&amp;#12493;&amp;#12463;&amp;#12471;&amp;#12519;&amp;#12531;&lt;/span&gt;
&lt;span style="font-weight: bold; font-style: italic;"&gt;video_cache&lt;/span&gt; = ... &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#20837;&amp;#12387;&amp;#12390;&amp;#12367;&amp;#12427;&amp;#12499;&amp;#12487;&amp;#12458;&amp;#12473;&amp;#12488;&amp;#12522;&amp;#12540;&amp;#12512;&amp;#29992;&amp;#12398;&amp;#12461;&amp;#12515;&amp;#12483;&amp;#12471;&amp;#12517;&lt;/span&gt;
&lt;span style="font-weight: bold; font-style: italic;"&gt;byte_offset&lt;/span&gt; = ... &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12496;&amp;#12483;&amp;#12501;&amp;#12449;&amp;#19978;&amp;#12395;&amp;#12487;&amp;#12540;&amp;#12479;&amp;#12364;&amp;#20837;&amp;#12387;&amp;#12390;&amp;#12367;&amp;#12427;&amp;#20301;&amp;#32622;&lt;/span&gt;
&lt;span style="font-weight: bold; font-style: italic;"&gt;size&lt;/span&gt; = 1024 * 1024 &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#20837;&amp;#12387;&amp;#12390;&amp;#12367;&amp;#12427;&amp;#12487;&amp;#12540;&amp;#12479;&amp;#12398;&amp;#12481;&amp;#12515;&amp;#12531;&amp;#12463;&amp;#12469;&amp;#12452;&amp;#12474;&lt;/span&gt;

&lt;span style="font-weight: bold; font-style: italic;"&gt;video_array&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;bytearray&lt;/span&gt;(video_cache)
&lt;span style="font-weight: bold; font-style: italic;"&gt;write_view&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;memoryview&lt;/span&gt;(video_array)
&lt;span style="font-weight: bold; font-style: italic;"&gt;chunk&lt;/span&gt; = write_view[byte_offset:byte_offset + size]
socket.recv_into(chunk)
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Python"></category><category term="Python"></category></entry><entry><title>Effective Python一人輪読会(Item 37 to 51)</title><link href="http://achiwa912.github.io/effective3.html" rel="alternate"></link><published>2020-08-21T00:00:00-04:00</published><updated>2021-01-28T00:00:00-05:00</updated><author><name>きょうす</name></author><id>tag:achiwa912.github.io,2020-08-21:/effective3.html</id><summary type="html">Effective Python読書メモ3</summary><content type="html">&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org1a3cd51"&gt;1. Chapter 5: クラスとインタフェース&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orgf342e3c"&gt;1.1. Item 37: ビルトインタイプを何重にもネストさせるより(複数の)クラスを作れ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org329d08b"&gt;1.2. Item 38: シンプルなインタフェースにはクラスでなく関数を受け入れよ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org881a322"&gt;1.3. Item 39: オブジェクトをgenericに作るためには@classmethodポリモーフィズムを使え&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orge2dc04c"&gt;1.4. Item 40: superを使って親クラスを初期化せよ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org353db6a"&gt;1.5. Item 41: Mix-inクラスを使って機能をcomposeすることを考えよ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgbdad28f"&gt;1.6. Item 42: プライベートなアトリビュートよりもパブリックな方が良い&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org0071639"&gt;1.7. Item 43: カスタムコンテナタイプを作るにはcollections.abcを継承せよ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#org60cf8ce"&gt;2. Chapter 6: メタクラスとアトリビュート&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org236efdf"&gt;2.0.1. メタクラスの定義&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org35d658b"&gt;2.0.2. typeが持つ別の顔&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org6d82d5f"&gt;2.0.3. typeの正体&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#org3a61733"&gt;2.1. Item 44: SetterやGetterメソッドよりもアトリビュートを普通に使え&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgf49ae81"&gt;2.2. Item 45: アトリビュートのリファクタリングよりも @property を使え&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org232a1a3"&gt;2.3. Item 46: 再利用可能な@propertyメソッドとしてデスクリプターを使え&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org7fa887f"&gt;2.4. Item 47: Lazyアトリビュートのために__getattr__, ​__getattribute__や__setattribute__を使え&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org92c6614"&gt;2.5. Item 48: ​__init_subclass__を使ってサブクラスをvalidateせよ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orga36a0e7"&gt;2.6. Item 49: ​__init_subclass__を使ってクラスを登録せよ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org1997640"&gt;2.7. Item 50: ​__set_name__を使ってクラスアトリビュートをannotateせよ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org449094d"&gt;2.8. Item 51: クラス拡張を組み合わせるために、メタクラスよりもクラスデコレーターを使え&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1a3cd51" class="outline-2"&gt;
&lt;h2 id="org1a3cd51"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Chapter 5: クラスとインタフェース&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgf342e3c" class="outline-3"&gt;
&lt;h3 id="orgf342e3c"&gt;&lt;span class="section-number-3"&gt;1.1&lt;/span&gt; Item 37: ビルトインタイプを何重にもネストさせるより(複数の)クラスを作れ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-1"&gt;
&lt;p&gt;
コードを拡張して以下のような複雑なコードになったら、複数のクラスを使うようにリファクタリングした方が良いです。
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;ディクショナリを含むディクショナリ&lt;/li&gt;
&lt;li&gt;3以上の個数を持つタプルを値として持つディクショナリ&lt;/li&gt;
&lt;li&gt;複雑にネストした他のビルトインタイプ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
長いタプルはnamedtupleを使う手もありますが、namedtupleには制限があります。
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;デフォルト値が指定できない&lt;/li&gt;
&lt;li&gt;数値のインデックスやiterationでアトリビュート値がアクセスできる&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org329d08b" class="outline-3"&gt;
&lt;h3 id="org329d08b"&gt;&lt;span class="section-number-3"&gt;1.2&lt;/span&gt; Item 38: シンプルなインタフェースにはクラスでなく関数を受け入れよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-2"&gt;
&lt;pre class="example"&gt;
current = {'green': 12, 'blue': 3}
&lt;/pre&gt;

&lt;p&gt;
このディクショナリに、
&lt;/p&gt;
&lt;pre class="example"&gt;
increments = [('red', 5), ('blue', 17), ('orange', 9)]
&lt;/pre&gt;

&lt;p&gt;
このタプルのリストを加えて、
&lt;/p&gt;
&lt;pre class="example"&gt;
result = {'green': 12, 'blue': 20, 'red': 5, 'orange': 9}
&lt;/pre&gt;

&lt;p&gt;
を得たいとします。
&lt;/p&gt;

&lt;p&gt;
次の関数は、ステートフルなclosureを使って追加した(=ミスした)色の数をカウントしつつ、上記のことを行います。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;increment_with_report&lt;/span&gt;(current, increments):
    &lt;span style="font-weight: bold; font-style: italic;"&gt;added_count&lt;/span&gt; = 0
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;missing&lt;/span&gt;():
        &lt;span style="font-style: italic;"&gt;'''&amp;#12459;&amp;#12454;&amp;#12531;&amp;#12488;&amp;#12434;+1&amp;#12375;&amp;#12390;0&amp;#12434;&amp;#36820;&amp;#12377;'''&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;nonlocal&lt;/span&gt; added_count  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12473;&amp;#12486;&amp;#12540;&amp;#12488;&amp;#12501;&amp;#12523;&amp;#12394;closure&lt;/span&gt;
        &lt;span style="font-weight: bold; font-style: italic;"&gt;added_count&lt;/span&gt; += 1
        &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; 0
    &lt;span style="font-weight: bold; font-style: italic;"&gt;result&lt;/span&gt; = defaultdict(missing, current)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;closure&amp;#12434;&amp;#20181;&amp;#36796;&amp;#12416;&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; key, amount &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; increments:
        &lt;span style="font-weight: bold; font-style: italic;"&gt;result&lt;/span&gt;[key] += amount
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; result, added_count
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
以前調べたとき、closuresは以下の定義でした。
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;関数と、そのインナー関数がある&lt;/li&gt;
&lt;li&gt;インナー関数は、外側の関数で定義された変数を参照する&lt;/li&gt;
&lt;li&gt;外側の関数は、インナー関数を戻り値として返す&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
上記の例では最後の要件を満たしていませんが、 &lt;code&gt;defaultdict()&lt;/code&gt; にインナー関数 &lt;code&gt;missing()&lt;/code&gt; を渡すことで、closureとして機能していることになるようです。
&lt;/p&gt;

&lt;p&gt;
また、上の例ではclosureをステートを保持する目的で使っています。これもclosureのユースケースの一つなのですね。
&lt;/p&gt;

&lt;p&gt;
しかし、ステートフルなclosureは読みづらいために避けるべきと書いてあります。その代わりにクラスを用意し、更に &lt;code&gt;__call__()&lt;/code&gt; を実装することでクラスを関数のように使うことを推奨しています。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;BetterCountMissing&lt;/span&gt;:
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__init__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.added = 0
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__call__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.added += 1
        &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; 0

&lt;span style="font-weight: bold; font-style: italic;"&gt;counter&lt;/span&gt; = BetterCountMissig()
&lt;span style="font-weight: bold; font-style: italic;"&gt;result&lt;/span&gt; = defaultdict(counter, current)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;counter&amp;#12434;&amp;#38306;&amp;#25968;&amp;#12392;&amp;#12375;&amp;#12390;&amp;#28193;&amp;#12377;&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; key, amount &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; increments:
    &lt;span style="font-weight: bold; font-style: italic;"&gt;result&lt;/span&gt;[key] += amount
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org881a322" class="outline-3"&gt;
&lt;h3 id="org881a322"&gt;&lt;span class="section-number-3"&gt;1.3&lt;/span&gt; Item 39: オブジェクトをgenericに作るためには@classmethodポリモーフィズムを使え&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-3"&gt;
&lt;p&gt;
えー、MapReduceって何でしたっけ。処理をたくさんのworkersにばらまいて、結果を統合していくやつでしたよね。この本は前提知識が高度すぎて、大変読みづらいです。ぼちぼち見ていきましょう。
&lt;/p&gt;

&lt;p&gt;
これはインタフェース的な、継承されることを前提としたクラスですね。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;InputData&lt;/span&gt;:
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;read&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
        &lt;span style="font-weight: bold;"&gt;raise&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;NotImplementedError&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
パスを渡されてリードする処理を実装した子クラスです。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;PathIputData&lt;/span&gt;(InputData):
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__init__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, path):
        &lt;span style="font-weight: bold;"&gt;super&lt;/span&gt;().__init__()
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.path = path
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;read&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
        &lt;span style="font-weight: bold;"&gt;with&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;open&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.path) &lt;span style="font-weight: bold;"&gt;as&lt;/span&gt; f:
            &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; f.read()
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
これもインタフェース的workerクラス。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;Worker&lt;/span&gt;:
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__init__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, input_data):
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.input_data = input_data
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.result = &lt;span style="font-weight: bold; text-decoration: underline;"&gt;None&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;map&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
        &lt;span style="font-weight: bold;"&gt;raise&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;NotImplementedError&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;reduce&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, other):
        &lt;span style="font-weight: bold;"&gt;raise&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;NotImplementedError&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
行数をカウントする処理を入れ込んだworker子クラス。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;LineCountWorker&lt;/span&gt;(Worker):
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;map&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
        &lt;span style="font-weight: bold; font-style: italic;"&gt;data&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.input_data.read()
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.result = data.count(&lt;span style="font-style: italic;"&gt;'\n'&lt;/span&gt;)
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;reduce&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, other):
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.result += other.result
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
次は、ディレクトリをリストして、その中にあるファイルをリードできる &lt;code&gt;PathInputData&lt;/code&gt; オブジェクトをyieldするジェネレーター関数を定義します。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; os
&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;generate_inputs&lt;/span&gt;(data_dir):
    &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; name &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; os.listdir(data_dir):
        &lt;span style="font-weight: bold;"&gt;yield&lt;/span&gt; PathInputData(os.path.join(data_dir, name))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
そしてworkersを複数用意するところ。ワーカーとして &lt;code&gt;LineCountWorker&lt;/code&gt; を渡しています。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#24341;&amp;#25968;input_list&amp;#12399;PathInputData&amp;#12434;yield&amp;#12377;&amp;#12427;&amp;#12472;&amp;#12455;&amp;#12493;&amp;#12524;&amp;#12540;&amp;#12479;&amp;#12540;&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;create_workers&lt;/span&gt;(input_list):  
    &lt;span style="font-weight: bold; font-style: italic;"&gt;workers&lt;/span&gt; = []
    &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; input_data &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; input_list:
        workers.append(LineCountWorker(input_data))
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; workers
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
次は用意したworkersを実行するところ。Pythonでスレッド使うやり方習いましたっけ? まあ読めばわかるのでいいや。 &lt;code&gt;thread.join()&lt;/code&gt; は作ったスレッドの実行が終わるまで待つ(ブロックされる)ということ。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; threading &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; Thread
&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;execute&lt;/span&gt;(workers):
    &lt;span style="font-weight: bold; font-style: italic;"&gt;threads&lt;/span&gt; = [Thread(target=w.&lt;span style="font-weight: bold;"&gt;map&lt;/span&gt;) &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; w &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; workers]
    &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; thread &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; threads: thread.start()
    &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; thread &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; threads: thread.join()
    first, *&lt;span style="font-weight: bold; font-style: italic;"&gt;rest&lt;/span&gt; = workers
    &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; worker &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; rest:
        first.&lt;span style="font-weight: bold;"&gt;reduce&lt;/span&gt;(worker)
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; first.result
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
おー、なんか格好いいです。これがMapReduceの実装なのですね。先頭の worker に全ての結果を集約しています。
&lt;/p&gt;

&lt;p&gt;
最後にこれらをまとめます。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;mapreduce&lt;/span&gt;(data_dir):
    &lt;span style="font-weight: bold; font-style: italic;"&gt;inputs&lt;/span&gt; = generate_inputs(data_dir)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12472;&amp;#12455;&amp;#12493;&amp;#12524;&amp;#12540;&amp;#12479;&amp;#12540;&amp;#12434;&amp;#36820;&amp;#12377;&lt;/span&gt;
    &lt;span style="font-weight: bold; font-style: italic;"&gt;workers&lt;/span&gt; = create_workers(inputs)
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; execute(workers)
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;code&gt;generate_inputs&lt;/code&gt; は &lt;code&gt;PathInputData&lt;/code&gt; を一つずつ返す iterator を作り、 &lt;code&gt;create_workers&lt;/code&gt; でこれらを割り振ったワーカーのリストを用意して、 &lt;code&gt;executee&lt;/code&gt; で mapreduce します。うーん、格好いい! 
&lt;/p&gt;

&lt;p&gt;
ここまで理解したところで、やっと本節のテーマに入ります。導入が長すぎる。。。
まずは、上記のやり方に対してダメ出しです。問題は、パーツの結びつきがお互いに強すぎて、一つ変更するとみんな変更しなくてはいけないこと。独立性が低すぎるということです。
&lt;/p&gt;

&lt;p&gt;
これに対する解はクラスメソッドのポリモーフィズムを使うことだと書いてあります。正直言って、意味がわかりません。読み進めましょう。
&lt;/p&gt;

&lt;p&gt;
まずはgenericな &lt;code&gt;InputData&lt;/code&gt; クラスを定義します。追加したのはconfigパラメーターから設定を読み込むクラスメソッド(のインタフェース)。意味深です。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;GenericInputData&lt;/span&gt;:
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;read&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
        &lt;span style="font-weight: bold;"&gt;raise&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;NotImplementedError&lt;/span&gt;
    @&lt;span style="font-weight: bold;"&gt;classmethod&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;generate_inputs&lt;/span&gt;(cls, config):
        &lt;span style="font-weight: bold;"&gt;raise&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;NotImplementedError&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;code&gt;PathInputData&lt;/code&gt; クラスでこれを継承します。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;PathInputData&lt;/span&gt;(GenericInputData):
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__init__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, path):
        &lt;span style="font-weight: bold;"&gt;super&lt;/span&gt;().__init__()
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.path = path
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;read&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
        &lt;span style="font-weight: bold;"&gt;with&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;open&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.path) &lt;span style="font-weight: bold;"&gt;as&lt;/span&gt; f:
            &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; f.read()
    @&lt;span style="font-weight: bold;"&gt;classmethod&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;generate_input&lt;/span&gt;(cls, config):
        &lt;span style="font-weight: bold; font-style: italic;"&gt;data_dir&lt;/span&gt; = config[&lt;span style="font-style: italic;"&gt;'data_dir'&lt;/span&gt;]
        &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; name &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; os.listdir(data_dir)
            &lt;span style="font-weight: bold;"&gt;yield&lt;/span&gt; cls(os.path.join(data_dir, name))
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
別関数だった &lt;code&gt;generate_input&lt;/code&gt; を &lt;code&gt;PathInputData&lt;/code&gt; にクラスメソッドとして組み込んでいます。
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;yield&lt;/code&gt; の行は、 &lt;code&gt;PathInputData&lt;/code&gt; のインスタンスを作って、その引数としてconfigのディレクトリにある各ファイルのパスを渡しています。 &lt;code&gt;@classmethod&lt;/code&gt; を付けてクラスメソッドを用意することで、 &lt;code&gt;__init__()&lt;/code&gt; を使わない別のやり方でコンストラクターを定義することができる、ということでした。
&lt;/p&gt;

&lt;p&gt;
また、genericなクラスではなく具体的な子クラスでそのクラスメソッドを実装することで、子クラスに合わせたフレキシブルな初期化ロジックを入れ込むことができます。
&lt;/p&gt;

&lt;p&gt;
そしてgenericなworkerクラスです。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;GenericWorker&lt;/span&gt;:
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__init__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, input_data)
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.input_data = input_data
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.result = &lt;span style="font-weight: bold; text-decoration: underline;"&gt;None&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;map&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
        &lt;span style="font-weight: bold;"&gt;raise&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;NotImplementedError&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;reduce&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, other):
        &lt;span style="font-weight: bold;"&gt;raise&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;NotImplementedError&lt;/span&gt;

    @&lt;span style="font-weight: bold;"&gt;classmethod&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;create_workers&lt;/span&gt;(cls, input_class, config):
        &lt;span style="font-weight: bold; font-style: italic;"&gt;workers&lt;/span&gt; = []
        &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; input_data &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; input_class.generate_inputs(config):
            workers.append(cls(input_data))
        &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; workers
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
こちらでも別関数だった &lt;code&gt;create_workers&lt;/code&gt; をクラスメソッドとして組み込んでいます。今回のポイントはクラスメソッドを使ったポリモーフィズムとのことですが、 &lt;code&gt;create_workers&lt;/code&gt; をジェネリックなworkerクラスに組み込んだところを言っているのでしょうか。
&lt;/p&gt;

&lt;p&gt;
以前は &lt;code&gt;mapreuce&lt;/code&gt; 関数で呼び出していた &lt;code&gt;generate_inputs&lt;/code&gt; はこの中で呼び出されるようになります。つまり、 &lt;code&gt;create_workers&lt;/code&gt; メソッドにおいて &lt;code&gt;PathInputData&lt;/code&gt; インスタンスの生成と、それを組み込んだ &lt;code&gt;GenericWorker&lt;/code&gt; インスタンスの生成を行っています。
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;LineCountWorker&lt;/code&gt; は &lt;code&gt;GenericWorker&lt;/code&gt; を継承します。他は変更なし。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;LineCountWorker&lt;/span&gt;(GenericWorker):
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;map&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
    ...
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;reduce&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, other):
    ...
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;code&gt;mapreduce&lt;/code&gt; 関数は引数としてconfigを取ります。 &lt;code&gt;generate_inputs&lt;/code&gt; の呼び出しは &lt;code&gt;create_workers&lt;/code&gt; に含まれたのでここからは無くなっています。シンプルになりました。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;mapreduce&lt;/span&gt;(worker_class, input_class, config):
    &lt;span style="font-weight: bold; font-style: italic;"&gt;workers&lt;/span&gt; = worker_class.create_workers(input_class, config)
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; execute(workers)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
そして、全ての基点がここ。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;config&lt;/span&gt; = {&lt;span style="font-style: italic;"&gt;'data_dir'&lt;/span&gt;: tmpdir}
&lt;span style="font-weight: bold; font-style: italic;"&gt;result&lt;/span&gt; = mapreduce(LineCountWorker, PathInputData, config)
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(f&lt;span style="font-style: italic;"&gt;'There are {result} lines'&lt;/span&gt;)

&amp;gt;&amp;gt;&amp;gt;
There are 4360 lines
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
ところで、独立性が低すぎる件はこれで解決したのでしょうか。クラスのインスタンス生成をクラスメソッドとして組み込んだためスッキリしたとは思いますが、どこが解決されているのか今ひとつわかりません。。。
&lt;/p&gt;

&lt;p&gt;
今回の節はかなり難しかったです。意味を理解するのに数時間以上悩みました。
&lt;/p&gt;

&lt;p&gt;
追記です。このようなやり方でオブジェクトを作る方法は、static factory patternというようです。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orge2dc04c" class="outline-3"&gt;
&lt;h3 id="orge2dc04c"&gt;&lt;span class="section-number-3"&gt;1.4&lt;/span&gt; Item 40: superを使って親クラスを初期化せよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-4"&gt;
&lt;p&gt;
スーパークラスのコンストラクタを呼ぶときは、親クラスを名前で指定するのでなく、 &lt;code&gt;super.__init__()&lt;/code&gt; を指定するように、とのこと。普通にやっていますよね。この節はこれで言いたいことはおしまいですが、更に補足します。
&lt;/p&gt;

&lt;p&gt;
二つの親クラスを継承した子クラスがあるとして、その二つの親クラスのどこかの先祖が同じクラスであるような継承をダイヤモンド継承と呼ぶらしいです。ダイヤモンド継承ではその同じ祖先のコンストラクタを複数回実行してしまうことで、副作用が出ることがあります。
&lt;/p&gt;

&lt;p&gt;
例えば共有する先祖クラスにおいて、親クラスで操作する変数の初期化をしている場合は、一つの親クラスがその変数の初期化及び値を操作した後に、別の親クラスのコンストラクタでもう一度初期化してしまう場合がありえます。
&lt;/p&gt;

&lt;p&gt;
しかし、 &lt;code&gt;super&lt;/code&gt; を使うと一つの祖先クラスのコンストラクターを1回しか実行しないことを保証してくれます。このあたりのルールは method resolution order (MRO)という仕様にて定義されています。
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;super&lt;/code&gt; によるMROを使ったコンストラクターは、先祖クラスのコンストラクターを実行する順序が、ぱっと見の感覚と異なる場合があることに注意。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org353db6a" class="outline-3"&gt;
&lt;h3 id="org353db6a"&gt;&lt;span class="section-number-3"&gt;1.5&lt;/span&gt; Item 41: Mix-inクラスを使って機能をcomposeすることを考えよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-5"&gt;
&lt;p&gt;
Mixinsは知りませんでした。&lt;a href="https://www.residentmar.io/2019/07/07/python-mixins.html#:~:text=A%20mixin%20is%20a%20class,this%20feature%E2%80%94and%20nothing%20else.&amp;amp;text=Mixins%20are%20a%20safe%20form%20of%20multiple%20inheritance."&gt;ここ&lt;/a&gt;にわかりやすい定義があります。
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
A mixin is a class that defines and implements a single, well-defined feature. Subclasses that inherit from the mixin inherit this feature—and nothing else.
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
継承させることを目的に、ある一つの機能だけを定義、実装したクラスで、 &lt;code&gt;xxxMixin&lt;/code&gt; のような名前になるそうです。クラスを定義するときに、メインとなる親クラス一つと、複数のmixinクラスを継承するような使い方をします。
&lt;/p&gt;
&lt;pre class="example"&gt;
class SomeClass(Parent, AaaMixin, BbbMixin, CccMixin):
&lt;/pre&gt;

&lt;p&gt;
のような感じで。これは便利そうです。Javaのインタフェースがこれに相当するのでしたっけ。
&lt;/p&gt;

&lt;p&gt;
この中に出てくるバイナリーツリーのコードの意味がピンときません。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;BinaryTree&lt;/span&gt;(ToDictMixin):
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__init__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, value, left=&lt;span style="font-weight: bold; text-decoration: underline;"&gt;None&lt;/span&gt;, right=&lt;span style="font-weight: bold; text-decoration: underline;"&gt;None&lt;/span&gt;):
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.value = value
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.left = left
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.right = right
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;code&gt;ToDictMinxin&lt;/code&gt; はディクショナリ(リストや相当機能を持つクラスを含む)をたどってPythonのディクショナリに変換する &lt;code&gt;to_dict&lt;/code&gt; メソッドを実装したmixinです。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;tree&lt;/span&gt; = BinaryTree(10, 
    left=BinaryTree(7, right=BinaryTree(9)),
    right=BinaryTree(13, left=BinaryTree(11)))
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(tree.to_dict())
&amp;gt;&amp;gt;&amp;gt;
{&lt;span style="font-style: italic;"&gt;'value'&lt;/span&gt;: 10,
 &lt;span style="font-style: italic;"&gt;'left'&lt;/span&gt;: {&lt;span style="font-style: italic;"&gt;'value'&lt;/span&gt;: 7, 
          &lt;span style="font-style: italic;"&gt;'left'&lt;/span&gt;: &lt;span style="font-weight: bold; text-decoration: underline;"&gt;None&lt;/span&gt;, 
          &lt;span style="font-style: italic;"&gt;'right: {'&lt;/span&gt;value&lt;span style="font-style: italic;"&gt;': 9, '&lt;/span&gt;left&lt;span style="font-style: italic;"&gt;': None, '&lt;/span&gt;right&lt;span style="font-style: italic;"&gt;': None}},&lt;/span&gt;
&lt;span style="font-style: italic;"&gt; '&lt;/span&gt;right&lt;span style="font-style: italic;"&gt;': {'&lt;/span&gt;value&lt;span style="font-style: italic;"&gt;': 13, &lt;/span&gt;
&lt;span style="font-style: italic;"&gt;          '&lt;/span&gt;left&lt;span style="font-style: italic;"&gt;': {'&lt;/span&gt;value&lt;span style="font-style: italic;"&gt;': 11, '&lt;/span&gt;left&lt;span style="font-style: italic;"&gt;': None, '&lt;/span&gt;right&lt;span style="font-style: italic;"&gt;': None},&lt;/span&gt;
&lt;span style="font-style: italic;"&gt;          '&lt;/span&gt;right&lt;span style="font-style: italic;"&gt;': None}}&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
ここにコードスニップを書いて眺めていたら、ようやく理解できました。
Kindleデバイスでこの本を読むのは無理があります。。。
&lt;/p&gt;

&lt;p&gt;
また、
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; json
&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;JsonMixin&lt;/span&gt;:
    @&lt;span style="font-weight: bold;"&gt;classmethod&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;from_json&lt;/span&gt;(cls, data):
        &lt;span style="font-weight: bold; font-style: italic;"&gt;kwargs&lt;/span&gt; = json.loads(data)
        &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; cls(**kwargs)
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;to_json&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
        &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; json.dumps(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.to_dict())
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
このクラスメソッド &lt;code&gt;from_json()&lt;/code&gt; がわかりづらかったです。
&lt;code&gt;data&lt;/code&gt; はjsonエンコードしてシリアライズされたデータで、これをディクショナリに変換(デコード)して &lt;code&gt;kwargs&lt;/code&gt; に入れます。そしてこれを引数に当該クラスのオブジェクトを作成して戻します。 &lt;code&gt;JsonMixin&lt;/code&gt; は、当該クラスをjsonにエンコードする機能と、逆にデコードしてクラスに戻す機能を付与する mixin でした。
&lt;/p&gt;

&lt;p&gt;
これはスタティックファクトリーパターン、、、とは違うのかな。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgbdad28f" class="outline-3"&gt;
&lt;h3 id="orgbdad28f"&gt;&lt;span class="section-number-3"&gt;1.6&lt;/span&gt; Item 42: プライベートなアトリビュートよりもパブリックな方が良い&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-6"&gt;
&lt;p&gt;
タイトルの通りです。
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;プライベートアトリビュートは頑張れば子クラスからアクセスできてしまう&lt;/li&gt;
&lt;li&gt;プライベートアトリビュートを親クラスから更にその親クラスに移した場合など、子クラスで無理にアクセスしようとしていると名称が変わってアクセスできなくなる&lt;/li&gt;
&lt;li&gt;プライベートの仕組みを使ってアクセス制御するよりも、注意事項をドキュメントに書いた方がよい&lt;/li&gt;
&lt;li&gt;唯一プライベートアトリビュートを使って良いのは、名前のコンフリクトを避けたい場合&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0071639" class="outline-3"&gt;
&lt;h3 id="org0071639"&gt;&lt;span class="section-number-3"&gt;1.7&lt;/span&gt; Item 43: カスタムコンテナタイプを作るにはcollections.abcを継承せよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-7"&gt;
&lt;p&gt;
これもタイトルの通りです。
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;list&lt;/code&gt; や &lt;code&gt;dict&lt;/code&gt; 等のPythonで定義されているコンテナタイプを継承してクラスが作れるとは知りませんでした。
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;list&lt;/code&gt; 等に用意されている便利なメソッドは多く、一から作るのは大変なので、 &lt;code&gt;collections.abc&lt;/code&gt; を継承するとよい、ということでした。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org60cf8ce" class="outline-2"&gt;
&lt;h2 id="org60cf8ce"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; Chapter 6: メタクラスとアトリビュート&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
メタクラスって何ですか? StackOverflowの&lt;a href="https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python"&gt;what-are-metaclass-in-python&lt;/a&gt;に、ものすごく詳しくてわかりやすい解説がありました。
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org236efdf" class="outline-4"&gt;
&lt;h4 id="org236efdf"&gt;&lt;span class="section-number-4"&gt;2.0.1&lt;/span&gt; メタクラスの定義&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-0-1"&gt;
&lt;p&gt;
メタクラスはクラスを作るクラスです。クラスはそのクラスの実体(オブジェクト)がどのように振る舞うかを規定しますが、メタクラスはクラスがどう振る舞うかを規定します。クラスはメタクラスのインスタンスです。
&lt;/p&gt;

&lt;p&gt;
そういう意味で、クラスはオブジェクトです。オブジェクトは以下の特徴を持ちます。
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;それを変数にアサインできる&lt;/li&gt;
&lt;li&gt;コピーできる&lt;/li&gt;
&lt;li&gt;それにアトリビュートを追加できる&lt;/li&gt;
&lt;li&gt;関数のパラメーターとして渡すことが出来る&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org35d658b" class="outline-4"&gt;
&lt;h4 id="org35d658b"&gt;&lt;span class="section-number-4"&gt;2.0.2&lt;/span&gt; typeが持つ別の顔&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-0-2"&gt;
&lt;p&gt;
ご存じのように、 &lt;code&gt;type&lt;/code&gt; には &lt;code&gt;type(1)&lt;/code&gt; で &lt;code&gt;&amp;lt;type 'int'&amp;gt;&lt;/code&gt; を、 &lt;code&gt;type("1")&lt;/code&gt; で &lt;code&gt;&amp;lt;type 'str'&amp;gt;&lt;/code&gt; のように返す機能がありますが、その他に全く別のアビリティーを持ちます。それは、クラスを動的に作る機能です。
&lt;/p&gt;

&lt;p&gt;
この機能の使い方は以下です。
&lt;/p&gt;
&lt;pre class="example"&gt;
type(name, bases, attrs)
# name: クラスの名前
# bases: ペアレントクラスのタプル(空でもよい)
# attrs: アトリビュートの名前と値を持つディクショナリ
&lt;/pre&gt;


&lt;p&gt;
例えば、
&lt;/p&gt;
&lt;pre class="example"&gt;
class Foo():
    bar = True
&lt;/pre&gt;

&lt;p&gt;
は次のように書けます。
&lt;/p&gt;
&lt;pre class="example"&gt;
Foo = type('Foo', (), {'bar':True})
&lt;/pre&gt;

&lt;p&gt;
目からウロコです。なんだかすごくないですか!?
&lt;/p&gt;

&lt;p&gt;
メソッドを定義することも出来ます。
&lt;/p&gt;
&lt;pre class="example"&gt;
def echo_bar(self):
    print(self.bar)
&lt;/pre&gt;


&lt;p&gt;
Fooクラスを継承したFooChildを作ります。
&lt;/p&gt;
&lt;pre class="example"&gt;
FooChild = type('FooChild', (Foo,), {'echo_bar': echo_bar})
&lt;/pre&gt;


&lt;p&gt;
これが、Pythonがキーワード &lt;code&gt;class&lt;/code&gt; を見つけるとメタクラス &lt;code&gt;type&lt;/code&gt; を使って行うことだそうです。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6d82d5f" class="outline-4"&gt;
&lt;h4 id="org6d82d5f"&gt;&lt;span class="section-number-4"&gt;2.0.3&lt;/span&gt; typeの正体&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-0-3"&gt;
&lt;p&gt;
&lt;code&gt;__class__&lt;/code&gt; のアトリビュートを見ると、タイプがわかります。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold; font-style: italic;"&gt;age&lt;/span&gt; = 35
&amp;gt;&amp;gt;&amp;gt; age.__class__
&amp;lt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-style: italic;"&gt;'int'&lt;/span&gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold; font-style: italic;"&gt;name&lt;/span&gt; = &lt;span style="font-style: italic;"&gt;'bob'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; name.__class__
&amp;lt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-style: italic;"&gt;'str'&lt;/span&gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;foo&lt;/span&gt;(): &lt;span style="font-weight: bold;"&gt;pass&lt;/span&gt;
... 
&amp;gt;&amp;gt;&amp;gt; foo.__class__
&amp;lt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-style: italic;"&gt;'function'&lt;/span&gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;Bar&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;object&lt;/span&gt;): &lt;span style="font-weight: bold;"&gt;pass&lt;/span&gt;
... 
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold; font-style: italic;"&gt;b&lt;/span&gt; = Bar()
&amp;gt;&amp;gt;&amp;gt; b.__class__
&amp;lt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-style: italic;"&gt;'__main__.Bar'&lt;/span&gt;&amp;gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
おー、これはわかりやすいです。
&lt;/p&gt;

&lt;p&gt;
一歩踏み込んで、 &lt;code&gt;__class__&lt;/code&gt; の &lt;code&gt;__class__&lt;/code&gt; を見てみると、、、
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&amp;gt;&amp;gt;&amp;gt; age.__class__.__class__
&amp;lt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-style: italic;"&gt;'type'&lt;/span&gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; name.__class__.__class__
&amp;lt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-style: italic;"&gt;'type'&lt;/span&gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; foo.__class__.__class__
&amp;lt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-style: italic;"&gt;'type'&lt;/span&gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; b.__class__.__class__
&amp;lt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-style: italic;"&gt;'type'&lt;/span&gt;&amp;gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
なんと、全て &lt;code&gt;type&lt;/code&gt; になっていました。つまり、メタクラス &lt;code&gt;type&lt;/code&gt; はPythonの様々なタイプオブジェクトのタイプなのでした。
&lt;/p&gt;

&lt;p&gt;
ここまで踏み込んだところで、ようやく本文に入ります。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3a61733" class="outline-3"&gt;
&lt;h3 id="org3a61733"&gt;&lt;span class="section-number-3"&gt;2.1&lt;/span&gt; Item 44: SetterやGetterメソッドよりもアトリビュートを普通に使え&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-1"&gt;
&lt;p&gt;
getter, setterを用意するのはpythonicでないそうです。
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;@property&lt;/code&gt; , &lt;code&gt;@&amp;lt;attr&amp;gt;.setter&lt;/code&gt; デコレーターを使うと、アトリビュートの値を普通に参照、 &lt;code&gt;=&lt;/code&gt; で設定するときにこれらのメソッドが使われます。Introducing Pythonを見返すまで忘れていましたが。。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;Duck&lt;/span&gt;():
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__init__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, input_name):
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.hidden_name = input_name
    @&lt;span style="font-weight: bold;"&gt;property&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;name&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
        &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.hidden_name
    &lt;span style="font-weight: bold; text-decoration: underline;"&gt;@name.setter&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;name&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, input_name):
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.hidden_name = input_name

&lt;span style="font-weight: bold; font-style: italic;"&gt;duck&lt;/span&gt; = Duck(&lt;span style="font-style: italic;"&gt;'No name'&lt;/span&gt;)
&lt;span style="font-weight: bold; font-style: italic;"&gt;duck.name&lt;/span&gt; = &lt;span style="font-style: italic;"&gt;'Donald'&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(duck.name)
&amp;gt;&amp;gt;&amp;gt;
Donald
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
注意点として、これらは副作用無く、素早く終わるようにすること、だそうです。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf49ae81" class="outline-3"&gt;
&lt;h3 id="orgf49ae81"&gt;&lt;span class="section-number-3"&gt;2.2&lt;/span&gt; Item 45: アトリビュートのリファクタリングよりも @property を使え&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-2"&gt;
&lt;p&gt;
&lt;code&gt;@property&lt;/code&gt; のアドバンストな使い方は、アトリビュートをその場で計算して返すこと。Linuxの/procと似てますね。
&lt;/p&gt;

&lt;p&gt;
本題から外れてまたKindle版の悪口ですが、Click here to view code imageをクリックしてビットマップイメージでコードを見ても、まだインデントが間違っている箇所がたくさんあります。本当にひどい。返品したいくらいです。Kindle版の技術書がひどいのはある程度わかっていましたが、ここまでとは。もう安くても買いません。
&lt;/p&gt;

&lt;p&gt;
えーと、leaky bucket(穴の開いたバケツ)です。最初、普通に穴の開いたバケツをイメージして読んだのですが、コードの意味がよくわかりません。検索してみると専門用語のようです。ここで言っているクオータは何でしょう。残量? 使用した量? 残量みたいですね。整理しながら読んでいきましょう。
&lt;/p&gt;

&lt;p&gt;
まずはバケツを定義します。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;Bucket&lt;/span&gt;:
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__init__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, period):
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.period_delta = timedelta(seconds=period)
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.reset_time = datetime.now()
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.quota = 0  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12463;&amp;#12458;&amp;#12540;&amp;#12479;&amp;#12434;0&amp;#12395;&amp;#21021;&amp;#26399;&amp;#21270;&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__repr__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
        &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; f&lt;span style="font-style: italic;"&gt;'Bucket(quota={self.quota})'&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
これはいいですかね。最初はクオータ0始まりです。
&lt;/p&gt;

&lt;p&gt;
次は &lt;code&gt;fill()&lt;/code&gt; です。バケツに水を汲みます。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;fill&lt;/span&gt;(bucket, amount):
    &lt;span style="font-weight: bold; font-style: italic;"&gt;now&lt;/span&gt; = datatime.now()
    &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; (now - bucket.reset_time) &amp;gt; bucket.period_delta:
        &lt;span style="font-weight: bold; font-style: italic;"&gt;bucket.quota&lt;/span&gt; = 0
        &lt;span style="font-weight: bold; font-style: italic;"&gt;bucket.reset_time&lt;/span&gt; = now
    &lt;span style="font-weight: bold; font-style: italic;"&gt;bucket.quota&lt;/span&gt; += amount
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
時間が &lt;code&gt;bucket.period_delta&lt;/code&gt; よりも長く経過していたら、タイマーをリセットし、クオータを &lt;code&gt;amount&lt;/code&gt; に設定して、まだだったら残量に &lt;code&gt;amount&lt;/code&gt; を追加しています。何ですかね。 &lt;code&gt;fill()&lt;/code&gt; を呼ばれたときだけ一気に漏れる(そしてフィルする)バケツなのでしょうか。何だかWikiで呼んだleaky bucket algorithmの定義と違うような。。。
&lt;/p&gt;

&lt;p&gt;
そして、Kindle版でインデントがずれていた &lt;code&gt;deduct()&lt;/code&gt; です。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;deduct&lt;/span&gt;(bucket, amount):
    &lt;span style="font-weight: bold; font-style: italic;"&gt;now&lt;/span&gt; = datetime.now()
    &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; (now - bucket.reset_time) &amp;gt; bucket.period_delta:
        &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;False&lt;/span&gt;  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12371;&amp;#12398;&amp;#26399;&amp;#38291;&amp;#12395;&amp;#12496;&amp;#12465;&amp;#12484;&amp;#12399;&amp;#12501;&amp;#12451;&amp;#12523;&amp;#12373;&amp;#12428;&amp;#12390;&amp;#12356;&amp;#12394;&amp;#12356;&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; bucket.quota - amount &amp;lt; 0:
        &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;False&lt;/span&gt;  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#20351;&amp;#12356;&amp;#12383;&amp;#12356;&amp;#37327;&amp;#12364;&amp;#12394;&amp;#12356;&lt;/span&gt;
    &lt;span style="font-weight: bold; font-style: italic;"&gt;bucket.quota&lt;/span&gt; -= amount
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;True&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
あれれ、残量によらず(?)期間にバケツがフィルされていなければ &lt;code&gt;False&lt;/code&gt; でリターンするのですね。フィルされずに &lt;code&gt;bucket.period_delta&lt;/code&gt; を過ぎていたら、既に漏れてしまっているのでdeductさせません(クオータ(残量)の値は変えないけど)という乱暴な作りなのでしょうか。
&lt;/p&gt;

&lt;p&gt;
整理してみましょう。
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;フィルするときに規定時間 &lt;code&gt;buekct.period_delta&lt;/code&gt; 経っていなければ残量に追加量を加える&lt;/li&gt;
&lt;li&gt;フィルするときに規定時間経っていれば期間のカウンターをリセットして追加量＝残量とする&lt;/li&gt;
&lt;li&gt;水を使おうとしたときに残量が必要量あり、規定時間経っていなければ、使わせる&lt;/li&gt;
&lt;li&gt;水を使おうとしたときに規定時間経っていたら、(残量がどうあれ)使わせない&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
やはり、乱暴な作りでした。。。
&lt;/p&gt;

&lt;p&gt;
この実装の問題は、そもそもバケツの残量がいくつから始まったのかわからないことだ、と書いてあります。そんなに大層な問題ですかね。。。
&lt;/p&gt;

&lt;p&gt;
で、改善版です。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;NewBucket&lt;/span&gt;:
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__init__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, period):
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.period_delta = timedelta(seconds=period)
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.reset_time = datetime.now()
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.max_quota = 0
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.quota_consumed = 0
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__repr__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
        &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; (f&lt;span style="font-style: italic;"&gt;'NewBucket(max_quota={self.max_quota}, '&lt;/span&gt;
               f&lt;span style="font-style: italic;"&gt;'quota_consumed={self.quota_consumed})'&lt;/span&gt;)
    @&lt;span style="font-weight: bold;"&gt;property&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;quota&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
        &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.max_quota - &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.quota_consumed
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;code&gt;quota&lt;/code&gt; アトリビュートを廃止して &lt;code&gt;max_quota&lt;/code&gt; と &lt;code&gt;quota_consumed&lt;/code&gt; を導入しました。そして &lt;code&gt;@property&lt;/code&gt; で廃止した &lt;code&gt;quota&lt;/code&gt; アトリビュートを動的に作って返します。今回のポイントは実はここだけですかね。
&lt;/p&gt;

&lt;p&gt;
更にsetterの定義です。上で定義した &lt;code&gt;fill()&lt;/code&gt; と &lt;code&gt;deduct()&lt;/code&gt; がそのまま使えるように配慮しました、と書いてあります。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold; text-decoration: underline;"&gt;@quota.setter&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;quota&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, amount):
    &lt;span style="font-weight: bold; font-style: italic;"&gt;delta&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.max_quota - amount  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#28187;&amp;#23569;&amp;#37327; = &amp;#26368;&amp;#22823;&amp;#37327; - &amp;#35373;&amp;#23450;&amp;#20516;&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; amount == 0:
        &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;0&amp;#12434;&amp;#25351;&amp;#23450;&amp;#12375;&amp;#12383;&amp;#22580;&amp;#21512;&amp;#12399;&amp;#12289;&amp;#26032;&amp;#12383;&amp;#12394;&amp;#26399;&amp;#38291;&amp;#12398;&amp;#12383;&amp;#12417;&amp;#12395;&amp;#12522;&amp;#12475;&amp;#12483;&amp;#12488;&amp;#12377;&amp;#12427;&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.quota_consumed = 0
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.max_quota = 0
    eilf delta &amp;lt; 0:
        &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#26032;&amp;#12383;&amp;#12394;&amp;#26399;&amp;#38291;&amp;#12398;&amp;#12383;&amp;#12417;&amp;#12395;&amp;#27531;&amp;#37327;&amp;#12434;&amp;#12501;&amp;#12451;&amp;#12523;&amp;#12377;&amp;#12427;&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;assert&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.quota_comsumed == 0
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.max_quota = amount
    &lt;span style="font-weight: bold;"&gt;else&lt;/span&gt;:
        &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#24403;&amp;#35442;&amp;#26399;&amp;#38291;&amp;#12395;&amp;#12362;&amp;#12356;&amp;#12390;&amp;#12289;&amp;#27531;&amp;#37327;&amp;#12434;&amp;#20351;&amp;#12358;&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;assert&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.max_quota &amp;gt;= &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.quota_consumed
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.quota_consumed += delta  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#28040;&amp;#36027;&amp;#12375;&amp;#12383;&amp;#37327;&amp;#12395;&amp;#28187;&amp;#23569;&amp;#37327;&amp;#12434;&amp;#21152;&amp;#12360;&amp;#12427;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
このメソッドだけ眺めても理解できないので、 &lt;code&gt;fill()&lt;/code&gt; や &lt;code&gt;deduct()&lt;/code&gt; と付き合わせて読みます。
&lt;/p&gt;

&lt;p&gt;
まず &lt;code&gt;amount == 0&lt;/code&gt; の時は、 &lt;code&gt;fill()&lt;/code&gt; で規定時間経過時のフィルのために、いったん残量をゼロにするところです。確かにこれでOKです。
&lt;/p&gt;

&lt;p&gt;
次の &lt;code&gt;delta &amp;lt; 0&lt;/code&gt; は、 &lt;code&gt;fill()&lt;/code&gt; で残量をゼロした後にフィルするところです。残量をゼロにしたときに &lt;code&gt;quota_consumed = max_quota = 0&lt;/code&gt; にしているので、 &lt;code&gt;delta&lt;/code&gt; は必ず負になります。
&lt;/p&gt;

&lt;p&gt;
それ以外のケースは &lt;code&gt;deduct()&lt;/code&gt; された場合です。このメソッドでは残量(quota)に、残量から減少量(&lt;code&gt;amount_deduct&lt;/code&gt; とする)を引いた量を代入しているので、これがsetterメソッドで残量に設定する値になるから、setterメソッドの引数を &lt;code&gt;amount_setter&lt;/code&gt; と表記すると、、、
&lt;/p&gt;
&lt;pre class="example"&gt;
self.quota_consumed += delta は、
self.quota_consumed = self.quota_consumed + delta ということなので、
    = quota_consumed + (max_quota - amount_setter)  self略
    = quota_consumed + (max_quota - (max_quota - quota_consumed - amount_deduct))
    = quota_consumed x 2 + amount_deduct あれあれ???
&lt;/pre&gt;
&lt;p&gt;
うーむ、何をどう間違ったのか。 &lt;code&gt;quota_comsumed&lt;/code&gt; が2回足されてしまいました。1回で良かったのに。2時間ほど考えてみましたがわかりませんでした。悔しいけど飛ばして進みます。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org232a1a3" class="outline-3"&gt;
&lt;h3 id="org232a1a3"&gt;&lt;span class="section-number-3"&gt;2.3&lt;/span&gt; Item 46: 再利用可能な@propertyメソッドとしてデスクリプターを使え&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-3"&gt;
&lt;p&gt;
&lt;code&gt;@property&lt;/code&gt; の大きな問題は再利用性です。同じようなアトリビュートがたくさんあると、それら全てに &lt;code&gt;@property&lt;/code&gt; を用意しなければなりません。更に、無関係のクラスでは再利用できません。
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;@classmethod&lt;/code&gt; はクラスメソッドで、そのクラスのオブジェクトを作らなくても使えるメソッドでした。 &lt;code&gt;@staticmethod&lt;/code&gt; は知っているような気もしますがクラスメソッドと何が違うのでしたっけ。&lt;a href="https://stackabuse.com/pythons-classmethod-and-staticmethod-explained/"&gt;ここ&lt;/a&gt;によると、スタティックメソッドは引数としてclsを取らないところがポイントで、クラスのステータスを扱えません。クラスメソッド(やインスタンスメソッドも?)から下請的に使うもののようです。
&lt;/p&gt;

&lt;p&gt;
次はデスクリプターです。Pythonのunder the hoodで活躍するもののようです。under the hood話はたまに聞くから良いのであって、これだけ続くとだいぶお腹いっぱいです。が、Real Pythonの&lt;a href="https://realpython.com/python-descriptors/"&gt;長い記事&lt;/a&gt;を読みます。。。。。 。。。読みました。最後の二つの節は意味が追えなかったので飛ばしましたが。
&lt;/p&gt;

&lt;p&gt;
デスクリプターは以下のデスクリプタープロトコルを一つ以上実装したクラスで、デスクリプター機能を実現したい他のクラスにアタッチして使います。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;__get__(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, obj, &lt;span style="font-weight: bold;"&gt;type&lt;/span&gt;=&lt;span style="font-weight: bold; text-decoration: underline;"&gt;None&lt;/span&gt;) -&amp;gt; &lt;span style="font-weight: bold;"&gt;object&lt;/span&gt;
__set__(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, obj, value) -&amp;gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;None&lt;/span&gt;
__delete__(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, obj) -&amp;gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;None&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
そしてEffective Pythonに戻って話を続けます。あれれ、話の展開がそっくりです。こんなのあり? でもお陰で読みやすいです。
&lt;/p&gt;

&lt;p&gt;
以下の例で &lt;code&gt;Grade&lt;/code&gt; がデスクリプターです。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;Grade&lt;/span&gt;:
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__get__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, instance, instance_type):
        ...
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__set__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, instance, value):
        ...

&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;Exam&lt;/span&gt;:
    &lt;span style="font-weight: bold; font-style: italic;"&gt;math_grade&lt;/span&gt; = Grade()
    &lt;span style="font-weight: bold; font-style: italic;"&gt;writing_grade&lt;/span&gt; = Grade()
    &lt;span style="font-weight: bold; font-style: italic;"&gt;science_grade&lt;/span&gt; = Grade()
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;code&gt;@property&lt;/code&gt; と同様に、デスクリプターをアタッチした変数は、クラスインスタンスのアトリビュートとしてアクセスできるようになります。上の例では、 &lt;code&gt;Exam&lt;/code&gt; のインスタンスを作ったとき、例えば &lt;code&gt;Exam_instance.writing_grade&lt;/code&gt; のアトリビュートアクセスで、 &lt;code&gt;Exam&lt;/code&gt; にアタッチされているデスクリプター &lt;code&gt;Grade&lt;/code&gt; の &lt;code&gt;__get__&lt;/code&gt; 、 &lt;code&gt;__get__&lt;/code&gt; が使われます。
&lt;/p&gt;

&lt;p&gt;
具体例です。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;exam&lt;/span&gt; = Exam()
&lt;span style="font-weight: bold; font-style: italic;"&gt;exam.writing_grade&lt;/span&gt; = 40
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
これは、次のように解釈されます。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;Exam.&lt;span style="font-weight: bold;"&gt;__dict__&lt;/span&gt;[&lt;span style="font-style: italic;"&gt;'writing_grade'&lt;/span&gt;].__set__(exam, 40)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
ここで、 &lt;code&gt;__dict__&lt;/code&gt; はPythonの全てのオブジェクトが持っているディクショナリのアトリビュートで、そのオブジェクトの全てのアトリビュートやメソッドが入っています。
例えば、以下のようになります。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(Exam.&lt;span style="font-weight: bold;"&gt;__dict__&lt;/span&gt;)
&amp;gt;&amp;gt;&amp;gt;
{&lt;span style="font-style: italic;"&gt;'__module__'&lt;/span&gt;: &lt;span style="font-style: italic;"&gt;'__main__'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'math_grade'&lt;/span&gt;: &amp;lt;__main__.Grade &lt;span style="font-weight: bold;"&gt;object&lt;/span&gt; at 0x10c02afa0&amp;gt;, &lt;span style="font-style: italic;"&gt;'writing_grade'&lt;/span&gt;: &amp;lt;__main__.Grade &lt;span style="font-weight: bold;"&gt;object&lt;/span&gt; at 0x10c02af70&amp;gt;, &lt;span style="font-style: italic;"&gt;'science_grade'&lt;/span&gt;: &amp;lt;__main__.Grade &lt;span style="font-weight: bold;"&gt;object&lt;/span&gt; at 0x10c041070&amp;gt;, &lt;span style="font-style: italic;"&gt;'__dict__'&lt;/span&gt;: &amp;lt;attribute &lt;span style="font-style: italic;"&gt;'__dict__'&lt;/span&gt; of &lt;span style="font-style: italic;"&gt;'Exam'&lt;/span&gt; objects&amp;gt;, &lt;span style="font-style: italic;"&gt;'__weakref__'&lt;/span&gt;: &amp;lt;attribute &lt;span style="font-style: italic;"&gt;'__weakref__'&lt;/span&gt; of &lt;span style="font-style: italic;"&gt;'Exam'&lt;/span&gt; objects&amp;gt;, &lt;span style="font-style: italic;"&gt;'__doc__'&lt;/span&gt;: &lt;span style="font-weight: bold; text-decoration: underline;"&gt;None&lt;/span&gt;}
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;code&gt;__dict__['writing_grade']&lt;/code&gt; は &lt;code&gt;Grade&lt;/code&gt; オブジェクトであることがわかりますね。同様に、
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;exam.writing_grade
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
これは、次のように解釈されます。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;Exam.&lt;span style="font-weight: bold;"&gt;__dict__&lt;/span&gt;[&lt;span style="font-style: italic;"&gt;'writing_grade'&lt;/span&gt;].__get__(exam, Exam)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
ここからしばらくReal PythonとEffective Pythonで同じストーリー展開で話が進みます。
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;Grade&lt;/code&gt; の実体は一つで、複数インスタンスから参照されるため、 &lt;code&gt;Grade&lt;/code&gt; が持つアトリビュートに値を入れても駄目(一つのインスタンスで値を変えると、全てのインスタンスで変わってしまう)&lt;/li&gt;
&lt;li&gt;普通のアトリビュートでなく、オブジェクトをキーとするディクショナリにすれば解決、に見える&lt;/li&gt;
&lt;li&gt;そのディクショナリは強参照しているため、オブジェクトが不要となっても参照数が残り、ガベージコレクションがメモリを解放しない。つまり、メモリリークする。&lt;/li&gt;
&lt;li&gt;弱参照にすればいいじゃん(いまここ)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
何やらマニアックな話です。また新概念の登場です。 &lt;code&gt;weakref&lt;/code&gt; モジュールの &lt;code&gt;WeakKeyDictionary&lt;/code&gt; は弱参照するディクショナリです(&lt;a href="https://docs.python.org/3/library/weakref.html"&gt;ここ&lt;/a&gt;)。強参照(strong reference)が普通の参照で、弱参照(weak reference)は弱い参照です。この強弱は何が違うのかと言うと、ガベージコレクションの際に参照数をカウントする、しないになります。
&lt;/p&gt;

&lt;p&gt;
ガベージコレクション(GC)は参照カウントがゼロのオブジェクトを回収してメモリを解放しますが、弱参照はGCにカウントされません。このため、弱参照しか残っていないオブジェクトはGCによってメモリ解放(&amp;amp;参照を解除)されてしまいます。
&lt;/p&gt;

&lt;p&gt;
そんな参照が役に立つのかというと、キャッシュなどのユースケースで使えます。キャッシュは本体がどこかにあるため、参照を消されてメモリ解放されても致命的ではないのです。
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;WeakKeyDictionary&lt;/code&gt; を使った最終版です。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; weakref &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; WeakKeyDictionary
&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;Grade&lt;/span&gt;:
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__init__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;._values = WeakKeyDictionary()
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__get__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, instance, instance_type):
        ...
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__set__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, instance, value):
        ...
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
ここでは省略していますが、 &lt;code&gt;__get__&lt;/code&gt;, &lt;code&gt;__set__&lt;/code&gt; の実装が変わっているはず、、、です。
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;Exam&lt;/code&gt; の実装は変わりません。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;Exam&lt;/span&gt;:
    &lt;span style="font-weight: bold; font-style: italic;"&gt;math_grade&lt;/span&gt; = Grade()
    &lt;span style="font-weight: bold; font-style: italic;"&gt;writing_grade&lt;/span&gt; = Grade()
    &lt;span style="font-weight: bold; font-style: italic;"&gt;science_grade&lt;/span&gt; = Grade()

&lt;span style="font-weight: bold; font-style: italic;"&gt;first_exam&lt;/span&gt; = Exam()
&lt;span style="font-weight: bold; font-style: italic;"&gt;first_exam.writing_grade&lt;/span&gt; = 82
&lt;span style="font-weight: bold; font-style: italic;"&gt;second_exam&lt;/span&gt; = Exam()
&lt;span style="font-weight: bold; font-style: italic;"&gt;second_exam.writing_grade&lt;/span&gt; = 75
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(f&lt;span style="font-style: italic;"&gt;'First {first_exam.writing_grade}'&lt;/span&gt;)
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(f&lt;span style="font-style: italic;"&gt;'Second {second_exam.writing_grade}'&lt;/span&gt;)
&amp;gt;&amp;gt;&amp;gt;
First 82
Second 75
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
複数インスタンスで別の値を持つことができました。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7fa887f" class="outline-3"&gt;
&lt;h3 id="org7fa887f"&gt;&lt;span class="section-number-3"&gt;2.4&lt;/span&gt; Item 47: Lazyアトリビュートのために__getattr__, ​__getattribute__や__setattribute__を使え&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-4"&gt;
&lt;p&gt;
Pythonのスペシャルメソッド &lt;code&gt;__getattr__&lt;/code&gt; はLazyなアトリビュート参照(参照された時に初めて見に行く)を実現します。クラスが &lt;code&gt;__getattr__&lt;/code&gt; を実装していたら、オブジェクトインスタンスのディクショナリにアトリビュートが見つからなかった際、 &lt;code&gt;__getattr__&lt;/code&gt; が呼ばれます。そしてそのアトリビュートはインスタンスディクショナリ &lt;code&gt;__dict__&lt;/code&gt; に登録され、次以降のアクセスはそのディクショナリから値を取り出します。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;SomeClass&lt;/span&gt;:
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__init__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, aaa):
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.exists = 5
    &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12458;&amp;#12502;&amp;#12472;&amp;#12455;&amp;#12463;&amp;#12488;&amp;#12364;&amp;#25351;&amp;#23450;&amp;#12450;&amp;#12488;&amp;#12522;&amp;#12499;&amp;#12517;&amp;#12540;&amp;#12488;&amp;#12434;&amp;#25345;&amp;#12383;&amp;#12394;&amp;#12356;&amp;#26178;&amp;#12395;&amp;#21628;&amp;#12400;&amp;#12428;&amp;#12427;&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__getattr__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, name):
        &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;"getattr is called"&lt;/span&gt;)
        &lt;span style="font-weight: bold; font-style: italic;"&gt;value&lt;/span&gt; = 15  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#26412;&amp;#24403;&amp;#12399;&amp;#12289;&amp;#12371;&amp;#12371;&amp;#12391;&amp;#22806;&amp;#37096;DB&amp;#12394;&amp;#12393;&amp;#12363;&amp;#12425;&amp;#20516;&amp;#12434;&amp;#25345;&amp;#12387;&amp;#12390;&amp;#12367;&amp;#12427;&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;setattr&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, name, value)
        &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; value

&lt;span style="font-weight: bold; font-style: italic;"&gt;sc&lt;/span&gt; = SomeClass()
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(sc.exists)
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;"1st: "&lt;/span&gt;, sc.foo)
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;"2nd: "&lt;/span&gt;, sc.foo)
&amp;gt;&amp;gt;&amp;gt;
5
&lt;span style="font-weight: bold;"&gt;getattr&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;is&lt;/span&gt; called
1st:  15
2nd:  15
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;code&gt;foo&lt;/code&gt; を2回読んだとき、 &lt;code&gt;__getattr__&lt;/code&gt; が呼ばれたのは最初の1回だけだったことがわかります。
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;__dict__&lt;/code&gt; にキャッシュされた値を取り出されると困る場合、例えば、アトリビュートが外部データベースの値を参照しているような時は、毎回実体のデータベースの値を読みにいく必要があります。これを実現するのが &lt;code&gt;__getattribute__&lt;/code&gt; スペシャルメソッドです。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;SomeClass&lt;/span&gt;:
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__init__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.exists = 5
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__getattribute__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, name):
        &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;"__getattribute__ is called"&lt;/span&gt;)
        &lt;span style="font-weight: bold; font-style: italic;"&gt;value&lt;/span&gt; = 15
        &lt;span style="font-weight: bold;"&gt;setattr&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, name, value)
        &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; value

&lt;span style="font-weight: bold; font-style: italic;"&gt;sc&lt;/span&gt; = SomeClass()
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(sc.exists)
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;"1st: "&lt;/span&gt;, sc.foo)
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;"2nd: "&lt;/span&gt;, sc.foo)
&amp;gt;&amp;gt;&amp;gt;
__getattribute__ &lt;span style="font-weight: bold;"&gt;is&lt;/span&gt; called
15
__getattribute__ &lt;span style="font-weight: bold;"&gt;is&lt;/span&gt; called
1st:  15
__getattribute__ &lt;span style="font-weight: bold;"&gt;is&lt;/span&gt; called
2nd:  15
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
常に &lt;code&gt;__getattribute__&lt;/code&gt; が呼ばれていることがわかります。
&lt;/p&gt;

&lt;p&gt;
Lazyにセットしたい場合は、これらに共通の &lt;code&gt;__setattr__&lt;/code&gt; を使います。これは毎回呼ばれるごとに、実体に値を設定します。
&lt;/p&gt;

&lt;p&gt;
注意点が一つあって、 &lt;code&gt;__getattribute__, __setattr__&lt;/code&gt; を使うときにはその中でこれらが再帰的に呼ばれないようにしないと、無限recursiveによって落ちます。 &lt;code&gt;super().__setaddr__&lt;/code&gt; のようにします。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__setaddr__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, name, value):
    &amp;#12394;&amp;#12395;&amp;#12363;&amp;#12481;&amp;#12455;&amp;#12483;&amp;#12463;&amp;#12375;&amp;#12390;&amp;#20363;&amp;#22806;&amp;#12434;&amp;#19978;&amp;#12370;&amp;#12383;&amp;#12426;&amp;#12290;&amp;#12290;&amp;#12290;
    &lt;span style="font-weight: bold;"&gt;super&lt;/span&gt;().__setattr__(name, value)
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org92c6614" class="outline-3"&gt;
&lt;h3 id="org92c6614"&gt;&lt;span class="section-number-3"&gt;2.5&lt;/span&gt; Item 48: ​__init_subclass__を使ってサブクラスをvalidateせよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-5"&gt;
&lt;p&gt;
メタクラスは &lt;code&gt;type&lt;/code&gt; を継承することで定義されます。デフォルトの挙動ではメタクラスは、関係するクラスのステートメントのコンテンツを &lt;code&gt;__new__&lt;/code&gt; メソッドで受け取ります。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;Meta&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;type&lt;/span&gt;):
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__new__&lt;/span&gt;(meta, name, bases, class_dict):
        &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(f&lt;span style="font-style: italic;"&gt;'* Running {meta}.__new__ for {name}'&lt;/span&gt;)
        &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'Bases:'&lt;/span&gt;, bases)
        &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(class_dict)
        &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;type&lt;/span&gt;.__new__(meta, name, bases, class_dict)

&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;MyClass&lt;/span&gt;(metaclass=Meta):
    &lt;span style="font-weight: bold; font-style: italic;"&gt;stuff&lt;/span&gt; = 123
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;foo&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
        &lt;span style="font-weight: bold;"&gt;pass&lt;/span&gt;

&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;MySubclass&lt;/span&gt;(MyClass):
    &lt;span style="font-weight: bold; font-style: italic;"&gt;other&lt;/span&gt; = 567
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;bar&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
        &lt;span style="font-weight: bold;"&gt;pass&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;code&gt;__new__&lt;/code&gt; の引数は以下です。
&lt;/p&gt;
&lt;pre class="example"&gt;
meta: メタクラス
name: (関連クラスの)名前
bases: ペアレントクラスのタプル
class dict: クラスのアトリビュートやメソッドの入ったディクショナリ
&lt;/pre&gt;

&lt;p&gt;
これを実行すると、以下のようになります。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;Running &amp;lt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-style: italic;"&gt;'__main__.Meta'&lt;/span&gt;&amp;gt;.__new__ &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; MyClass
Bases: ()
{&lt;span style="font-style: italic;"&gt;'__module__'&lt;/span&gt;: &lt;span style="font-style: italic;"&gt;'__main__'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'__qualname__'&lt;/span&gt;: &lt;span style="font-style: italic;"&gt;'MyClass'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'stuff'&lt;/span&gt;: 123, &lt;span style="font-style: italic;"&gt;'foo'&lt;/span&gt;: &amp;lt;function MyClass.foo at 0x10632f550&amp;gt;}
Running &amp;lt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-style: italic;"&gt;'__main__.Meta'&lt;/span&gt;&amp;gt;.__new__ &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; MySubclass
Bases: (&amp;lt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-style: italic;"&gt;'__main__.MyClass'&lt;/span&gt;&amp;gt;,)
{&lt;span style="font-style: italic;"&gt;'__module__'&lt;/span&gt;: &lt;span style="font-style: italic;"&gt;'__main__'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'__qualname__'&lt;/span&gt;: &lt;span style="font-style: italic;"&gt;'MySubclass'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'other'&lt;/span&gt;: 567, &lt;span style="font-style: italic;"&gt;'bar'&lt;/span&gt;: &amp;lt;function MySubclass.bar at 0x10632f5e0&amp;gt;}
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
このようにメタクラスでは、 &lt;code&gt;__new__&lt;/code&gt; メソッドにおいて関係クラスの情報を得たり修正することが出来るため、関連クラスの定義が完了する前に、そのパラメーターの有効性をチェックする目的で使えそうです。
&lt;/p&gt;

&lt;p&gt;
しかしこのユースケースでは、メタクラスを使わずに、Python 3.6以降で用意されている &lt;code&gt;__init_subclass__&lt;/code&gt; スペシャルクラスメソッドを使った方が良いです。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;BetterPolygon&lt;/span&gt;:
    &lt;span style="font-weight: bold; font-style: italic;"&gt;sides&lt;/span&gt; = &lt;span style="font-weight: bold; text-decoration: underline;"&gt;None&lt;/span&gt;  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12469;&amp;#12502;&amp;#12463;&amp;#12521;&amp;#12473;&amp;#12391;&amp;#25351;&amp;#23450;&amp;#24517;&amp;#35201;&lt;/span&gt;

    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__init_subclass__&lt;/span&gt;(cls):
        &lt;span style="font-weight: bold;"&gt;super&lt;/span&gt;().__init_subclass()
        &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; cls.sides &amp;lt; 3:
            &lt;span style="font-weight: bold;"&gt;raise&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;ValueError&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'Polygons need 3+ sides'&lt;/span&gt;)
    @&lt;span style="font-weight: bold;"&gt;classmethod&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;interior_angles&lt;/span&gt;(cls):
        &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; (cls.sides - 2) * 180
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
これを継承して、ポリゴンを作ります。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;Point&lt;/span&gt;(BetterPolygon):
    &lt;span style="font-weight: bold; font-style: italic;"&gt;sides&lt;/span&gt; = 1
&amp;gt;&amp;gt;&amp;gt;
Traceback ...
&lt;span style="font-weight: bold; text-decoration: underline;"&gt;ValueError&lt;/span&gt;: Polygons need 3+ sides
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
クラス &lt;code&gt;Point&lt;/code&gt; を作ろうとして &lt;code&gt;BetterPolygon.__init_subclass()&lt;/code&gt; にて例外が上がりました。
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;__init_subclass__&lt;/code&gt; を使うと、複数のクラスチェック用クラスを継承したり、更にはダイヤモンド継承をしてもうまくハンドルしてくれます。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;Top&lt;/span&gt;:
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__init_subclass__&lt;/span&gt;(cls):
        &lt;span style="font-weight: bold;"&gt;super&lt;/span&gt;().__init_subclass()
        &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(f&lt;span style="font-style: italic;"&gt;'Top for {cls}'&lt;/span&gt;)

&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;Left&lt;/span&gt;(Top):  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12371;&amp;#12428;&amp;#12434;&amp;#23450;&amp;#32681;&amp;#12377;&amp;#12427;&amp;#26178;&amp;#12395;Top.__init_subclass__()&amp;#12364;&amp;#21628;&amp;#12400;&amp;#12428;&amp;#12427;&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__init_subclass__&lt;/span&gt;(cls):
        &lt;span style="font-weight: bold;"&gt;super&lt;/span&gt;().__init_subclass()  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;Right&amp;#12395;&amp;#12390;&amp;#26082;&amp;#12395;&amp;#23455;&amp;#34892;&amp;#28168;&amp;#12415;&amp;#12398;&amp;#12383;&amp;#12417;&amp;#20309;&amp;#12418;&amp;#12375;&amp;#12394;&amp;#12356;&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(f&lt;span style="font-style: italic;"&gt;'Left for {cls}'&lt;/span&gt;)

&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;Right&lt;/span&gt;(Top):  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12371;&amp;#12428;&amp;#12434;&amp;#23450;&amp;#32681;&amp;#12377;&amp;#12427;&amp;#26178;&amp;#12395;Top.__init_subclass__()&amp;#12364;&amp;#21628;&amp;#12400;&amp;#12428;&amp;#12427;&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__init_subclass__&lt;/span&gt;(cls):
        &lt;span style="font-weight: bold;"&gt;super&lt;/span&gt;().__init_subclass()  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;Top.__init_subclass__()&amp;#12434;&amp;#21628;&amp;#12406;&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(f&lt;span style="font-style: italic;"&gt;'Right for {cls}'&lt;/span&gt;)

&lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12371;&amp;#12428;&amp;#12434;&amp;#23450;&amp;#32681;&amp;#12377;&amp;#12427;&amp;#26178;&amp;#12395;Right.__init_subclass__()&amp;#12364;&amp;#21628;&amp;#12400;&amp;#12428;&amp;#12427;&lt;/span&gt;
&lt;span style="font-weight: bold; font-style: italic;"&gt;#   &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12381;&amp;#12398;&amp;#20013;&amp;#12391;&amp;#12289;top.__init_subclass__()&amp;#12434;&amp;#21628;&amp;#12406;&lt;/span&gt;
&lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#27425;&amp;#12395;&amp;#12289;Left.__init_subclass__()&amp;#12364;&amp;#21628;&amp;#12400;&amp;#12428;&amp;#12427;&lt;/span&gt;
&lt;span style="font-weight: bold; font-style: italic;"&gt;#   &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12381;&amp;#12398;&amp;#20013;&amp;#12391;&amp;#12289;top.__init_subclass__()&amp;#12434;&amp;#21628;&amp;#12400;&amp;#12394;&amp;#12356;(Right&amp;#12364;&amp;#23455;&amp;#34892;&amp;#28168;&amp;#12415;)&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;Bottom&lt;/span&gt;(Left, Right):
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__init_subclass__&lt;/span&gt;(cls):
        &lt;span style="font-weight: bold;"&gt;super&lt;/span&gt;().__init_subclass()
        &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(f&lt;span style="font-style: italic;"&gt;'Bottom for {cls}'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
これを実行します。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;Top &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; &amp;lt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-style: italic;"&gt;'__main__.Left'&lt;/span&gt;&amp;gt;  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;Left&amp;#12363;&amp;#12425;Top&amp;#12398;__init_subclass__&amp;#23455;&amp;#34892;&lt;/span&gt;
Top &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; &amp;lt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-style: italic;"&gt;'__main__.Right'&lt;/span&gt;&amp;gt;  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;Right&amp;#12363;&amp;#12425;Top&amp;#12398;__init_subclass__&amp;#23455;&amp;#34892;&lt;/span&gt;
&lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;Bottom&amp;#12363;&amp;#12425;Right.__init_subclass__&amp;#23455;&amp;#34892;-&amp;gt;Top&amp;#12398;__init_subclass__&amp;#23455;&amp;#34892;&lt;/span&gt;
Top &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; &amp;lt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-style: italic;"&gt;'__main__.Bottom'&lt;/span&gt;&amp;gt;  
Right &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; &amp;lt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-style: italic;"&gt;'__main__.Bottom'&lt;/span&gt;&amp;gt;  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;Bottom&amp;#12363;&amp;#12425;Right.__init_subclass__&amp;#23455;&amp;#34892;&lt;/span&gt;
Left &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; &amp;lt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-style: italic;"&gt;'__main__.Bottom'&lt;/span&gt;&amp;gt;  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;Bottom&amp;#12363;&amp;#12425;Left.__init_subclass__&amp;#23455;&amp;#34892;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;code&gt;Bottom&lt;/code&gt; は左経由、右経由と両方から &lt;code&gt;Top.__init_subclass__&lt;/code&gt; を呼んでしまいそうですが、実際には、 &lt;code&gt;Top.__init_subclass__&lt;/code&gt; はRight/Leftクラスで合わせて一度しか呼ばれていないことがわかります。 &lt;code&gt;super().__init_subclass__()&lt;/code&gt; のお陰でダイヤモンド継承をうまく処理している証拠です。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orga36a0e7" class="outline-3"&gt;
&lt;h3 id="orga36a0e7"&gt;&lt;span class="section-number-3"&gt;2.6&lt;/span&gt; Item 49: ​__init_subclass__を使ってクラスを登録せよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-6"&gt;
&lt;p&gt;
モジュラーなPythonプログラムを作るために、次のような関数を使って作成したクラスを全て登録すること(class registration)は役に立つパターンの一つだそうです。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;registry&lt;/span&gt; = {}
&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;registr_class&lt;/span&gt;(target_class):
    &lt;span style="font-weight: bold; font-style: italic;"&gt;registry&lt;/span&gt;[target_class.&lt;span style="font-weight: bold;"&gt;__name__&lt;/span&gt;] = target_class
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
クラスを作ったら、必ず &lt;code&gt;register_class&lt;/code&gt; を呼ぶ必要があるのですが、忘れないようにこれを自動で行うために &lt;code&gt;__init_subclass__&lt;/code&gt; が使えます。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;Register&lt;/span&gt;():
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__init_subclass__&lt;/span&gt;(cls):
        &lt;span style="font-weight: bold;"&gt;super&lt;/span&gt;().__init_subclass__()
        register_class(cls)

&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;NewClass&lt;/span&gt;(Register):
    &lt;span style="font-weight: bold;"&gt;pass&lt;/span&gt;

&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(registry)
&amp;gt;&amp;gt;&amp;gt;
{&lt;span style="font-style: italic;"&gt;'NewClass'&lt;/span&gt;: &amp;lt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-style: italic;"&gt;'__main__.NewClass'&lt;/span&gt;&amp;gt;}
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
メタクラスも使えますが、 &lt;code&gt;__init_subclass__&lt;/code&gt; を使った方がクリアで理解しやすいとのことです。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1997640" class="outline-3"&gt;
&lt;h3 id="org1997640"&gt;&lt;span class="section-number-3"&gt;2.7&lt;/span&gt; Item 50: ​__set_name__を使ってクラスアトリビュートをannotateせよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-7"&gt;
&lt;p&gt;
&lt;code&gt;__set_name__&lt;/code&gt; は&lt;a href="https://www.python.org/dev/peps/pep-0487/"&gt;PEP 487&lt;/a&gt;で提唱され、Python 3.6以降に入っています。デスクリプターの問題(の一つ)は、それを含むクラスの情報を持たないことです。例えば、アトリビュートを &lt;code&gt;__dict__&lt;/code&gt; に登録するユースケースにおいて、 &lt;code&gt;__get__&lt;/code&gt; が呼ばれるまで登録するアトリビュートの名前を知りません。
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;__set_name__&lt;/code&gt; はクラス作成の際に、このデスクリプターをアタッチする全てのアトリビュートに対して呼ばれ、デスクリプターがアトリビュート名の知識を得ることが出来ます。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;Field&lt;/span&gt;:
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__init__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.name = &lt;span style="font-weight: bold; text-decoration: underline;"&gt;None&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.internal_name = &lt;span style="font-weight: bold; text-decoration: underline;"&gt;None&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__set_name__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, owner, name):
        &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;Called on class creation for each descriptor&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.name = name
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.internal_name = &lt;span style="font-style: italic;"&gt;'_'&lt;/span&gt; + name
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__get__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, instance , instance_type):
        &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; instance &lt;span style="font-weight: bold;"&gt;is&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;None&lt;/span&gt;:
            &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;getattr&lt;/span&gt;(instance, &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.internal_name, &lt;span style="font-style: italic;"&gt;''&lt;/span&gt;)
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__set__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, instance, value):
        &lt;span style="font-weight: bold;"&gt;setattr&lt;/span&gt;(instance, &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.internal_name, value)
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;code&gt;Field&lt;/code&gt; はデスクリプターです。 &lt;code&gt;__set_name__&lt;/code&gt; によって、このデスクリプターをアタッチするクラスのアトリビュート名をとその内部名を覚えておいてくれます。
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;FixedCustomer&lt;/span&gt;:
    &lt;span style="font-weight: bold; font-style: italic;"&gt;first_name&lt;/span&gt; = Field()
    &lt;span style="font-weight: bold; font-style: italic;"&gt;last_name&lt;/span&gt; = Filed()
    &lt;span style="font-weight: bold; font-style: italic;"&gt;prefix&lt;/span&gt; = Field()
    &lt;span style="font-weight: bold; font-style: italic;"&gt;suffix&lt;/span&gt; = Field()

&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold; font-style: italic;"&gt;cust&lt;/span&gt; = FixedCustomer()
&amp;gt;&amp;gt;&amp;gt; cust.&lt;span style="font-weight: bold;"&gt;__dict__&lt;/span&gt;
{}
&amp;gt;&amp;gt;&amp;gt; cust.first_name.&lt;span style="font-weight: bold;"&gt;__dict__&lt;/span&gt;  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#22793;&amp;#25968;&amp;#21517;&amp;#12399;&amp;#12487;&amp;#12473;&amp;#12463;&amp;#12522;&amp;#12503;&amp;#12479;&amp;#12540;Field&amp;#20869;&amp;#12398;__dict__&amp;#12395;&amp;#20445;&amp;#25345;&lt;/span&gt;
{&lt;span style="font-style: italic;"&gt;'name'&lt;/span&gt;: &lt;span style="font-style: italic;"&gt;'first_name'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'internal_name'&lt;/span&gt;: &lt;span style="font-style: italic;"&gt;'_first_name'&lt;/span&gt;}
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold; font-style: italic;"&gt;cust.first_name&lt;/span&gt; = &lt;span style="font-style: italic;"&gt;'Joy'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; cust.&lt;span style="font-weight: bold;"&gt;__dict__&lt;/span&gt;  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#22793;&amp;#25968;&amp;#12398;&amp;#20516;&amp;#12399;&amp;#21508;cust&amp;#12458;&amp;#12502;&amp;#12472;&amp;#12455;&amp;#12463;&amp;#12488;&amp;#12398;__dict__&amp;#12395;&amp;#20445;&amp;#25345;&lt;/span&gt;
{&lt;span style="font-style: italic;"&gt;'_first_name'&lt;/span&gt;: &lt;span style="font-style: italic;"&gt;'Joy'&lt;/span&gt;}
&amp;gt;&amp;gt;&amp;gt; cust.first_name.&lt;span style="font-weight: bold;"&gt;__dict__&lt;/span&gt;
{&lt;span style="font-style: italic;"&gt;'name'&lt;/span&gt;: &lt;span style="font-style: italic;"&gt;'first_name'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'internal_name'&lt;/span&gt;: &lt;span style="font-style: italic;"&gt;'_first_name'&lt;/span&gt;}
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
first_nameを設定した時に、 &lt;code&gt;__set__&lt;/code&gt; の指定通りに内部名が &lt;code&gt;dict&lt;/code&gt; に登録されていることがわかります。
&lt;/p&gt;

&lt;p&gt;
first_nameは実際にはそのクラスのアトリビュートではなく、デスクリプター内に保持されている情報であるため、当該クラスオブジェクトの &lt;code&gt;__dict__&lt;/code&gt; には登録されていません。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org449094d" class="outline-3"&gt;
&lt;h3 id="org449094d"&gt;&lt;span class="section-number-3"&gt;2.8&lt;/span&gt; Item 51: クラス拡張を組み合わせるために、メタクラスよりもクラスデコレーターを使え&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-8"&gt;
&lt;p&gt;
クラスの全てのメソッドに対し、ヘルパーを使って引数や戻り値、上がる割り込みをプリントすることを考えます。全てのメソッドにデコレーターを付けることは面倒です。メタクラスを使って仕込むことも、対象クラスの親クラスが別のメタクラスを既に使っていた場合に問題となります。
&lt;/p&gt;

&lt;p&gt;
これを解決するために、クラスデコレーターがあります。クラスデコレーターはクラス定義の前に &lt;code&gt;@&amp;lt;decorator_name&amp;gt;&lt;/code&gt; を付けることで機能します。
&lt;/p&gt;

&lt;p&gt;
まずはシンプルなクラスデコレーターの例です。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;my_class_decorator&lt;/span&gt;(klass):
    &lt;span style="font-weight: bold; font-style: italic;"&gt;klass.extra_param&lt;/span&gt; = &lt;span style="font-style: italic;"&gt;'hello'&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; klass

&lt;span style="font-weight: bold; text-decoration: underline;"&gt;@my_class_decorator&lt;/span&gt;
&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;MyClass&lt;/span&gt;:
    &lt;span style="font-weight: bold;"&gt;pass&lt;/span&gt;

&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(MyClass)
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(MyClass.extra_param)
&amp;gt;&amp;gt;&amp;gt;
&amp;lt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-style: italic;"&gt;'__main__.MyClass'&lt;/span&gt;&amp;gt;
hello
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
デコレーターによって、 &lt;code&gt;extra_param = 'hello'&lt;/code&gt; が設定されています。
&lt;/p&gt;

&lt;p&gt;
次は上で述べたデバッグ用デコレーターです。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; functools &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; wraps

&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;trace_func&lt;/span&gt;(func):
    &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;hasattr&lt;/span&gt;(func, &lt;span style="font-style: italic;"&gt;'tracing'&lt;/span&gt;):  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;Only decorate once&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; func

    &lt;span style="font-weight: bold; text-decoration: underline;"&gt;@wraps&lt;/span&gt;(func)
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;wrapper&lt;/span&gt;(*args, **kwargs):
        &lt;span style="font-weight: bold; font-style: italic;"&gt;result&lt;/span&gt; = &lt;span style="font-weight: bold; text-decoration: underline;"&gt;None&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;try&lt;/span&gt;:
            &lt;span style="font-weight: bold; font-style: italic;"&gt;result&lt;/span&gt; = func(*args, **kwargs)
            &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; result
        &lt;span style="font-weight: bold;"&gt;except&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;Exception&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;as&lt;/span&gt; e:
            &lt;span style="font-weight: bold; font-style: italic;"&gt;result&lt;/span&gt; = e
            &lt;span style="font-weight: bold;"&gt;raise&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;finally&lt;/span&gt;:
            &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(f&lt;span style="font-style: italic;"&gt;'{func.__name__}({args!r}, {kwargs!r}) -&amp;gt; '&lt;/span&gt;
                  f&lt;span style="font-style: italic;"&gt;'{result!r}'&lt;/span&gt;)

    &lt;span style="font-weight: bold; font-style: italic;"&gt;wrapper.tracing&lt;/span&gt; = &lt;span style="font-weight: bold; text-decoration: underline;"&gt;True&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; wrapper
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;code&gt;functools&lt;/code&gt; の &lt;code&gt;wraps&lt;/code&gt; は関数をラッパーするデコレーターです。&lt;a href="./effective2.html"&gt;Item 26&lt;/a&gt;で学んでいました。 &lt;code&gt;try&lt;/code&gt; ブロックの &lt;code&gt;finally&lt;/code&gt; は、リターンしようが、例外が上がろうが、実行されます。
&lt;/p&gt;

&lt;p&gt;
次に示す &lt;code&gt;trace&lt;/code&gt; はクラスデコレーターとして機能する関数です。 &lt;code&gt;dir&lt;/code&gt; ビルトイン関数によってデコレートするクラスのアトリビュート一式(メソッドなど含む)の名前(キー)を取得し、これが &lt;code&gt;trace_types&lt;/code&gt; に含まれるタイプなら(ie, メソッド等だったら) &lt;code&gt;trace_func&lt;/code&gt; でラップして、ラップしたものを &lt;code&gt;setattr&lt;/code&gt; で &lt;code&gt;__dict__&lt;/code&gt; に設定します。つまり、そのメソッドの代わりにラップしたものが呼ばれるようになります。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; types
&lt;span style="font-weight: bold; font-style: italic;"&gt;trace_types&lt;/span&gt; = (
    types.MethodType,
    types.FunctionType,
    types.BuiltinFunctionType,
    types.BuiltinMethodType,
    types.MethodDescriptorType,
    types.ClassMethodDescriptorType)

&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;trace&lt;/span&gt;(klass):
    &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; key &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;dir&lt;/span&gt;(klass):
        &lt;span style="font-weight: bold; font-style: italic;"&gt;value&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;getattr&lt;/span&gt;(klass, key)
        &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;isinstance&lt;/span&gt;(value, trace_types):
            &lt;span style="font-weight: bold; font-style: italic;"&gt;wrapped&lt;/span&gt; = trace_func(value)
            &lt;span style="font-weight: bold;"&gt;setattr&lt;/span&gt;(klass, key, wrapped)
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; klass
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;code&gt;@trace&lt;/code&gt; クラスデコレーターで、 &lt;code&gt;dict&lt;/code&gt; を継承したクラス &lt;code&gt;TraceDict&lt;/code&gt; をデコレートします。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&amp;gt;&amp;gt;&amp;gt; @trace
... &lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;TraceDict&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;dict&lt;/span&gt;):
...     &lt;span style="font-weight: bold;"&gt;pass&lt;/span&gt;
... 
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold; font-style: italic;"&gt;trace_dict&lt;/span&gt; = TraceDict([(&lt;span style="font-style: italic;"&gt;'hi'&lt;/span&gt;, 1)])
__new__((&amp;lt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-style: italic;"&gt;'__main__.TraceDict'&lt;/span&gt;&amp;gt;, [(&lt;span style="font-style: italic;"&gt;'hi'&lt;/span&gt;, 1)]), {}) -&amp;gt; {}
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold; font-style: italic;"&gt;trace_dict&lt;/span&gt;[&lt;span style="font-style: italic;"&gt;'there'&lt;/span&gt;] = 2
&amp;gt;&amp;gt;&amp;gt; trace_dict[&lt;span style="font-style: italic;"&gt;'hi'&lt;/span&gt;]
__getitem__(({&lt;span style="font-style: italic;"&gt;'hi'&lt;/span&gt;: 1, &lt;span style="font-style: italic;"&gt;'there'&lt;/span&gt;: 2}, &lt;span style="font-style: italic;"&gt;'hi'&lt;/span&gt;), {}) -&amp;gt; 1
1
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold;"&gt;try&lt;/span&gt;:
...     trace_dict[&lt;span style="font-style: italic;"&gt;'does not exist'&lt;/span&gt;]
... &lt;span style="font-weight: bold;"&gt;except&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;KeyError&lt;/span&gt;:
...     &lt;span style="font-weight: bold;"&gt;pass&lt;/span&gt;  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;Expected&lt;/span&gt;
... 
__getitem__(({&lt;span style="font-style: italic;"&gt;'hi'&lt;/span&gt;: 1, &lt;span style="font-style: italic;"&gt;'there'&lt;/span&gt;: 2}, &lt;span style="font-style: italic;"&gt;'does not exist'&lt;/span&gt;), {}) -&amp;gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;KeyError&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'does not exist'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
実行結果を見ると、 &lt;code&gt;trace_func&lt;/code&gt; 内のprint文は &lt;code&gt;TraceDict&lt;/code&gt; がnewされた時と、キー'hi', 'doesn not exist'の値をそれぞれ参照しようとしたときに動いています。'there'に値2を入れた時に動いていないのはどうしてでしょうか。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold;"&gt;isinstance&lt;/span&gt;(trace_dict.__new__, types.MethodType)
&lt;span style="font-weight: bold; text-decoration: underline;"&gt;True&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold;"&gt;isinstance&lt;/span&gt;(trace_dict.__getitem__, types.MethodType)
&lt;span style="font-weight: bold; text-decoration: underline;"&gt;True&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold;"&gt;isinstance&lt;/span&gt;(trace_dict.__setitem__, types.MethodType)
&lt;span style="font-weight: bold; text-decoration: underline;"&gt;False&lt;/span&gt;  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12354;&amp;#12428;!?&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; trace_dict.__new__
&amp;lt;bound method &lt;span style="font-weight: bold;"&gt;dict&lt;/span&gt;.__new__ of {&lt;span style="font-style: italic;"&gt;'hi'&lt;/span&gt;: 1, &lt;span style="font-style: italic;"&gt;'there'&lt;/span&gt;: 2}&amp;gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold;"&gt;type&lt;/span&gt;(trace_dict.__new__)
&amp;lt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-style: italic;"&gt;'method'&lt;/span&gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold;"&gt;type&lt;/span&gt;(trace_dict.__getitem__)
&amp;lt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-style: italic;"&gt;'method'&lt;/span&gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold;"&gt;type&lt;/span&gt;(trace_dict.__setitem__)
&amp;lt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-style: italic;"&gt;'method-wrapper'&lt;/span&gt;&amp;gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;code&gt;__new__, __getitem__&lt;/code&gt; 共にmethodタイプなのに対して、 &lt;code&gt;__setitem__&lt;/code&gt; はmethod-wrapperという異なるタイプだからのようです。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Python"></category><category term="Python"></category></entry><entry><title>Effective Python一人輪読会(Item 19 to 36)</title><link href="http://achiwa912.github.io/effective2.html" rel="alternate"></link><published>2020-08-18T00:00:00-04:00</published><updated>2021-12-03T00:00:00-05:00</updated><author><name>きょうす</name></author><id>tag:achiwa912.github.io,2020-08-18:/effective2.html</id><summary type="html">Effective Python読書メモ2</summary><content type="html">&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org2f41e6e"&gt;1. Chapter 3: 関数&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org820f816"&gt;1.1. Item 19: 関数が複数の値を返すとき、4つ以上の変数にunpackするな&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org17b0d41"&gt;1.2. Item 20: Noneを返すくらいなら例外を上げよ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgb8964c5"&gt;1.3. Item 21: Closuresが変数のスコープにどう影響するかを知っておけ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org74faee5"&gt;1.4. Item 22: 可変数のpositional argumentsを使って見やすくしろ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org0027aa8"&gt;1.5. Item 23: オプションとなる挙動はキーワード引数で与えよ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgd8af33d"&gt;1.6. Item 24: 動的なデフォルト引数を指定するときはNoneとDocstringsを使え&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org027f701"&gt;1.7. Item 25: キーワードオンリー引数、位置オンリー引数を使って、明確さを強制せよ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org558a018"&gt;1.8. Item 26: 関数のデコレーターをfunctools.wrapsを使って定義せよ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgae97b2d"&gt;2. Chapter 4: Comprehensionsとジェネレーター&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orge8f1590"&gt;2.1. Item 27: mapとfilterの代わりにcomprehensionsを使え&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org05c19ba"&gt;2.2. Item 28: 3つ以上のコントロールsubexpressionsをcomprehensionsで使うな&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgca2d3f6"&gt;2.3. Item 29: Assignment表現を使って、comprehensions内での繰り返しを避けよ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org4025dc2"&gt;2.4. Item 30: リストを返すくらいならジェネレーターを考慮せよ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org849f4c6"&gt;2.5. Item 31: 引数をたどるときには保守的になれ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org0fe05e7"&gt;2.6. Item 32: 大きなリストcomprehensionsの代わりにジェネレーターexpressionsを考えよ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org18181fd"&gt;2.7. Item 33: yield fromを使って複数のジェネレーターを組み合わせよ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org61afc26"&gt;2.8. Item 34: ジェネレーターにsendを使ってデータを送ってはいけない&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgf146ab2"&gt;2.9. Item 35: throwで例外を投げてジェネレータの状態遷移を起こすな&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgc1d6aec"&gt;2.10. Item 36: Iteratorやジェネレーターを使うときにはitertoolsの使用を検討せよ&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org109feb6"&gt;2.10.1. Iteratorsをつなぐ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org7042ef7"&gt;2.10.2. Iteratorからアイテムをフィルタする&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org35a3757"&gt;2.10.3. 複数iteratorsのアイテムを結びつける&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org2f41e6e" class="outline-2"&gt;
&lt;h2 id="org2f41e6e"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Chapter 3: 関数&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org820f816" class="outline-3"&gt;
&lt;h3 id="org820f816"&gt;&lt;span class="section-number-3"&gt;1.1&lt;/span&gt; Item 19: 関数が複数の値を返すとき、4つ以上の変数にunpackするな&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-1"&gt;
&lt;p&gt;
うっかり順番を間違えたりするので。catch-allの星付きexpression(eg, *others)を使うか、namedtupleを使う。
&lt;/p&gt;

&lt;p&gt;
namedtupleについては&lt;a href="https://dbader.org/blog/writing-clean-python-with-namedtuples"&gt;ここ&lt;/a&gt;の説明がわかりやすかったです。(逆にIntroducing Pythonの説明はさっぱり。。。) 以下のように使います。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; collections &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; namedtuple
&lt;span style="font-weight: bold; font-style: italic;"&gt;Car&lt;/span&gt; = namedtuple(&lt;span style="font-style: italic;"&gt;'Car'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'color milage'&lt;/span&gt;)
&amp;#12414;&amp;#12383;&amp;#12399;
&lt;span style="font-weight: bold; font-style: italic;"&gt;Car&lt;/span&gt; = namedtuple(&lt;span style="font-style: italic;"&gt;'Car'&lt;/span&gt;, [&lt;span style="font-style: italic;"&gt;'color'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'milage'&lt;/span&gt;])
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
前者の文字列部分(&lt;code&gt;'color milage'&lt;/code&gt;)は内部で &lt;code&gt;split()&lt;/code&gt; されてリストになるため、後者と等価だそうです。
&lt;/p&gt;

&lt;p&gt;
メソッドの無いimmutableなクラスのように使えます。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;my_car&lt;/span&gt; = Car(&lt;span style="font-style: italic;"&gt;'red'&lt;/span&gt;, 3812.4)
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
namedtupleは内部ではクラスとして表現されていますが、メモリ効率は良いそうです。
&lt;/p&gt;


&lt;p&gt;
複数の値を返す関数は、それらをタプルにして返すことは知りませんでした。関数の呼び出し元が複数の変数にunpackする時にタプルから取り出します。
&lt;/p&gt;

&lt;p&gt;
もう一つ。日本語ではあまり馴染みがありませんが、英語ではよく使うmaiden(中央値)。要素が偶数の場合にどうするのか知りませんでした。真ん中の二つの平均を取るのですか。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; count % 2 == 0:
    &lt;span style="font-weight: bold; font-style: italic;"&gt;lower&lt;/span&gt; = sorted_numbers[middle - 1]
    &lt;span style="font-weight: bold; font-style: italic;"&gt;upper&lt;/span&gt; = sorted_numbers[middle]
    &lt;span style="font-weight: bold; font-style: italic;"&gt;median&lt;/span&gt; = (lower + upper) / 2
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org17b0d41" class="outline-3"&gt;
&lt;h3 id="org17b0d41"&gt;&lt;span class="section-number-3"&gt;1.2&lt;/span&gt; Item 20: Noneを返すくらいなら例外を上げよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-2"&gt;
&lt;p&gt;
&lt;code&gt;None&lt;/code&gt; や0, 空の文字列, etc.は全て &lt;code&gt;False&lt;/code&gt; と解釈されるので、if文などでの判定でうっかり間違いやすい。
&lt;/p&gt;

&lt;p&gt;
適切な例外(そのままでなく)を上げて、それをドキュメントに書く。更にtype annotationsする。
&lt;/p&gt;
&lt;pre class="example"&gt;
def careful_divide(a: float, b: float) -&amp;gt; float:
    """Divides a by b.

    Raises:
	ValueError: When the inputs cannot be divided.
    """"
    try:
	return a / b
    except ZeroDivisionError as e:
	raise ValueError('Invalid inputs')
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb8964c5" class="outline-3"&gt;
&lt;h3 id="orgb8964c5"&gt;&lt;span class="section-number-3"&gt;1.3&lt;/span&gt; Item 21: Closuresが変数のスコープにどう影響するかを知っておけ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-3"&gt;
&lt;p&gt;
えーっと、closuresって何でしたっけ? Introducing Pythonを読んだときに消化不良のまま終わったような気が。。
&lt;/p&gt;

&lt;p&gt;
30分ほど調べてみました。&lt;a href="https://www.programiz.com/python-programming/closure"&gt;ここ&lt;/a&gt;の定義が一番しっくり来ました。
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;関数と、そのインナー関数がある&lt;/li&gt;
&lt;li&gt;インナー関数は、外側の関数で定義された変数を参照する&lt;/li&gt;
&lt;li&gt;外側の関数は、インナー関数を戻り値として返す&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;print_msg&lt;/span&gt;(msg):
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;printer&lt;/span&gt;():    &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;inner function&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(msg)    &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;msg was defined in the enclosing function&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; printer    &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;return the inner function&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
これを使うには、
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;another&lt;/span&gt; = print_msg(&lt;span style="font-style: italic;"&gt;"Hello"&lt;/span&gt;)
another()
&amp;gt;&amp;gt;&amp;gt;
Hello
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
メリットの説明は&lt;a href="http://www.trytoprogram.com/python-programming/python-closures/"&gt;ここ&lt;/a&gt;がわかりやすかったです。
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;コールバックとして定義されるため、ある意味データ隠蔽(hiding)に使える&lt;/li&gt;
&lt;li&gt;ハードコードされた定数や文字列の代わりに使える&lt;/li&gt;
&lt;li&gt;コードに関数が1, 2個しかないときに有効&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
この節では、やたらと小難しい具体例が続きますが、言っていることは単純です: インナー関数でアサインしている変数のスコープは、インナー関数で閉じる(ie, 外側の関数に届かない)。そして、もし外側の関数にスコープを広げたい場合は &lt;code&gt;nonlocal&lt;/code&gt; を付けます。
&lt;/p&gt;

&lt;p&gt;
この &lt;code&gt;nonlocal&lt;/code&gt; の使い方にも注意が必要で、長い関数だと &lt;code&gt;nonlocal&lt;/code&gt; であることがわかりづらくなります。単純な関数以外ではヘルパークラスにするのがよい、とのこと。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;SomeClass&lt;/span&gt;:
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__call__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, x, y):
&lt;span style="font-weight: bold; font-style: italic;"&gt;sc&lt;/span&gt; = SomeClass()
sc(5, 7)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;__call__&amp;#12364;&amp;#20351;&amp;#12431;&amp;#12428;&amp;#12427;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;code&gt;__call__()&lt;/code&gt; スペシャル関数は、クラスを関数であるかのように振る舞わせる関数。なお、この大事なところでKindle版は最後の &lt;code&gt;return (1, x)&lt;/code&gt; のインデントがずれています。しかも、Click here to view code imageがここには何故か無い。どうしろと。。。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org74faee5" class="outline-3"&gt;
&lt;h3 id="org74faee5"&gt;&lt;span class="section-number-3"&gt;1.4&lt;/span&gt; Item 22: 可変数のpositional argumentsを使って見やすくしろ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-4"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;可変長の引数(0個含む)は関数の定義def文において &lt;code&gt;*args&lt;/code&gt; のようにアスタリスク付きで書くことで実現できる&lt;/li&gt;
&lt;li&gt;関数の呼び出し側で、 &lt;code&gt;*vars&lt;/code&gt; としてアスタリスクを付けて引数を指定することで、リスト等のシーケンスの中身を(展開して)渡せる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
二つ目において、呼び出し側がgeneratorにアスタリスクを付けると、呼び出しのたびにgeneratorを全て展開してしまうため、メモリ圧迫＆クラッシュに注意、とのことです。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0027aa8" class="outline-3"&gt;
&lt;h3 id="org0027aa8"&gt;&lt;span class="section-number-3"&gt;1.5&lt;/span&gt; Item 23: オプションとなる挙動はキーワード引数で与えよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-5"&gt;
&lt;p&gt;
ここは特にコメントなしです。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd8af33d" class="outline-3"&gt;
&lt;h3 id="orgd8af33d"&gt;&lt;span class="section-number-3"&gt;1.6&lt;/span&gt; Item 24: 動的なデフォルト引数を指定するときはNoneとDocstringsを使え&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-6"&gt;
&lt;p&gt;
例:
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;log&lt;/span&gt;(message, when=&lt;span style="font-weight: bold; text-decoration: underline;"&gt;None&lt;/span&gt;):
    &amp;#8220;&amp;#8220;&amp;#8220;Log a message &lt;span style="font-weight: bold;"&gt;with&lt;/span&gt; a timestamp.
    Args:
        message: Message to &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;.
        when: datetime of when the message occurred.
            Defaults to the present time.
    &amp;#8221;&amp;#8221;&amp;#8221;
    &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; when &lt;span style="font-weight: bold;"&gt;is&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;None&lt;/span&gt;:
        &lt;span style="font-weight: bold; font-style: italic;"&gt;when&lt;/span&gt; = datetime.now()
    &lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(f&lt;span style="font-style: italic;"&gt;'{when}: {message}'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
上の関数において、whenのデフォルトはNoneとしておき、関数の中で現在時刻を設定しています。def文で &lt;code&gt;when=datetime.now()&lt;/code&gt; を書いても機能しないのは、 &lt;code&gt;datetime.now()&lt;/code&gt; が評価されるのが関数のロード時のみだからです。同様に、 &lt;code&gt;{}&lt;/code&gt; , &lt;code&gt;[]&lt;/code&gt; のような動的な値を使うときにも &lt;code&gt;None&lt;/code&gt; をデフォルト値として置きます。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org027f701" class="outline-3"&gt;
&lt;h3 id="org027f701"&gt;&lt;span class="section-number-3"&gt;1.7&lt;/span&gt; Item 25: キーワードオンリー引数、位置オンリー引数を使って、明確さを強制せよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-7"&gt;
&lt;p&gt;
&lt;code&gt;float('inf')&lt;/code&gt; は無限大を意味するそうです。
&lt;/p&gt;

&lt;p&gt;
引数リストにあるアスタリスク &lt;code&gt;*&lt;/code&gt; は、位置引数の終わりと、キーワードオンリー引数の始まりを強制します。また、Python 3.8より、引数リストにある &lt;code&gt;/&lt;/code&gt; は、これよりも前の引数は位置オンリー引数であることを強制します。例えば、
&lt;/p&gt;
&lt;pre class="example"&gt;
def func(num, div, /, *, ov_flag=False, zd_flag=True):
&lt;/pre&gt;

&lt;p&gt;
とあったときに、
&lt;/p&gt;
&lt;pre class="example"&gt;
func(10, 2, True, False)
func(num=10, div=2)
&lt;/pre&gt;

&lt;p&gt;
などと呼び出すとTypeErrorとなります。
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;/&lt;/code&gt; と &lt;code&gt;*&lt;/code&gt; に挟まれた引数は、位置引数としてもキーワード引数としてもどちらでもよいそうです。これがPythonのデフォルトです。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org558a018" class="outline-3"&gt;
&lt;h3 id="org558a018"&gt;&lt;span class="section-number-3"&gt;1.8&lt;/span&gt; Item 26: 関数のデコレーターをfunctools.wrapsを使って定義せよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-8"&gt;
&lt;p&gt;
コードスニップを見ていると、見慣れない表現が。。。
&lt;/p&gt;
&lt;pre class="example"&gt;
{args!r}
&lt;/pre&gt;

&lt;p&gt;
この &lt;code&gt;!r&lt;/code&gt; は、 &lt;code&gt;__repr__()&lt;/code&gt; で解釈せよ、という意味だそうです。 f'This string {name!r} is a good one' のように使います。 &lt;code&gt;!r&lt;/code&gt; は検索しづらいですね。。
&lt;/p&gt;

&lt;p&gt;
この項目は難しいです。ぱっと読んでも意味がよくわかりません。decoratorの問題らしいので検索してみます。&lt;a href="https://lerner.co.il/2019/05/05/making-your-python-decorators-even-better-with-functool-wraps/"&gt;ここ&lt;/a&gt;の説明がわかりやすかったです。なるほど、 &lt;code&gt;__name__&lt;/code&gt; や &lt;code&gt;__doc__&lt;/code&gt; を表示したり &lt;code&gt;help()&lt;/code&gt; を使うと、wrapper関数の情報が表示されてしまうようです。
&lt;/p&gt;

&lt;p&gt;
その解決策がfunctools.wrapsを使うことで、
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; functools &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; wraps

&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;mydeco&lt;/span&gt;(func):
    &lt;span style="font-weight: bold; text-decoration: underline;"&gt;@wraps&lt;/span&gt;(func)
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;wrapper&lt;/span&gt;(*args, *kwargs):
        &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; f&lt;span style="font-style: italic;"&gt;'{func(args, **kwargs)}!!!'&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; wrapper
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
こうすると
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
By applying this “wraps” decorator to our inner function, we copy over func’s name, docstring, and signature to our inner function, avoiding the issues that we had seen before:
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
そういうことでしたか。
&lt;/p&gt;

&lt;p&gt;
デコレーターについて補足します。上記code snippetは以下と等価です。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; functools &lt;span style="font-weight: bold;"&gt;import&lt;/span&gt; wraps

&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;mydeco&lt;/span&gt;(func):
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;wrapper&lt;/span&gt;(*args, *kwargs):
        &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; f&lt;span style="font-style: italic;"&gt;'{func(args, **kwargs)}!!!'&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; wrapper
&lt;span style="font-weight: bold; font-style: italic;"&gt;func&lt;/span&gt; = mydeco(func)
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
最後の行で、 &lt;code&gt;mydeco&lt;/code&gt; はインナー関数 &lt;code&gt;wrapper&lt;/code&gt; を返すので、以降 &lt;code&gt;func()&lt;/code&gt; を呼ぶとインナー関数 &lt;code&gt;wrapper()&lt;/code&gt; が呼ばれることになります。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgae97b2d" class="outline-2"&gt;
&lt;h2 id="orgae97b2d"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; Chapter 4: Comprehensionsとジェネレーター&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
&lt;a href="https://jeffknupp.com/blog/2013/04/07/improve-your-python-yield-and-generators-explained/#:~:text=A%20Python%20generator%20is%20a,as%20the%20%22generated%22%20value."&gt;ここ&lt;/a&gt;を参考にして、ジェネレーターについて整理します。(このリンクはかなり詳細に説明しています)
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;ジェネレーター関数は、 &lt;code&gt;return&lt;/code&gt; の代わりに &lt;code&gt;yield&lt;/code&gt; を持つ関数で、ジェネレーター(=ジェネレーターiterator)を作る。&lt;/li&gt;
&lt;li&gt;ジェネレーターは特定のタイプのiterator。iteratorとして機能するために、ジェネレーターは &lt;code&gt;__next__()&lt;/code&gt; メソッドを持つ。&lt;/li&gt;
&lt;li&gt;ジェネレーターから次の値を得るには、iterators: &lt;code&gt;next()&lt;/code&gt; を使う。( &lt;code&gt;next()&lt;/code&gt; は &lt;code&gt;__next__()&lt;/code&gt; メソッドを呼ぶ)&lt;/li&gt;
&lt;li&gt;ジェネレーターは &lt;code&gt;next()&lt;/code&gt; の呼び主に対して、 &lt;code&gt;yield&lt;/code&gt; 文で値を返す。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
ジェネレーターの使い方
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;一通りたどるとジェネレーターは &lt;code&gt;StopIteration&lt;/code&gt; 例外を上げる。これは普通のiteratorと同じ挙動で、for文などでは問題視せずにサイレントに抜ける。&lt;/li&gt;
&lt;li&gt;その後、もう一度ジェネレーターを呼ぶと &lt;code&gt;StopIteration&lt;/code&gt; 例外を上げる。&lt;/li&gt;
&lt;li&gt;ジェネレーター関数をもう一度呼んで、新たなジェネレーターを作り直すことができる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;


&lt;div id="outline-container-orge8f1590" class="outline-3"&gt;
&lt;h3 id="orge8f1590"&gt;&lt;span class="section-number-3"&gt;2.1&lt;/span&gt; Item 27: mapとfilterの代わりにcomprehensionsを使え&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-1"&gt;
&lt;p&gt;
&lt;code&gt;map()&lt;/code&gt; ビルトイン関数は知りませんでした。&lt;a href="https://www.geeksforgeeks.org/python-map-function/"&gt;ここ&lt;/a&gt;によると、第二引数のiterable(例: リスト)の各アイテムに、第一引数の関数を適用して、iterableなmapオブジェクトを返す、とのこと。
&lt;/p&gt;
&lt;pre class="example"&gt;
mapobj = map(lambda x: x ** 2, somelist)
&lt;/pre&gt;


&lt;p&gt;
&lt;code&gt;filter&lt;/code&gt; ビルトイン関数も知りませんでしたが、名前から明らかです。
&lt;/p&gt;
&lt;pre class="example"&gt;
filter(lambda x: x % 2 == 0, somelist)
&lt;/pre&gt;

&lt;p&gt;
&lt;code&gt;filter&lt;/code&gt; もフィルターされたiteratorを返します。
&lt;/p&gt;

&lt;p&gt;
両方とも返すのはiteratorですが、リストcomprehensionsと似てますね。
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;map&lt;/code&gt; と &lt;code&gt;filter&lt;/code&gt; を組み合わせると読みづらいので、スッキリとかけるcomprehensionsを使え、ということでした。 &lt;code&gt;somelist&lt;/code&gt; の中から2で割りきれる要素のみ2乗したいとき、
&lt;/p&gt;
&lt;pre class="example"&gt;
map(lambda x: x**2, filter(lambda x: x % 2 == 0, somelist))
&lt;/pre&gt;

&lt;p&gt;
これが、
&lt;/p&gt;
&lt;pre class="example"&gt;
[x**2 for x in somelist if x % 2 == 0]
&lt;/pre&gt;

&lt;p&gt;
。。。確かに。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org05c19ba" class="outline-3"&gt;
&lt;h3 id="org05c19ba"&gt;&lt;span class="section-number-3"&gt;2.2&lt;/span&gt; Item 28: 3つ以上のコントロールsubexpressionsをcomprehensionsで使うな&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-2"&gt;
&lt;p&gt;
初級者的にキツい表現が出ました。やりたいことは、二次元にネストされたリストであるmatrixの中身をflattenする(一次元にする)、です。えーと、ネストされた &lt;code&gt;for&lt;/code&gt; は左から解釈するらしいので、、
&lt;/p&gt;
&lt;pre class="example"&gt;
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flat = [x for row in matrix for x in row]
&lt;/pre&gt;

&lt;p&gt;
最初の &lt;code&gt;for&lt;/code&gt; で &lt;code&gt;matrix&lt;/code&gt; の各アイテム= &lt;code&gt;row&lt;/code&gt; を取り出して、次の &lt;code&gt;for&lt;/code&gt; で &lt;code&gt;row&lt;/code&gt; の中の &lt;code&gt;x&lt;/code&gt; を取り出し、これを使ってリストを作る、ということでした。
&lt;/p&gt;
&lt;pre class="example"&gt;
print(flat)
&amp;gt;&amp;gt;&amp;gt;
[1, 2, 3, 4, 5, 6, 7, 8, 9]
&lt;/pre&gt;

&lt;p&gt;
これは便利そうです。
&lt;/p&gt;

&lt;p&gt;
次は、先ほど &lt;code&gt;matrix&lt;/code&gt; の要素を二乗する(flattenしない)場合。
&lt;/p&gt;
&lt;pre class="example"&gt;
squared = [[x ** 2 for x in row] for row in matrix]
print(squared)
&amp;gt;&amp;gt;&amp;gt;
[[1, 4, 9], [16, 25, 36], [49, 64, 81]]
&lt;/pre&gt;

&lt;p&gt;
このリストcomprehensionのリストが二重になっているので、flattenしないのですね。
&lt;/p&gt;

&lt;p&gt;
お題のコントロールsubexpressionsは、 &lt;code&gt;for&lt;/code&gt; によるループだけでなく、 &lt;code&gt;for&lt;/code&gt; に付けられる &lt;code&gt;if&lt;/code&gt; も指していました。下の例は &lt;code&gt;for&lt;/code&gt; が二つと &lt;code&gt;if&lt;/code&gt; があるのでアウト。
&lt;/p&gt;
&lt;pre class="example"&gt;
[x for wor in matrix for x in row if x % 2 == 0]
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgca2d3f6" class="outline-3"&gt;
&lt;h3 id="orgca2d3f6"&gt;&lt;span class="section-number-3"&gt;2.3&lt;/span&gt; Item 29: Assignment表現を使って、comprehensions内での繰り返しを避けよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-3"&gt;
&lt;p&gt;
Assignment expressions - Walrusのやつです(&lt;code&gt;:=&lt;/code&gt;)。これは便利なので、是非とも使っていきたいと思います。
&lt;/p&gt;

&lt;p&gt;
次のようなストックがあって、
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;stock&lt;/span&gt; = {
    &lt;span style="font-style: italic;"&gt;'nails'&lt;/span&gt;: 125,
    &lt;span style="font-style: italic;"&gt;'screws'&lt;/span&gt;: 35,
    &lt;span style="font-style: italic;"&gt;'wingnuts'&lt;/span&gt;: 8,
    &lt;span style="font-style: italic;"&gt;'washers'&lt;/span&gt;: 24,
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
次のようなオーダー(8個単位とする)が来た場合について考えます。
&lt;/p&gt;
&lt;pre class="example"&gt;
order = ['screws', 'wingnuts', 'clips']
&lt;/pre&gt;


&lt;p&gt;
ディクショナリcomprehensionを使って、次のように書くと良いです。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;get_batches&lt;/span&gt;(count, size):
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; count // size

&lt;span style="font-weight: bold; font-style: italic;"&gt;found&lt;/span&gt; = {name: batches &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; name &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; order
    &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; (batches := get_batches(stock.get(name, 0), 8))}
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;code&gt;get_batches&lt;/code&gt; を使って、8個のセットが何セットあるかを求めています。
ポイントWalrusを使って &lt;code&gt;get_batches&lt;/code&gt; の実行をif節の中で1回だけ使っているところ。
&lt;/p&gt;
&lt;pre class="example"&gt;
print(found)
&amp;gt;&amp;gt;&amp;gt;
{'screws': 4, 'wingnuts': 1}
&lt;/pre&gt;


&lt;p&gt;
知りませんでした、generator expressions。&lt;a href="https://dbader.org/blog/python-generator-expressions"&gt;ここ&lt;/a&gt;の説明がわかりやすかったです。まずは似たようなリストcomprehension:
&lt;/p&gt;
&lt;pre class="example"&gt;
listcomp = ['Hello' for i in range(3)]
&lt;/pre&gt;

&lt;p&gt;
これがジェネレーターexpression:
&lt;/p&gt;
&lt;pre class="example"&gt;
genexpr = ('Hello' for i in range(3))
&lt;/pre&gt;

&lt;p&gt;
後者が返すのはジェネレーターです。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold;"&gt;next&lt;/span&gt;(genexpr)
&lt;span style="font-style: italic;"&gt;'Hello'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold;"&gt;next&lt;/span&gt;(genexpr)
&lt;span style="font-style: italic;"&gt;'Hello'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold;"&gt;next&lt;/span&gt;(genexpr)
&lt;span style="font-style: italic;"&gt;'Hello'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span style="font-weight: bold;"&gt;next&lt;/span&gt;(genexpr)
&lt;span style="font-weight: bold; text-decoration: underline;"&gt;StopIteration&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
先ほどの例はジェネレーターexpressionを使っても書けます。
&lt;/p&gt;
&lt;pre class="example"&gt;
found = ((name, batches) for name in order 
    if (batches := get_batches(stock.get(name, 0), 8)))
&lt;/pre&gt;

&lt;p&gt;
もちろん、返るのはジェネレーター。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;next&lt;/span&gt;(found))
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;next&lt;/span&gt;(found))
&amp;gt;&amp;gt;&amp;gt;
(&lt;span style="font-style: italic;"&gt;'screws'&lt;/span&gt;, 4)
(&lt;span style="font-style: italic;"&gt;'wingnuts'&lt;/span&gt;, 1)
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org4025dc2" class="outline-3"&gt;
&lt;h3 id="org4025dc2"&gt;&lt;span class="section-number-3"&gt;2.4&lt;/span&gt; Item 30: リストを返すくらいならジェネレーターを考慮せよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-4"&gt;
&lt;p&gt;
お、なんだか今更ジェネレーターの説明がありました。どうしてジェネレーターexpressionsを説明なしで使った後にこれが来るかな。。。
&lt;/p&gt;

&lt;p&gt;
この本は、どこから読んでも良いと謳っていますが、逆に、最初から読もうが途中から読もうが読みづらさは変わらない、という残念なことになっていると思います。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org849f4c6" class="outline-3"&gt;
&lt;h3 id="org849f4c6"&gt;&lt;span class="section-number-3"&gt;2.5&lt;/span&gt; Item 31: 引数をたどるときには保守的になれ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-5"&gt;
&lt;p&gt;
1カ所、どうしてもわからないところがありました。
&lt;/p&gt;
&lt;pre class="example"&gt;
percentages = normalize_func(lambda: read_visits(path))
&lt;/pre&gt;

&lt;p&gt;
&lt;code&gt;read_visits()&lt;/code&gt; はgenerator関数です。
&lt;/p&gt;

&lt;pre class="example"&gt;
def read_visits(data_path):
    with open(data_path) as f:
        for line in f:
            yield int(line)
&lt;/pre&gt;


&lt;p&gt;
これに &lt;code&gt;lambda&lt;/code&gt; が付くとどうなるのでしょう???本文には次のように書いてあります。
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
To use normalize_func, I can pass in a lambda expression that calls the generator and produces a new iterator each time.
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
ジェネレーター関数は呼び出すとジェネレーターiteratorを返してくるので、それを &lt;code&gt;lambda&lt;/code&gt; が関数にしてくるのでしょうか。
&lt;/p&gt;

&lt;p&gt;
&amp;rarr; 違いました。lambdaの無名関数は、read_visits()を呼び出す関数(ie, iteratorを返す関数)です。これがnormalize_func関数に引数get_iter()として渡ります。normalize_funcの中で2回get_iter()をexhaustさせています。
&lt;/p&gt;

&lt;p&gt;
本文を読むと実は書いてありますが、普通にiteratorをnormalize_funcに渡すだけだと、1回目のsum(get_iter())でiteratorをexhaustさせてしまい、2回目のfor文で使っているget_iter()は何もyieldしません。これだと困るので、iteratorを直接渡すのでは無く、新たなiteratorを都度生成して返す関数を渡すためにlambdaによる無名関数化が行われているのでした。(1/15/2021追記)
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;normalize_func&lt;/span&gt;(get_iter):
    &lt;span style="font-weight: bold; font-style: italic;"&gt;total&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;sum&lt;/span&gt;(get_iter())   &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;New iterator&lt;/span&gt;
    &lt;span style="font-weight: bold; font-style: italic;"&gt;result&lt;/span&gt; = []
    &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; value &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; get_iter():  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;New iterator&lt;/span&gt;
        &lt;span style="font-weight: bold; font-style: italic;"&gt;percent&lt;/span&gt; = 100 * value / total
        result.append(percent)
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; result
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
ただ、お勧めのやり方はこれではなく、自分で &lt;code&gt;__iter__()&lt;/code&gt; メソッドを書いたクラスを用意することでした。このメソッドはジェネレーター関数でなくてはならず、iteratorを返します。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;ReadVisits&lt;/span&gt;:
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__init__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, data_path):
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.data_path = data_path

    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__iter__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
        &lt;span style="font-weight: bold;"&gt;with&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;open&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.data_path) &lt;span style="font-weight: bold;"&gt;as&lt;/span&gt; f:
            &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; line &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; f:
                yeild &lt;span style="font-weight: bold;"&gt;int&lt;/span&gt;(line)
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
iteratorを返す &lt;code&gt;__iter__()&lt;/code&gt; メソッドを持つクラスを用意することで、このクラスをfor文などでiterateすることが可能です。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0fe05e7" class="outline-3"&gt;
&lt;h3 id="org0fe05e7"&gt;&lt;span class="section-number-3"&gt;2.6&lt;/span&gt; Item 32: 大きなリストcomprehensionsの代わりにジェネレーターexpressionsを考えよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-6"&gt;
&lt;p&gt;
(今更ですが)ジェネレーターexpressionsの説明でした。その戻り値であるiteratorを入力とした、ジェネレーターexpressionsのネスト(?)も可能。
&lt;/p&gt;
&lt;pre class="example"&gt;
it = (len(x) for x in open('my_file.txt'))
roots = ((x, x**0.5) for x in it)
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org18181fd" class="outline-3"&gt;
&lt;h3 id="org18181fd"&gt;&lt;span class="section-number-3"&gt;2.7&lt;/span&gt; Item 33: yield fromを使って複数のジェネレーターを組み合わせよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-7"&gt;
&lt;p&gt;
&lt;code&gt;yield from&lt;/code&gt; です。for文で &lt;code&gt;yield&lt;/code&gt; を回すところを &lt;code&gt;yeild from&lt;/code&gt; とシンプルに書ける、くらいの説明でしたが、奥が深そうです。もう少し調べてみたところ、&lt;a href="https://lerner.co.il/2020/05/08/making-sense-of-generators-coroutines-and-yield-from-in-python/"&gt;ここ&lt;/a&gt;の説明が非常にわかりやすかったです。
&lt;/p&gt;

&lt;p&gt;
まずはcoroutinesから。これはPythonのジェネレーターにある &lt;code&gt;yield&lt;/code&gt; をサポートしているサブルーチン的なもので、 &lt;code&gt;yield&lt;/code&gt; 文で(自分のステートを保持したまま)呼び主に戻し、再度呼ばれたら &lt;code&gt;yield&lt;/code&gt; の次から実行を再開します。
&lt;/p&gt;

&lt;p&gt;
これが何を意味するかというと、coroutineを呼び出し＆そこから戻ることで、まるでスレッド間でコンテキストスイッチをしているように振る舞う、ということです。呼び出し側もcoroutineもお互いに自分のステートを忘れずに「コンテキストスイッチ」できます。ジェネレーターはcoroutine(的なもの?)で、これはなかなかすごい機能のような気がしてきました。
&lt;/p&gt;

&lt;p&gt;
次に &lt;code&gt;send()&lt;/code&gt; メソッドについてです。これは &lt;code&gt;yield&lt;/code&gt; してから再開する際に、呼び主から引数を受け取る仕組みです。単に &lt;code&gt;yield x&lt;/code&gt; のように書いていたところを
&lt;/p&gt;
&lt;pre class="example"&gt;
y = yield x
&lt;/pre&gt;

&lt;p&gt;
のように書きます。呼び出し側も &lt;code&gt;next(generator)&lt;/code&gt; でなく、
&lt;/p&gt;
&lt;pre class="example"&gt;
generator.send("Hello")
&lt;/pre&gt;

&lt;p&gt;
と書きます。ただし、最初にジェネレーターを実行する時だけは、まだ &lt;code&gt;yield&lt;/code&gt; 文に来ていないため、これまで通りnext(generator)で呼び出します。
&lt;/p&gt;

&lt;p&gt;
そして、 &lt;code&gt;yield from&lt;/code&gt; です。こいつの真の(裏の?)目的は、ジェネレーターから別のサブジェネレーターに機能をオフロードすることです。そしてその際に、元のジェネレーターが &lt;code&gt;send()&lt;/code&gt; で受け取った引数をサブジェネレーターにそのまま渡します。
&lt;/p&gt;
&lt;pre class="example"&gt;
def generator():
   ...
   yield from subgenerator()
&lt;/pre&gt;

&lt;p&gt;
この &lt;code&gt;yield&lt;/code&gt; 文に制御がいる(実行する行がここである)際に
&lt;/p&gt;
&lt;pre class="example"&gt;
generator.send('hello')
&lt;/pre&gt;

&lt;p&gt;
とすると、 &lt;code&gt;'hello'&lt;/code&gt; が &lt;code&gt;subgenerator()&lt;/code&gt; に渡ります。
&lt;/p&gt;

&lt;p&gt;
うーん、奥が深い。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org61afc26" class="outline-3"&gt;
&lt;h3 id="org61afc26"&gt;&lt;span class="section-number-3"&gt;2.8&lt;/span&gt; Item 34: ジェネレーターにsendを使ってデータを送ってはいけない&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-8"&gt;
&lt;p&gt;
えー、前の項目で何とか理解したばかりだというのに、 &lt;code&gt;send()&lt;/code&gt; を使うなと言っています。初心者にわかりづらいのと、 &lt;code&gt;yield from&lt;/code&gt; を使って初回に &lt;code&gt;None&lt;/code&gt; が返るケースでびっくりすることがあるため。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;wave_modulating&lt;/span&gt;(steps):
    &lt;span style="font-weight: bold; font-style: italic;"&gt;step_size&lt;/span&gt; = 2 * math.pi / steps
    &lt;span style="font-weight: bold; font-style: italic;"&gt;amplitude&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;yield&lt;/span&gt;    &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;Receive initial amplitude&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; step &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;range&lt;/span&gt;(steps):
        &lt;span style="font-weight: bold; font-style: italic;"&gt;radians&lt;/span&gt; = step * step_size
        &lt;span style="font-weight: bold; font-style: italic;"&gt;fraction&lt;/span&gt; = math.sin(radians)
        &lt;span style="font-weight: bold; font-style: italic;"&gt;output&lt;/span&gt; = amplitude * fraction
        &lt;span style="font-weight: bold; font-style: italic;"&gt;amplitude&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;yield&lt;/span&gt; output  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;Receive next amplitude&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
上記で、最初にamplitudeの初期値を受け取るところが、yield fromするとNoneが返る箇所です。これを、 &lt;code&gt;send()&lt;/code&gt; を使わずに、iteratorを引数で渡しておくようにします。関数の名前が示すように、ジェネレーターのカスケードになります。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;wave_cascading&lt;/span&gt;(amplitude_it, steps):
    &lt;span style="font-weight: bold; font-style: italic;"&gt;step_size&lt;/span&gt; = 2 * math.pi / steps
    &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; step &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;range&lt;/span&gt;(steps):
        &lt;span style="font-weight: bold; font-style: italic;"&gt;radians&lt;/span&gt; = step * step_size
        &lt;span style="font-weight: bold; font-style: italic;"&gt;fraction&lt;/span&gt; = math.sin(radians)
        &lt;span style="font-weight: bold; font-style: italic;"&gt;amplitude&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;next&lt;/span&gt;(amplitude_it)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;Get next input&lt;/span&gt;
        &lt;span style="font-weight: bold; font-style: italic;"&gt;output&lt;/span&gt; = amplitude * fraction
        &lt;span style="font-weight: bold;"&gt;yield&lt;/span&gt; output
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
こうします。そして、
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;complex_cascading&lt;/span&gt;(amplitude_it):
    &lt;span style="font-weight: bold;"&gt;yield&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; wave_cascading(amplitude_it, 3)
    &lt;span style="font-weight: bold;"&gt;yield&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; wave_cascading(amplitude_it, 4)
    &lt;span style="font-weight: bold;"&gt;yield&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;from&lt;/span&gt; wave_cascading(amplitude_it, 5)
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
ところで、上の &lt;code&gt;yield from&lt;/code&gt; 3行を1行にまとめればいいのに。こんな感じで:
&lt;/p&gt;
&lt;pre class="example"&gt;
yield from wave_cascading(amplitude_it, 12)
&lt;/pre&gt;

&lt;p&gt;
としばらく悩みましたが、 &lt;code&gt;step_size&lt;/code&gt; が変わってしまうので駄目でしたね。
そして更に、
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;run_cascading&lt;/span&gt;():
    &lt;span style="font-weight: bold; font-style: italic;"&gt;amplitudes&lt;/span&gt; = [7, 7, 7, 2, 2, 2, 2, 10, 10, 10, 10, 10]
    &lt;span style="font-weight: bold; font-style: italic;"&gt;it&lt;/span&gt; = complex_cascading(&lt;span style="font-weight: bold;"&gt;iter&lt;/span&gt;(amplitudes))
    &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; amplitude &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; amplitudes:
        &lt;span style="font-weight: bold; font-style: italic;"&gt;output&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;next&lt;/span&gt;(it)
        transmit(output)
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
うーん、わかりやすいですかね。初心者的には若干厳しいです。。。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf146ab2" class="outline-3"&gt;
&lt;h3 id="orgf146ab2"&gt;&lt;span class="section-number-3"&gt;2.9&lt;/span&gt; Item 35: throwで例外を投げてジェネレータの状態遷移を起こすな&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-9"&gt;
&lt;p&gt;
&lt;code&gt;throw&lt;/code&gt; を使う駄目な例:
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;run&lt;/span&gt;():
    &lt;span style="font-weight: bold; font-style: italic;"&gt;it&lt;/span&gt; = timer(4)
    &lt;span style="font-weight: bold;"&gt;while&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;True&lt;/span&gt;:
        &lt;span style="font-weight: bold;"&gt;try&lt;/span&gt;:
            &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; check_for_reset():
                &lt;span style="font-weight: bold; font-style: italic;"&gt;current&lt;/span&gt; = it.throw(Reset())  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#33258;&amp;#20998;&amp;#12391;&amp;#20363;&amp;#22806;&amp;#12434;&amp;#25237;&amp;#12370;&amp;#12390;&amp;#12356;&amp;#12427;&lt;/span&gt;
            &lt;span style="font-weight: bold;"&gt;else&lt;/span&gt;:
                &lt;span style="font-weight: bold; font-style: italic;"&gt;current&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;next&lt;/span&gt;(it)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12371;&amp;#12371;&amp;#12391;&amp;#20363;&amp;#22806;&amp;#12364;&amp;#30330;&amp;#29983;&amp;#12377;&amp;#12427;&amp;#21487;&amp;#33021;&amp;#24615;&amp;#12354;&amp;#12426;&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;except&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;StopIteration&lt;/span&gt;:
            &lt;span style="font-weight: bold;"&gt;break&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;else&lt;/span&gt;:  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#20363;&amp;#22806;&amp;#12364;&amp;#30330;&amp;#29983;&amp;#12375;&amp;#12394;&amp;#12363;&amp;#12387;&amp;#12383;&amp;#12425;&lt;/span&gt;
            announce(current)
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
何だか、何がしたいのかよくわかりません。。。。ので調べます。&lt;a href="https://stackoverflow.com/questions/11485591/what-is-generator-throw-good-for"&gt;ここ&lt;/a&gt;によると、 &lt;code&gt;it.throw()&lt;/code&gt; はit内部で例外を発生させるようです。 &lt;code&gt;it&lt;/code&gt; の &lt;code&gt;Reset()&lt;/code&gt; 例外ハンドラーでタイマーをリセットしているのかな。確かに、少し読みづらいですかね。
&lt;/p&gt;

&lt;p&gt;
ジェネレーターの &lt;code&gt;__iter__()&lt;/code&gt; を持つクラスを用意して &lt;code&gt;run()&lt;/code&gt; を書き換えます。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;Timer&lt;/span&gt;:
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__init__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, period):
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.current = period
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.period = period

    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;reset&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.current = &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.period

    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__iter__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;):
        &lt;span style="font-weight: bold;"&gt;while&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.current:
            &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.current -= 1
            &lt;span style="font-weight: bold;"&gt;yield&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;.current
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;code&gt;run()&lt;/code&gt; 関数はずっとシンプルになります。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;run&lt;/span&gt;():
    &lt;span style="font-weight: bold; font-style: italic;"&gt;timer&lt;/span&gt; = Timer(4)
    &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; current &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; timer:
        &lt;span style="font-weight: bold;"&gt;if&lt;/span&gt; check_for_reset():
            timer.reset()
        announce(current)
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgc1d6aec" class="outline-3"&gt;
&lt;h3 id="orgc1d6aec"&gt;&lt;span class="section-number-3"&gt;2.10&lt;/span&gt; Item 36: Iteratorやジェネレーターを使うときにはitertoolsの使用を検討せよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-10"&gt;
&lt;p&gt;
itertoolsには便利な関数がたくさんあるので使うとよい、という節でした。
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org109feb6" class="outline-4"&gt;
&lt;h4 id="org109feb6"&gt;&lt;span class="section-number-4"&gt;2.10.1&lt;/span&gt; Iteratorsをつなぐ&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-10-1"&gt;
&lt;/div&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;a id="org05c8324"&gt;&lt;/a&gt;chain&lt;br /&gt;
&lt;div class="outline-text-5" id="text-2-10-1-1"&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;it&lt;/span&gt; = itertools.chain([1, 2, 3], [4, 5, 6])
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;list&lt;/span&gt;(it))
&amp;gt;&amp;gt;&amp;gt;
[1, 2, 3, 4, 5, 6]
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a id="orge6c4ac4"&gt;&lt;/a&gt;repeat&lt;br /&gt;
&lt;div class="outline-text-5" id="text-2-10-1-2"&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;it&lt;/span&gt; = itertools.repeat(&lt;span style="font-style: italic;"&gt;'hello'&lt;/span&gt;, 3)
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;list&lt;/span&gt;(it))
&amp;gt;&amp;gt;&amp;gt;
[&lt;span style="font-style: italic;"&gt;'hello'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'hello'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'hello'&lt;/span&gt;]
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
もっと簡単な方法はないのでしょうか。実験してみます。
&lt;/p&gt;
&lt;pre class="example"&gt;
&amp;gt;&amp;gt;&amp;gt; 'hello' * 3
'hellohellohello'
&amp;gt;&amp;gt;&amp;gt; ['hello' * 3]
['hellohellohello']
&amp;gt;&amp;gt;&amp;gt; list('hello' * 3)
['h', 'e', 'l', 'l', 'o', 'h', 'e', 'l', 'l', 'o', 'h', 'e', 'l', 'l', 'o']
&lt;/pre&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="orgd8de34c"&gt;&lt;/a&gt;cycle&lt;br /&gt;
&lt;div class="outline-text-5" id="text-2-10-1-3"&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;it&lt;/span&gt; = itertools.cycle([1, 2])
&lt;span style="font-weight: bold; font-style: italic;"&gt;result&lt;/span&gt; = [&lt;span style="font-weight: bold;"&gt;next&lt;/span&gt;(it) &lt;span style="font-weight: bold;"&gt;for&lt;/span&gt; _ &lt;span style="font-weight: bold;"&gt;in&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;range&lt;/span&gt;(10)]
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(result)
&amp;gt;&amp;gt;&amp;gt;
[1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a id="org0aedf21"&gt;&lt;/a&gt;tee - iteratorを指定個数に分割して並列実行&lt;br /&gt;
&lt;div class="outline-text-5" id="text-2-10-1-4"&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;it1&lt;/span&gt;, &lt;span style="font-weight: bold; font-style: italic;"&gt;it2&lt;/span&gt;, &lt;span style="font-weight: bold; font-style: italic;"&gt;it3&lt;/span&gt; = itertools.tee([&lt;span style="font-style: italic;"&gt;'first'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'second'&lt;/span&gt;], 3)
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;list&lt;/span&gt;(it1))
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;list&lt;/span&gt;(it2))
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;list&lt;/span&gt;(it3))
&amp;gt;&amp;gt;&amp;gt;
[&lt;span style="font-style: italic;"&gt;'first'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'second'&lt;/span&gt;]
[&lt;span style="font-style: italic;"&gt;'first'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'second'&lt;/span&gt;]
[&lt;span style="font-style: italic;"&gt;'first'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'second'&lt;/span&gt;]
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a id="org69a4a1b"&gt;&lt;/a&gt;zip_longest - zipと似ているが、一番長いiteratorに合わせる。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7042ef7" class="outline-4"&gt;
&lt;h4 id="org7042ef7"&gt;&lt;span class="section-number-4"&gt;2.10.2&lt;/span&gt; Iteratorからアイテムをフィルタする&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-10-2"&gt;
&lt;/div&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;a id="org91bd8e7"&gt;&lt;/a&gt;islice - スライスする。ステップも指定可&lt;br /&gt;
&lt;div class="outline-text-5" id="text-2-10-2-1"&gt;
&lt;pre class="example"&gt;
first_five = itertools.islice(values, 5)  # 最初の5個
mkddle_odds = itertools.islice(values, 2, 8, 2)  # 3番目からステップ2で7まで
&lt;/pre&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a id="org4e97f34"&gt;&lt;/a&gt;takewhile - 指定関数がFalseを返すまでtakeする&lt;br /&gt;
&lt;div class="outline-text-5" id="text-2-10-2-2"&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;values&lt;/span&gt; = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
&lt;span style="font-weight: bold; font-style: italic;"&gt;less_than_seven&lt;/span&gt; = &lt;span style="font-weight: bold;"&gt;lambda&lt;/span&gt; x: x &amp;lt; 7
&lt;span style="font-weight: bold; font-style: italic;"&gt;it&lt;/span&gt; = itertools.takewhile(less_than_seven, values)
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;list&lt;/span&gt;(it))
&amp;gt;&amp;gt;&amp;gt;
[1, 2, 3, 4, 5, 6]
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a id="org637910a"&gt;&lt;/a&gt;dropwhile - takewhileの逆。指定関数がTrueを返すまでドロップする&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a id="orgad493bb"&gt;&lt;/a&gt;filterfalse - filterの逆&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

&lt;div id="outline-container-org35a3757" class="outline-4"&gt;
&lt;h4 id="org35a3757"&gt;&lt;span class="section-number-4"&gt;2.10.3&lt;/span&gt; 複数iteratorsのアイテムを結びつける&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-10-3"&gt;
&lt;/div&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;a id="org816fd63"&gt;&lt;/a&gt;accumulate - 積算する&lt;br /&gt;
&lt;div class="outline-text-5" id="text-2-10-3-1"&gt;
&lt;p&gt;
二つ目の引数に関数を指定して、加工が可能。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;values&lt;/span&gt; = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
&lt;span style="font-weight: bold; font-style: italic;"&gt;sum_reduce&lt;/span&gt; = itertools.accumulate(values)
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'Sum: '&lt;/span&gt;, &lt;span style="font-weight: bold;"&gt;list&lt;/span&gt;(sum_reduce))
&amp;gt;&amp;gt;&amp;gt;
Sum: [1, 3, 6, 10, 15, 21, 28, 36, 45, 55]
&lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;sum_modulo_20&lt;/span&gt;(first, second):
    &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; (first + second) % 20
&lt;span style="font-weight: bold; font-style: italic;"&gt;modulo_reduce&lt;/span&gt; = itertools.accumulate(values, sum_modulo_20)
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'Modulo: '&lt;/span&gt;, &lt;span style="font-weight: bold;"&gt;list&lt;/span&gt;(modulo_reduce))
&amp;gt;&amp;gt;&amp;gt;
Modulo: [1, 3, 6, 10, 15, 1, 8, 16, 5, 15]
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
後者のユースケースは、行列計算かな。
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="org1ddedab"&gt;&lt;/a&gt;product - 直積(cartesian product)&lt;br /&gt;
&lt;div class="outline-text-5" id="text-2-10-3-2"&gt;
&lt;p&gt;
直積、デカルト積、cartesian積と呼ばれます。AとBの要素からそれぞれ一つずつ取ってきた作ったペアの集合です。学校で習った記憶があまりありません。。。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;single&lt;/span&gt; = itertools.product([1, 2], repeat=2)
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'Single: '&lt;/span&gt;, &lt;span style="font-weight: bold;"&gt;list&lt;/span&gt;(single)
&amp;gt;&amp;gt;&amp;gt;
Single: [(1, 2), (1, 2), (2, 1), (2, 2)]
multiple = itertools.product([1, 2], [&lt;span style="font-style: italic;"&gt;'a'&lt;/span&gt;, &lt;span style="font-style: italic;"&gt;'b'&lt;/span&gt;])
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-style: italic;"&gt;'Multi: '&lt;/span&gt;, &lt;span style="font-weight: bold;"&gt;list&lt;/span&gt;(multiple))
&amp;gt;&amp;gt;&amp;gt;
Multi: [(1, &lt;span style="font-style: italic;"&gt;'a'&lt;/span&gt;), (1, &lt;span style="font-style: italic;"&gt;'b'&lt;/span&gt;), (2, &lt;span style="font-style: italic;"&gt;'a'&lt;/span&gt;), (2, &lt;span style="font-style: italic;"&gt;'b'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
上の例でのrepeatは、自身で積を計算するときの個数を指定します。product(A, repeat=4)はproduct(A, A, A, A)と等価。
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;&lt;a id="orge28d83e"&gt;&lt;/a&gt;permutations - 順列&lt;br /&gt;
&lt;div class="outline-text-5" id="text-2-10-3-3"&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;it&lt;/span&gt; = itertools.permutations([1, 2, 3, 4], 2)
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;list&lt;/span&gt;(it))
&amp;gt;&amp;gt;&amp;gt;
[(1, 2), (1, 3), (1, 4), (2, 1), (2, 3), (2, 4), 
 (3, 1), (3, 2), (3, 4), (4, 1), (4, 2), (4, 3)]
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a id="orgc64c6d7"&gt;&lt;/a&gt;combinations - 組み合わせ&lt;br /&gt;
&lt;div class="outline-text-5" id="text-2-10-3-4"&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;it&lt;/span&gt; = itertools.combinations([1, 2, 3, 4], 2)
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;list&lt;/span&gt;(it))
&amp;gt;&amp;gt;&amp;gt;
[(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a id="orga0a6aba"&gt;&lt;/a&gt;combinations_with_replacement&lt;br /&gt;
&lt;div class="outline-text-5" id="text-2-10-3-5"&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;it&lt;/span&gt; = itertools.combinations_with_replacement([1, 2, 3, 4], 2)
&lt;span style="font-weight: bold;"&gt;print&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;list&lt;/span&gt;(it))
&amp;gt;&amp;gt;&amp;gt;
[(1, 1), (1, 2), (1, 3), (1, 4), (2, 2), (2, 3), (2, 4), 
 (3, 3), (3, 4), (4, 4)]
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Python"></category><category term="Python"></category></entry><entry><title>Effective Python一人輪読会(Item 1 to 18)</title><link href="http://achiwa912.github.io/effective1.html" rel="alternate"></link><published>2020-08-15T00:00:00-04:00</published><updated>2020-08-21T00:00:00-04:00</updated><author><name>きょうす</name></author><id>tag:achiwa912.github.io,2020-08-15:/effective1.html</id><summary type="html">Effective Python読書メモ1</summary><content type="html">&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org477d258"&gt;1. はじめに&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org0b39c9e"&gt;2. Chapter 1: Pythonicな考え方&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org51125d6"&gt;2.1. Item 1: どのバージョンのPythonを使っているか意識せよ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org864ab94"&gt;2.2. Item 2: PEP 8のスタイルガイドに従え&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgf4d204f"&gt;2.3. Item 3: bytesとstrの違いを理解せよ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org7d2c2ad"&gt;2.4. Item 4: C言語ライクなフォーマット文字列やstr.formatよりもF-Stringsを使え&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org19510d2"&gt;2.5. Item 5: 複雑なexpressionsでなくヘルパー関数を書け&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org4ccbb54"&gt;2.6. Item 6: インデックスよりもunpackingを使え&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org171c9b0"&gt;2.7. Item 7: range()よりもenumerate()を使え&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orge21e414"&gt;2.8. Item 8: iteratorsを並列で処理するためにzipを使え&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org510796c"&gt;2.9. Item 9: forやwhileループの後のelseは使うな&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org1815098"&gt;2.10. Item 10: Walrus operator (:=) を使って繰り返しを避けよ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#org7ce308d"&gt;3. Chapter 2: リストとディクショナリ&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org10b476a"&gt;3.1. Item 11: シーケンスをどうスライスするか知っておけ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org9dfdf88"&gt;3.2. Item 12: strideとsliceを同時にするな&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org61949b7"&gt;3.3. Item 13: スライスするよりcatch-allのunpackingを使え&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org17927e9"&gt;3.4. Item 14: 複雑な条件のソートではkeyパラメータを使え&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org24a1541"&gt;3.5. Item 15: ディクショナリに追加する順番が守られるとは限らない&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org1c09470"&gt;3.6. Item 16: 欠けているディクショナリのキーを扱うのに、inとKeyErrorよりもgetを使え&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgb50bb80"&gt;3.7. Item 17: 内部状態に欠けている項目を扱うには、setdefaultよりもdefaultdictを使え&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org0a92cfe"&gt;3.8. Item 18: __missing__()メソッドを使って、キー依存のデフォルト値を作る方法を知っておけ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org477d258" class="outline-2"&gt;
&lt;h2 id="org477d258"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; はじめに&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
この記事は&lt;a href="https://effectivepython.com/"&gt;Effeitive Python第2版&lt;/a&gt;(英語版)の読書メモ(その1)です。
&lt;/p&gt;

&lt;p&gt;
以前、&lt;a href="https://www.amazon.com/Effective-Java-Joshua-Bloch/dp/0134685997"&gt;Effective Java&lt;/a&gt;の輪講に参加したことがありますが、あまりの難易度に消化不良のままフェードアウトしてしまいました。今回は同じ轍を踏まないよう、背景知識をネットで調べながらじっくりと読み進めたいと思います。
&lt;/p&gt;

&lt;p&gt;
私のPythonの知識は、入門書2冊(&lt;a href="https://www.amazon.com/Python-Crash-Course-Eric-Matthes-ebook/dp/B07J4521M3"&gt;Python Crash Course&lt;/a&gt;, &lt;a href="https://www.amazon.com/Introducing-Python-Modern-Computing-Packages/dp/1449359361"&gt;Introducing Python&lt;/a&gt;)を読んだ程度ですので、同じような初中級レベルの方の参考になる、、、かもしれません。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0b39c9e" class="outline-2"&gt;
&lt;h2 id="org0b39c9e"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; Chapter 1: Pythonicな考え方&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org51125d6" class="outline-3"&gt;
&lt;h3 id="org51125d6"&gt;&lt;span class="section-number-3"&gt;2.1&lt;/span&gt; Item 1: どのバージョンのPythonを使っているか意識せよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-1"&gt;
&lt;p&gt;
最初は特に難しくありません。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org864ab94" class="outline-3"&gt;
&lt;h3 id="org864ab94"&gt;&lt;span class="section-number-3"&gt;2.2&lt;/span&gt; Item 2: PEP 8のスタイルガイドに従え&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-2"&gt;
&lt;p&gt;
はい。emacsをPythonのIDE化するelpyを導入する際に、py-autopep8, blackenを入れたので大丈夫でしょう。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf4d204f" class="outline-3"&gt;
&lt;h3 id="orgf4d204f"&gt;&lt;span class="section-number-3"&gt;2.3&lt;/span&gt; Item 3: bytesとstrの違いを理解せよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-3"&gt;
&lt;p&gt;
unicodeとUTF-8の関係がよくわからなくなっていたので、少し整理しました。
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Python3のstringsは全てunicode stringsである。unicodeを使ってASCII以外の文字が表現できる。¥u + 4桁の数字。&lt;/li&gt;
&lt;li&gt;stringをファイルにセーブしたりする時に、bytesにエンコードする。このときUTF-8等を使う&lt;/li&gt;
&lt;li&gt;エンコードされたbytesをstringに戻すときにはデコードする&lt;/li&gt;
&lt;li&gt;UTF-8は文字列をエンコード、デコードする最も標準的なスキームである&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
len(bytes)するとバイト数が出る。len(str)は文字数をカウントする。
unicodeの1文字は2バイト以上の場合がある。日本語など。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7d2c2ad" class="outline-3"&gt;
&lt;h3 id="org7d2c2ad"&gt;&lt;span class="section-number-3"&gt;2.4&lt;/span&gt; Item 4: C言語ライクなフォーマット文字列やstr.formatよりもF-Stringsを使え&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-4"&gt;
&lt;p&gt;
はい。F-Stringsは直感的で一番使いやすいので、こればかり使っています。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org19510d2" class="outline-3"&gt;
&lt;h3 id="org19510d2"&gt;&lt;span class="section-number-3"&gt;2.5&lt;/span&gt; Item 5: 複雑なexpressionsでなくヘルパー関数を書け&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-5"&gt;
&lt;p&gt;
Effectiveシリーズの本領発揮です。
いきなり、意味がわらかない部分がありました。
&lt;/p&gt;
&lt;pre class="example"&gt;
from urllib.parse import parse_qs
my_values = parse_qs('red=5&amp;amp;blue=0&amp;amp;green=',
		     keep_blank_values=True)
print(repr(my_values))
&amp;gt;&amp;gt;&amp;gt;
{'red': ['5'], 'blue': ['0'], 'green': ['']}
&lt;/pre&gt;

&lt;p&gt;
まず、parse_qs()メソッドがわかりませんので調べます。
&lt;a href="https://docs.python.org/3/library/urllib.parse.html"&gt;こちら&lt;/a&gt;より、
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
urllib.parse.parse_qs(qs, keep_blank_values=False, strict_parsing=False, encoding='utf-8', errors='replace', max_num_fields=None)¶
&lt;/p&gt;

&lt;p&gt;
Parse a query string given as a string argument (data of type application/x-www-form-urlencoded). Data are returned as a dictionary. The dictionary keys are the unique query variable names and the values are lists of values for each name.
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
なるほど、parse_qs()は、URLに埋め込まれるクエリータイプの文字列をパースして、ディクショナリにして返してくれるメソッドでした。うーん、これを説明なしで書くとは、これまでの入門書とはひと味違います。
&lt;/p&gt;

&lt;p&gt;
そしてこれ:
&lt;/p&gt;
&lt;pre class="example"&gt;
red = my_values.get('red', [''])[0] or 0
green = my_values.get('green', [''])[0] or 0
opacity = my_values.get('opacity', [''])[0] or 0
&lt;/pre&gt;


&lt;p&gt;
何ですか、これは。getメソッドの二つ目の引数['']がわかりません。そしてgetメソッドの戻り値に[0]が付いているのも謎です。ディクショナリーのgetメソッドについてネットで調べてみます。&lt;a href="https://www.w3schools.com/python/ref_dictionary_get.asp"&gt;ここ&lt;/a&gt;によると、
&lt;/p&gt;
&lt;pre class="example"&gt;
Syntax
ditionaru.get(keyname, value)
 &amp;lt;snip&amp;gt;
 value - Optional. A value to return if the specified key does not exist.
	 Default value None
&lt;/pre&gt;
&lt;p&gt;
二つ目の引数は、指定したキーが存在しなかったときに返す値、だそうです。
&lt;/p&gt;

&lt;p&gt;
それでは[0]は? 手元のPythonインタープリターで見てみます。
&lt;/p&gt;
&lt;pre class="example"&gt;
&amp;gt;&amp;gt;&amp;gt; my_values.get('red', [''])
['5']
&amp;gt;&amp;gt;&amp;gt; my_values.get('green', [''])
['']
&amp;gt;&amp;gt;&amp;gt; my_values.get('opacity', [''])
['']
&lt;/pre&gt;
&lt;p&gt;
どれも、stringを一つだけ持つリストを返していました。確かにparse_qsの説明をよく読むと、
&lt;/p&gt;
&lt;pre class="example"&gt;
...and the values are lists of values for each name.
&lt;/pre&gt;

&lt;p&gt;
リストを返すと書いてありました。なので、[0]を付けるとリストの最初(かつ、この場合唯一)のメンバーを返すのですね。
&lt;/p&gt;
&lt;pre class="example"&gt;
&amp;gt;&amp;gt;&amp;gt; my_values.get('red', [''])[0]
'5'
&lt;/pre&gt;

&lt;p&gt;
確かにそうなりました。
&lt;/p&gt;

&lt;p&gt;
。。。すっきりしたところで読み進めていったら、説明が書いてありました。がーん。
&lt;/p&gt;

&lt;p&gt;
複雑なexpressionの例:
&lt;/p&gt;
&lt;pre class="example"&gt;
red = int(my_values.get('red', [''])[0] or 0)
&lt;/pre&gt;

&lt;p&gt;
このようなexpressionを書く代わりに、ヘルパー関数を作ります。
&lt;/p&gt;
&lt;pre class="example"&gt;
def get_first_int(values, key, default=0):
    found = values.get(key, [''])

    if found[0]:
        return int(found[0])
    return default
&lt;/pre&gt;

&lt;p&gt;
そして、次のように書けばOK。
&lt;/p&gt;
&lt;pre class="example"&gt;
red = get_first_int(my_values, 'red')
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org4ccbb54" class="outline-3"&gt;
&lt;h3 id="org4ccbb54"&gt;&lt;span class="section-number-3"&gt;2.6&lt;/span&gt; Item 6: インデックスよりもunpackingを使え&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-6"&gt;
&lt;p&gt;
知らない関数が説明無しで出てきました。
&lt;/p&gt;

&lt;pre class="example"&gt;
for rank, (name, calories) in enumerate(snacks, 1):
    print(f'#{rank}: {name} has {calories} calories')
&lt;/pre&gt;

&lt;p&gt;
enumerate()って、何でしたっけ? 特に二つ目の引数。。。
&lt;/p&gt;

&lt;p&gt;
&lt;a href="https://book.pythontips.com/en/latest/enumerate.html"&gt;ここ&lt;/a&gt;によると、何かをiterateして、更にカウンターまでつけてくれる便利なビルトインの関数だそうです。二つ目の引数はカウンター初期値でデフォルトは0。おー、これは便利かも。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org171c9b0" class="outline-3"&gt;
&lt;h3 id="org171c9b0"&gt;&lt;span class="section-number-3"&gt;2.7&lt;/span&gt; Item 7: range()よりもenumerate()を使え&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-7"&gt;
&lt;p&gt;
ここではビルトイン関数enumerate()の詳しい説明が。。。Item 6と7を逆にした方が読みやすいのでは。。。後で説明することを当たり前のように前のItemで使うのが、Effecitveシリーズの伝統なのでしょうか。
&lt;/p&gt;

&lt;p&gt;
range()はインデックスを使って自分でiterateするので複雑だし間違いやすいし読みづらい。enumerate()は自動でiterateして、更にインデックスまで付けてくれる。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orge21e414" class="outline-3"&gt;
&lt;h3 id="orge21e414"&gt;&lt;span class="section-number-3"&gt;2.8&lt;/span&gt; Item 8: iteratorsを並列で処理するためにzipを使え&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-8"&gt;
&lt;p&gt;
zip()忘れていました。複数のiterators(eg, リスト)から次の値をそれぞれ持ってきてタプルにしてくれる(lazy generatorと言うそうです)。zip()はその繰り返し回しか扱わないので、例えば無限長のリストに対して使ってもメモリを使い切る心配は無い。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org510796c" class="outline-3"&gt;
&lt;h3 id="org510796c"&gt;&lt;span class="section-number-3"&gt;2.9&lt;/span&gt; Item 9: forやwhileループの後のelseは使うな&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-9"&gt;
&lt;p&gt;
はい、使いません。本の指摘通り、「breakで抜けなかった時だけelseを実行する」という意味が紛らわしいので。
&lt;/p&gt;

&lt;p&gt;
この本のKindle版にはClick here to view code imageというリンクが、code snip部分によく出てきます。Kindleデバイスの画面では見づらいからなのかと思っていましたが、本文のcode snipにはとんでもない欠陥がたまにあることがわかりました。例えばこの項目にある例です。
&lt;/p&gt;
&lt;pre class="example"&gt;
def coprime_alternate(a, b)
    is_coprime = True
    for i in range(2, min(a, b) + 1):
	if a % i == 0 and b % i == 0:
	    is_coprime = False
	    break
	return is_coprime
&lt;/pre&gt;
&lt;p&gt;
これ、いかにもおかしいです。Click here to view code imageをクリックするとわかりますが、return is_coprimeのインデントが間違っています。正しくは、
&lt;/p&gt;
&lt;pre class="example"&gt;
def coprime_alternate(a, b)
    is_coprime = True
    for i in range(2, min(a, b) + 1):
	if a % i == 0 and b % i == 0:
	    is_coprime = False
	    break
    return is_coprime
&lt;/pre&gt;
&lt;p&gt;
インデントでブロックの範囲を指定するPythonとKindleの相性は悪いです。おや?と思ったら、Click here to view code imageリンクを押さないといけません。みなさん、紙の本かPDF版を買いましょう。でも、Kindle版が一番安いんですよね。。。
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;ペーパーバック $41、Kindle版 $23.49 (&lt;a href="https://www.amazon.com/Effective-Python-Specific-Software-Development/dp/0134853989"&gt;@amazon&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;PDF版 $31.99 (&lt;a href="https://www.informit.com/store/effective-python-90-specific-ways-to-write-better-python-9780134854762?ranMID=24808"&gt;@informIT&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
うーん、この値段ならPDF版を買うべきだったかも。。。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1815098" class="outline-3"&gt;
&lt;h3 id="org1815098"&gt;&lt;span class="section-number-3"&gt;2.10&lt;/span&gt; Item 10: Walrus operator (:=) を使って繰り返しを避けよ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-10"&gt;
&lt;p&gt;
Python 3.8で導入されたwalrus operatorですよ。流石、2019年末に改訂された2nd editionです。
&lt;/p&gt;
&lt;pre class="example"&gt;
.. these assignment statements are written a := b and 
pronounced "a walrus b" (because := looks like a pair
of eyeballs and tusks).
&lt;/pre&gt;

&lt;p&gt;
うーむ。ジョークなのか本気なのか。。
(walrus - セイウチ。tusks - 牙(キバ))
&lt;/p&gt;

&lt;p&gt;
ここで出てくるloop-and-a-halfイディオムって何でしょう?
&lt;/p&gt;

&lt;p&gt;
&lt;a href="https://codehs.gitbooks.io/introcs/content/Basic-JavaScript-and-Graphics/loop-and-a-half.html"&gt;ここ&lt;/a&gt;によると、while Trueなどで無限ループを作っておいて、そのループを抜ける条件をあらかじめsentinel(見張り、歩哨)の値として決めておくパターンをこう言うらしいです。以下のような感じ。これならよく使いますよね。
&lt;/p&gt;
&lt;pre class="example"&gt;
SENTINEL = -1
while True:
    ...
    if num == SENTINEL:
        break
&lt;/pre&gt;


&lt;p&gt;
これをwalrus operatorを使ってよりシンプルにします。
&lt;/p&gt;
&lt;pre class="example"&gt;
SENTINEL = -1
while (num := xxx) != SENTINEL:
    ...
&lt;/pre&gt;


&lt;p&gt;
walrus operatorの本質は、変数にアサインするだけでなく、アサインした変数をevaluateすることで、繰り返しを減らせる、ということのようです。定義だけ見ても、軽く読み飛ばしそうですが、後半のevaluateするというところがとても大事です。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7ce308d" class="outline-2"&gt;
&lt;h2 id="org7ce308d"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; Chapter 2: リストとディクショナリ&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org10b476a" class="outline-3"&gt;
&lt;h3 id="org10b476a"&gt;&lt;span class="section-number-3"&gt;3.1&lt;/span&gt; Item 11: シーケンスをどうスライスするか知っておけ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-3-1"&gt;
&lt;p&gt;
これ大事ですけど、使いこなせていませんでした。為になります。
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;somelist[start:end]でstartは含み、endは含まない&lt;/li&gt;
&lt;li&gt;b = a[:]とすると、bにはaのコピーがまるまる入る。aとbの実体はそれぞれ別。a == bだけどa is not b&lt;/li&gt;
&lt;li&gt;b = aとすると、bもaの実体を指す。a == bかつa is b&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org9dfdf88" class="outline-3"&gt;
&lt;h3 id="org9dfdf88"&gt;&lt;span class="section-number-3"&gt;3.2&lt;/span&gt; Item 12: strideとsliceを同時にするな&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-3-2"&gt;
&lt;p&gt;
somelist[start:end:stride]というやつです。同時にする必要があるなら、まずstrideだけして、その結果に対してsliceするように2段階で行う。最初にstrideしてiteratorを可能な限り短くすることがポイント。こんな感じ:
&lt;/p&gt;
&lt;pre class="example"&gt;
x = somelist[::stride]
y = x[start:end]
&lt;/pre&gt;


&lt;p&gt;
そもそもiterator, itarableって、名詞と形容詞以外の違いはあるんでしょうか。混乱してきたので整理します。
&lt;/p&gt;

&lt;p&gt;
&lt;a href="https://www.w3schools.com/python/python_iterators.asp"&gt;ここ&lt;/a&gt;がわかりやすく説明していました。
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;iteratorは、それをiterateする(1個ずつたどる)ことができるオブジェクト&lt;/li&gt;
&lt;li&gt;具体的にPythonでは、__iter__()と__next__()(=iterator protocol)を実装している&lt;/li&gt;
&lt;li&gt;リスト、タプル、ディクショナリ、セットは全てiterableオブジェクト&lt;/li&gt;
&lt;li&gt;これらはiterableな入れ物で、iter()メソッドを使ってiteratorを取り出すことができる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
うーむ、これまで厳密に区別していませんでした。
&lt;/p&gt;

&lt;p&gt;
itertoolsのisliceって何でしょう? &lt;a href="https://docs.python.org/3.8/library/itertools.html"&gt;ここ&lt;/a&gt;に説明がありました。
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
itertools.islice(iterable, stop)
&lt;/p&gt;

&lt;p&gt;
itertools.islice(iterable, start, stop[, step])
&lt;/p&gt;

&lt;p&gt;
Make an iterator that returns selected elements from the iterable. If start is non-zero, then elements from the iterable are skipped until start is reached. Afterward, elements are returned consecutively unless step is set higher than one which results in items being skipped. If stop is None, then iteration continues until the iterator is exhausted, if at all; otherwise, it stops at the specified position. Unlike regular slicing, islice() does not support negative values for start, stop, or step. 
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
「指定されたiterableから選択された要素を返すiteratorを作る。」
&lt;/p&gt;

&lt;p&gt;
これって、iterable[start:stop:stride]と何が違うんでしょうか???
Item 36にリンクが張ってあるので、そちらをチラ見してみます。
&lt;/p&gt;
&lt;pre class="example"&gt;
Use islice to slice an iterator by numerical indexes without copying.
&lt;/pre&gt;


&lt;p&gt;
おー、なるほど。大事なのはwithout copyingのところでしたか。
たくさんメモリを使いませんよ、ということですね。
&lt;/p&gt;

&lt;p&gt;
。。。後から考えてみると、itertools.islice()が返すのはiteratorで、next()等を使って回さないと一通りの結果がが得られないのに対し、iterable[&amp;#x2026;]の方は一式結果の揃ったリストが得られるので、その違いは明らかでした。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org61949b7" class="outline-3"&gt;
&lt;h3 id="org61949b7"&gt;&lt;span class="section-number-3"&gt;3.3&lt;/span&gt; Item 13: スライスするよりcatch-allのunpackingを使え&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-3-3"&gt;
&lt;p&gt;
こんなやつです。残りをリストにして返します。
&lt;/p&gt;
&lt;pre class="example"&gt;
largest, second, *others = [20, 19, 15, 9, 8, 5, 3, 1, 0]
print(largest, second, others)
&amp;gt;&amp;gt;&amp;gt;
20 19 [15, 9, 8, 5, 3, 1, 0]
&lt;/pre&gt;


&lt;p&gt;
catch-allの*othersは先頭や真ん中に来てもよい。
&lt;/p&gt;
&lt;pre class="example"&gt;
largest, *others, smallest = [20, 19, 15, 9, 8, 5, 3, 1, 0]
print(largest, others, smallest)
&amp;gt;&amp;gt;&amp;gt;
20 [19, 15, 9, 8, 5, 3, 1] 0
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org17927e9" class="outline-3"&gt;
&lt;h3 id="org17927e9"&gt;&lt;span class="section-number-3"&gt;3.4&lt;/span&gt; Item 14: 複雑な条件のソートではkeyパラメータを使え&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-3-4"&gt;
&lt;p&gt;
おっと、出ました。anonymousなlambda関数。
&lt;/p&gt;
&lt;pre class="example"&gt;
lambda x: x.name
&lt;/pre&gt;

&lt;p&gt;
のように使うのでした。この例ではxが引数。
&lt;/p&gt;

&lt;p&gt;
自作クラスのオブジェクトがメンバーであるリストをソートする時など、どのようにソートすればよいかPythonが判断できない場合には、ソートするkeyとして関数を渡してやります。
&lt;/p&gt;
&lt;pre class="example"&gt;
tools.sort(key=lambda x: x.name)
&lt;/pre&gt;

&lt;p&gt;
とすると、名前でソート。
&lt;/p&gt;
&lt;pre class="example"&gt;
tools.sort(key=lambda x: x.weight)
&lt;/pre&gt;

&lt;p&gt;
とすると、重さでソート。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org24a1541" class="outline-3"&gt;
&lt;h3 id="org24a1541"&gt;&lt;span class="section-number-3"&gt;3.5&lt;/span&gt; Item 15: ディクショナリに追加する順番が守られるとは限らない&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-3-5"&gt;
&lt;p&gt;
知りませんでした。Python 3.7から、ディクショナリに追加した順序を維持するようになったそうです。だからと言って、常にそうなることを前提にしてはいけない、という項目。ディクショナリの代わりにディクショナリライクな別のデータ構造が使われていた場合に、この前提が通用しないことがあります。
&lt;/p&gt;

&lt;p&gt;
3番目のアプローチの意味がわかりません。よく読んで考えてみると、type annotationsとは何か、知りませんでした。&lt;a href="https://dev.to/dstarner/using-pythons-type-annotations-4cfe"&gt;ここ&lt;/a&gt;に説明がありました。例えば以下の場合、
&lt;/p&gt;
&lt;pre class="example"&gt;
def combine(a: str b: str, time: int) -&amp;gt; str:
    return (a + b) * times
&lt;/pre&gt;

&lt;p&gt;
引数の後に付く「: &amp;lt;type&amp;gt;」は、その引数のタイプを示唆しています。示唆と書いたのは、これは純粋に読みやすさのためであって、実行時に強制しないという意です。更に -&amp;gt; &amp;lt;type&amp;gt;で、戻り値のタイプも示唆します。
&lt;/p&gt;

&lt;p&gt;
そして、実行時に以下のように-m mypyを指定して&amp;#x2013;strictを付けると、この示唆をチェックしてくれるようです。
&lt;/p&gt;
&lt;pre class="example"&gt;
$ pytyon3 -m mypy --strict example.py
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1c09470" class="outline-3"&gt;
&lt;h3 id="org1c09470"&gt;&lt;span class="section-number-3"&gt;3.6&lt;/span&gt; Item 16: 欠けているディクショナリのキーを扱うのに、inとKeyErrorよりもgetを使え&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-3-6"&gt;
&lt;p&gt;
見慣れない表現がありました、
&lt;/p&gt;
&lt;pre class="example"&gt;
votes[key] = names = []
&lt;/pre&gt;

&lt;p&gt;
これは、votes[key]とname両方に同じ[]への参照を代入する(ie, &lt;code&gt;votes[key] is names&lt;/code&gt;)、ということでした。
よく見るのは a = b = 100のような表現ですが、少し変わっただけでわからなくなりました。
&lt;/p&gt;

&lt;p&gt;
ディクショナリにキーが無かったときに初期化するやり方として、getを使うのが一番よいとのこと。次は、ディクショナリの指定キーの値を+1し、もしキーが存在しない場合はキーを追加した上で行うパターン。
&lt;/p&gt;
&lt;pre class="example"&gt;
count = counters.get(key, 0)
counters[key] = count + 1
&lt;/pre&gt;

&lt;p&gt;
別のパターンでも。値がリストになっていて、キーが存在しない時には空のリストを追加するもの。
&lt;/p&gt;
&lt;pre class="example"&gt;
if (names := votes.get(key)) is None:
    votes[key] = names = []
names.append(who)
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb50bb80" class="outline-3"&gt;
&lt;h3 id="orgb50bb80"&gt;&lt;span class="section-number-3"&gt;3.7&lt;/span&gt; Item 17: 内部状態に欠けている項目を扱うには、setdefaultよりもdefaultdictを使え&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-3-7"&gt;
&lt;p&gt;
「内部状態に欠けている項目」って何でしょう?
例として、行ったことのある国と、訪れた街をvalueとして街のセットを持つディクショナリとして表現するとします。
&lt;/p&gt;
&lt;pre class="example"&gt;
{'Japan': {'Kyoto', 'Yokohama'}, 'France': {'Paris'}}
&lt;/pre&gt;

&lt;p&gt;
のような感じで。ここに'England' - 'London'を追加するとき、まだ'England'は登録されていない＝欠けているという意味で使っているようです。「内部状態」もわかりにくいです。このデータ構造の中身のことをそう言っているのでしょうが。一つ前のitemと似ていますね。
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;指定キーが存在しなければ追加＆値を初期化した上で、&lt;/li&gt;
&lt;li&gt;指定キーに対する値を+1したり、リストを追加したり、etc. する&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
このユースケースでは次のようなヘルパー関数を書け、と言っています。
&lt;/p&gt;
&lt;pre class="example"&gt;
from collections import defaultdict

class Visits:
    def __init__(self):
	self.data = defaultdict(set)

    def add(self, country, city):
	self.data[country].add(city)
&lt;/pre&gt;

&lt;p&gt;
defaultdict(default_factory)は&lt;a href="https://docs.python.org/2/library/collections.html#collections.defaultdict"&gt;ここ&lt;/a&gt;によると、ディクショナリライクなオブジェクトを返す関数で、もし追加しようとするキーが無かったら、default_factory関数がキーに対するデフォルトの値を提供します。上の例ではdefaultdict(set)とあるので、空のセットが設定されます。
&lt;/p&gt;

&lt;p&gt;
defaultdictの説明がありませんが、この本はかなり高度な知識を前提としているか、調べながら読め、ということなのでしょうか。
&lt;/p&gt;

&lt;p&gt;
このヘルパー関数を使うことで、やりたいことが短く書けます。
&lt;/p&gt;
&lt;pre class="example"&gt;
visits = Visits()
visits.add('Japan', 'Kyoto')
visits.add('Canada', 'Calgary')
&lt;/pre&gt;


&lt;p&gt;
getとdefaultdictの使い分け:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;自分でディクショナリを作るならdefaultdictを使うことを考える&lt;/li&gt;
&lt;li&gt;既存のディクショナリに対して追加するなら、getを使う&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0a92cfe" class="outline-3"&gt;
&lt;h3 id="org0a92cfe"&gt;&lt;span class="section-number-3"&gt;3.8&lt;/span&gt; Item 18: __missing__()メソッドを使って、キー依存のデフォルト値を作る方法を知っておけ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-3-8"&gt;
&lt;p&gt;
dictのsetdefaultメソッドもdefaultdictも使えないとき、dictのサブクラスを作って__missing__メソッドを用意すればよい。
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="font-weight: bold; text-decoration: underline;"&gt;Pictures&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;dict&lt;/span&gt;):  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;dict&amp;#12398;&amp;#12469;&amp;#12502;&amp;#12463;&amp;#12521;&amp;#12473;&amp;#12434;&amp;#20316;&amp;#12427;&lt;/span&gt;
    &lt;span style="font-weight: bold;"&gt;def&lt;/span&gt; &lt;span style="font-weight: bold;"&gt;__missing__&lt;/span&gt;(&lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;, key):  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;key&amp;#12399;&amp;#20889;&amp;#30495;&amp;#12408;&amp;#12398;path&lt;/span&gt;
        &lt;span style="font-weight: bold; font-style: italic;"&gt;value&lt;/span&gt; = open_picture(key)  &lt;span style="font-weight: bold; font-style: italic;"&gt;# &lt;/span&gt;&lt;span style="font-weight: bold; font-style: italic;"&gt;&amp;#12501;&amp;#12449;&amp;#12452;&amp;#12523;&amp;#12495;&amp;#12531;&amp;#12489;&amp;#12523;&amp;#12434;&amp;#36820;&amp;#12377;&amp;#38306;&amp;#25968;&lt;/span&gt;
        &lt;span style="font-weight: bold;"&gt;self&lt;/span&gt;[key] = value
        &lt;span style="font-weight: bold;"&gt;return&lt;/span&gt; value

&lt;span style="font-weight: bold; font-style: italic;"&gt;pictures&lt;/span&gt; = Pictures()
&lt;span style="font-weight: bold; font-style: italic;"&gt;handle&lt;/span&gt; = pictures[path]
handle.seek(0)
&lt;span style="font-weight: bold; font-style: italic;"&gt;image_data&lt;/span&gt; = handle.read()
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
上記の例では、pathがpicturesに登録されていなかったときに__missing__メソッドが呼ばれます。open_picture(path)は、ここでは定義を省略しますが、指定パスのファイルをオープンしてハンドルを返す関数。オープンに失敗したら例外を上げます。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Python"></category><category term="Python"></category></entry><entry><title>emacsにelpyを導入する</title><link href="http://achiwa912.github.io/elpy.html" rel="alternate"></link><published>2020-08-14T00:00:00-04:00</published><updated>2020-08-14T00:00:00-04:00</updated><author><name>きょうす</name></author><id>tag:achiwa912.github.io,2020-08-14:/elpy.html</id><summary type="html">elpyでemacsをPython IDEにする</summary><content type="html">&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orgf7d28e2"&gt;1. はじめに&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgdf07538"&gt;2. emacsの嫌いなところ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgde26fe6"&gt;3. elpyとは&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org184d536"&gt;4. elpyの導入&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orgbf303f9"&gt;4.1. melpaリポジトリの追加&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgef08185"&gt;4.2. パッケージを読み込む&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org37a6aa0"&gt;4.3. パッケージをactivateする&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org374f93f"&gt;4.4. pipでインストールするパッケージを持ってくる&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgb7d3c34"&gt;4.5. 確認する&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgf66aadf"&gt;5. 終わりに&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf7d28e2" class="outline-2"&gt;
&lt;h2 id="orgf7d28e2"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; はじめに&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
私は以前、elpyの導入に失敗しています。elpyはemacsをPythonの統合環境(IDE)化するパッケージです。
&lt;/p&gt;

&lt;p&gt;
原因がよくわかりませんが、どう頑張っても動かなかったのです。3日くらい試行錯誤して断念しました。実力も無いのにemacsを使うのが悪いという話もありますが、指が慣れてしまっているので他の環境には移れないのです。
&lt;/p&gt;

&lt;p&gt;
最近Pythonに再入門してから、普通のエディタとしてemacsを使ってPythonのコードを書いてきました。IDEの自動補完機能を使う同僚を横目で見て、いつもうらやましく思っていました。そこで、一念発起して、再度elpyの導入にチャレンジしました。
&lt;/p&gt;

&lt;p&gt;
この記事は&lt;a href="https://realpython.com/emacs-the-best-python-editor/"&gt;Real Pythonの導入記事&lt;/a&gt;を &lt;del&gt;丸写し&lt;/del&gt; 参考にしています。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgdf07538" class="outline-2"&gt;
&lt;h2 id="orgdf07538"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; emacsの嫌いなところ&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
いきなりですが、emacsの嫌いなところです。emacs使いはいろいろな意味で上級者が多いです。初級者向けの導入記事はあまり無いか、あっても高度すぎて理解できないことがよくあります。
&lt;/p&gt;

&lt;p&gt;
設定ファイルの.emacs.d/init.elを書き換える時はいつも緊張します。導入記事のアドバイスの通り書いているはずなのに、意味不明のエラーをたくさん吐いて、emacsが使い物にならなくなるのです。
&lt;/p&gt;

&lt;p&gt;
emacs使いはきっと &lt;del&gt;マゾ&lt;/del&gt; 辛いことが好きなんだと思います。
&lt;/p&gt;

&lt;p&gt;
そんな訳で、emacsではいろいろな冒険ができないところが嫌いです。現状維持圧力を感じます。この10年でした冒険と言えば、org-modeを使い始めたことと、今回のelpy導入くらいです。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgde26fe6" class="outline-2"&gt;
&lt;h2 id="orgde26fe6"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; elpyとは&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
話を戻して、elpyについてです。elpyはEmacs Python Development Environmentのことで、次のようなPythonのIDE機能を提供します。
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;自動インデント(これは標準のpython-modeにもある)&lt;/li&gt;
&lt;li&gt;シンタックスハイライト&lt;/li&gt;
&lt;li&gt;自動補完&lt;/li&gt;
&lt;li&gt;シンタックスチェック&lt;/li&gt;
&lt;li&gt;Python REPL統合&lt;/li&gt;
&lt;li&gt;仮想環境サポート&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
更に、elpyと連動して動くパッケージを入れると、あなたのemacsがそのへんのIDEに負けない立派なIDEに変身します。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org184d536" class="outline-2"&gt;
&lt;h2 id="org184d536"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; elpyの導入&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgbf303f9" class="outline-3"&gt;
&lt;h3 id="orgbf303f9"&gt;&lt;span class="section-number-3"&gt;4.1&lt;/span&gt; melpaリポジトリの追加&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-4-1"&gt;
&lt;p&gt;
早速ですが、例のinit.elを編集します。
elpyはmelpaとかいうemacsのパッケージリポジトリから持ってくるため、emacsがmelpaを見に行くようにしなくてはいけません。この部分の私の設定は次のようになっています。
&lt;/p&gt;
&lt;pre class="example"&gt;
(require 'package)
(setq package-archives
       '(("gnu" . "http://elpa.gnu.org/packages/")
	("melpa" . "http://melpa.org/packages/")
	("org" . "http://orgmode.org/elpa/")))
(package-initialize)
(when (not package-archive-contents)
  (package-refresh-contents))
&lt;/pre&gt;

&lt;p&gt;
大事なのはこの部分です。
&lt;/p&gt;
&lt;pre class="example"&gt;
("melpa" . "http://melpa.org/packages/")
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgef08185" class="outline-3"&gt;
&lt;h3 id="orgef08185"&gt;&lt;span class="section-number-3"&gt;4.2&lt;/span&gt; パッケージを読み込む&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-4-2"&gt;
&lt;p&gt;
次は、melpa他から必要なパッケージを持ってきます。
このやり方はReal Pythonからいただいてきたのですが、なかなか良いです。
まずmyPackagesとして必要なパッケージを定義しておいて、その後インストールされていなかったらインストールまで自動でやってくれます。
&lt;/p&gt;

&lt;pre class="example"&gt;
(defvar myPackages
  '(better-defaults
    elpy
    flycheck          ;; On the fly syntax checking
    py-autopep8       ;; Run autopep8 on save
    blacken           ;; Black formatting on save
    material-theme
    )
  )
(mapc #'(lambda (package)
	  (unless (package-installed-p package)
	    (package-install package)))
      myPackages)
&lt;/pre&gt;

&lt;p&gt;
elpyの他にいろいろなパッケージを読んでいますが、簡単に説明します。
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;better-defaults - emacsのデフォルト設定でいまいちなところを改善してくれるようです。今のところ、何が変わったのかわかりませんが、なんとなく入れておきます。&lt;/li&gt;
&lt;li&gt;flycheck - オンザフライで文法チェックをしてくれます&lt;/li&gt;
&lt;li&gt;py-autopep8 - セーブ時にpep8準拠チェックをして勝手に修正してくれます&lt;/li&gt;
&lt;li&gt;blacken - セーブ時にBlackのフォーマットチェックをして勝手に修正してくれます&lt;/li&gt;
&lt;li&gt;material-theme - このテーマはなかなかいい感じだったので、これまで使っていたものから乗り換えました&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org37a6aa0" class="outline-3"&gt;
&lt;h3 id="org37a6aa0"&gt;&lt;span class="section-number-3"&gt;4.3&lt;/span&gt; パッケージをactivateする&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-4-3"&gt;
&lt;p&gt;
そして、パッケージを有効化します。
こちらもReal Pythonから念仏のように写経しただけですが、うまく動いてくれたようです。なお、ここでは一気に全て入れていますが、エラーが出るとどこが悪いのかわからなくなるので、少しずつ動かしながら足していくのがよいと思います。
&lt;/p&gt;

&lt;pre class="example"&gt;
(load-theme 'material t)

;; elpy
(elpy-enable)
(setq elpy-rpc-virtualenv-path 'current)

;; Flycheck
(when (require 'flycheck nil t)
  (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
  (add-hook 'elpy-mode-hook 'flycheck-mode))

;; autopep8
(require 'py-autopep8)
(add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save)
&lt;/pre&gt;

&lt;p&gt;
1カ所注意があります。私は人気のvirtualenvではなくてvenvを使っているので、最初出ていたエラーメッセージに従って、次のようにしました。もし副作用があったらごめんなさい。
&lt;/p&gt;
&lt;pre class="example"&gt;
(setq elpy-rpc-virtualenv-path 'current)
&lt;/pre&gt;


&lt;p&gt;
そしてこれをしたことで、~/.local/binを環境変数PATHに入れるよう言われたので、~/.zshrc(macOSです)を修正しました。
&lt;/p&gt;
&lt;pre class="example"&gt;
export PATH="$HOME/.local/bin:$PYENV_ROOT/bin:$PATH"
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org374f93f" class="outline-3"&gt;
&lt;h3 id="org374f93f"&gt;&lt;span class="section-number-3"&gt;4.4&lt;/span&gt; pipでインストールするパッケージを持ってくる&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-4-4"&gt;
&lt;p&gt;
melpaから持ってこられないパッケージをpipを使って持ってきます。
&lt;/p&gt;
&lt;pre class="example"&gt;
pip3 install jedi flake8 autopep8 yapf black
&lt;/pre&gt;

&lt;p&gt;
こんな感じだったと思います。実際は一つずつインストールしたので、historyを見て書きました。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb7d3c34" class="outline-3"&gt;
&lt;h3 id="orgb7d3c34"&gt;&lt;span class="section-number-3"&gt;4.5&lt;/span&gt; 確認する&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-4-5"&gt;
&lt;p&gt;
pythonの.pyファイルを開いてM-x elpy-configと入れ、リターンキーを押します。
&lt;img src="./images/elpy-config.png" alt="elpy-config.png" /&gt;
&lt;/p&gt;

&lt;p&gt;
今回はうまくいきました。持ってきたパッケージは一通り認識されていました。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf66aadf" class="outline-2"&gt;
&lt;h2 id="orgf66aadf"&gt;&lt;span class="section-number-2"&gt;5&lt;/span&gt; 終わりに&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;p&gt;
上でも挙げた&lt;a href="https://realpython.com/emacs-the-best-python-editor/"&gt;Real Pythonの導入記事&lt;/a&gt;はemacsの説明から始まるので、うっかり見落とすところでしたが、さんざん検索した中で一番役に立った記事でした。初級者向けのemacs記事は少ないのでありがたいです。Real Pythonさん、どうもありがとうございます。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Python"></category><category term="Python"></category><category term="emacs"></category></entry><entry><title>世界一売れている"Python Crash Course"って、どんな本?</title><link href="http://achiwa912.github.io/pycrash.html" rel="alternate"></link><published>2020-08-04T00:00:00-04:00</published><updated>2020-08-04T00:00:00-04:00</updated><author><name>きょうす</name></author><id>tag:achiwa912.github.io,2020-08-04:/pycrash.html</id><summary type="html">Python本の紹介</summary><content type="html">&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org65910e3"&gt;1. はじめに&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org0e1a042"&gt;2. Python Crash Courseの紹介&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orgbea7b6a"&gt;2.1. 結論&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgabb7a30"&gt;2.2. 本書の構成&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org47d58e6"&gt;2.2.1. Part I: BASICS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org8da58b2"&gt;2.2.2. Part II: PROJECTS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgacc6b08"&gt;2.3. 優れている点&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org96eeecb"&gt;2.3.1. 説明がわかりやすい&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org3dff634"&gt;2.3.2. 豊富なハンズオン&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org0ec8804"&gt;2.3.3. 実践的なプロジェクト&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgef1b5d1"&gt;3. 英語で技術書を読む&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org37f2868"&gt;4. 終わりに&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org65910e3" class="outline-2"&gt;
&lt;h2 id="org65910e3"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; はじめに&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Pythonの推薦本を英語で検索すると、どのWebサイトでも大抵紹介されている&lt;a href="https://www.amazon.com/Python-Crash-Course-Hands-Project-Based/dp/1593276036"&gt;Python Crash Course: A Hands-On, Project-Based Introduction to Programming&lt;/a&gt;, Eric Matthes。Amazonのレビューを見ても大絶賛で、&lt;a href="https://nostarch.com/pythoncrashcourse2e"&gt;公式サイト&lt;/a&gt;によると世界で一番売れているPython本だそうです。
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
Python Crash Course is the world’s best-selling guide to the Python programming language.
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
私はこの本を使ってPythonに入門しました。この記事では、Python Crash Courseの紹介をしたいと思います。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0e1a042" class="outline-2"&gt;
&lt;h2 id="org0e1a042"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; Python Crash Courseの紹介&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;

&lt;div id="org38c968a" class="figure"&gt;
&lt;p&gt;&lt;img src="./images/pcc_title.png" alt="pcc_title.png" /&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgbea7b6a" class="outline-3"&gt;
&lt;h3 id="orgbea7b6a"&gt;&lt;span class="section-number-3"&gt;2.1&lt;/span&gt; 結論&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-1"&gt;
&lt;p&gt;
いきなり結論ですが、Python Crash Course (以下Crash Courseと略)はとても優れたPython入門書でした。あらゆるレベルの入門者に勧められると思います。特に優れているのが以下の点です。
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;豊富なハンズオン&lt;/li&gt;
&lt;li&gt;実践的な3つの異なるプロジェクト&lt;/li&gt;
&lt;li&gt;丁寧でわかりやすい説明&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgabb7a30" class="outline-3"&gt;
&lt;h3 id="orgabb7a30"&gt;&lt;span class="section-number-3"&gt;2.2&lt;/span&gt; 本書の構成&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-2"&gt;
&lt;p&gt;
Crash CourseはPart I: BASICSとPART II: PROJECTSの2パートに分かれます。
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org47d58e6" class="outline-4"&gt;
&lt;h4 id="org47d58e6"&gt;&lt;span class="section-number-4"&gt;2.2.1&lt;/span&gt; Part I: BASICS&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-2-1"&gt;
&lt;p&gt;
Part IでPythonの基本について説明します。本のタイトルに「ハンズオン」が含まれているだけあって、code snippetsを入力し、実際に動かしながら頭で理解したことを体(手)に覚え込ませていきます。code snippetsの出し方も上手です。一つのファイルの部分が少しずつ出てきて、一度に入力する量もいい案配です。
&lt;/p&gt;


&lt;div id="org77ce2f5" class="figure"&gt;
&lt;p&gt;&lt;img src="./images/pcc_snippets.png" alt="pcc_snippets.png" /&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
比較的短めの各章の最後には、TRY IT YOURSELFというハンズオンがあり、短いサイクルで復習します。体で覚え、定着させるには繰り返しが重要ですが、そのために必要十分なハンズオンの量になっていると思います。
&lt;/p&gt;


&lt;div id="orgd7355b5" class="figure"&gt;
&lt;p&gt;&lt;img src="./images/pcc_tryit.png" alt="pcc_tryit.png" /&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org8da58b2" class="outline-4"&gt;
&lt;h4 id="org8da58b2"&gt;&lt;span class="section-number-4"&gt;2.2.2&lt;/span&gt; Part II: PROJECTS&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-2-2"&gt;
&lt;p&gt;
Part IIはPart Iで覚えたPythonの基礎知識を使って、プロジェクト形式である程度まとまったプログラムを組みます。これが実践的でとても楽しかったです。
&lt;/p&gt;

&lt;p&gt;
最初のプロジェクトはインベーダーゲーム似のシューティングゲームを作ります。ゲームライブラリとしてはpygameを使います。個人的にはこれがヒットでした。プロジェクトを終えたら、読むのをやめてゲーム作りしようと思ったくらいです。(ぐっと堪えてプロジェクト3まで勧めましたが)
&lt;/p&gt;

&lt;p&gt;
Pythonはbattery includedと言われるだけあって、標準以外のライブラリが充実しています。ライブラリの導入の仕方、使い方を覚えるのも大事です。プロジェクトでは、ライブラリをどうやって使いこなすかがわかるようになっています。
&lt;/p&gt;

&lt;p&gt;
プロジェクトでは、通常の開発と同様に少しずつ作っていきます。最初は自機のビットマップを表示するだけ、次にキーで動かす、更に敵を1機表示する、ループで大量に表示する、弾を打つ、敵をやっつける、etc.。少しずつプログラムが出来てくるのが楽しいです。
&lt;/p&gt;

&lt;p&gt;
プログラムが成長するにつれて、リファクタリングすることもハンズオンとして学びます。長くなりすぎた部分を関数として切り出して独立させます。Pythonの入門書ですが、こういった、ソフトウエア開発で一般に必要になることもカバーしています。
&lt;/p&gt;

&lt;p&gt;
次のプロジェクトは、ネットから入手できるデータをmatplotlib等のライブラリを使ってビジュアル化します。スクレイピングの基礎の基礎のようなことをします。このプロジェクトは実践的で、即実用になりますが、若干掘り下げが足りないように思いました。入門書にそこまで求めるのはやりすぎでしょうか。。。繰り返しますが、このプロジェクトで学んだ内容はすぐにでも応用が利きます。
&lt;/p&gt;

&lt;p&gt;
最後のプロジェクトは、Djangoを使って動的ブログジェネレーター的なものを作ります。野心的なプロジェクトですが、本書のスペース不足のせいか、いきなり難易度が上がります。難しいのはPythonではなく、Djangoの使い方なのですが。慣れないDjangoの設定ファイルやhtmlファイルを大量に書くのは大変で、動かなかったときのデバッグは更に厳しいです。
&lt;/p&gt;

&lt;p&gt;
個人的には、本文のハンズオンを2回繰り返し、TRY IT YOURSELFまでやって、やっとDjangoの使い方がわかってきました。本書を離れて、DjangoについてWebで調べたりもしました。ここまでやると、だいぶ力が付くのでは無いかと思います。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgacc6b08" class="outline-3"&gt;
&lt;h3 id="orgacc6b08"&gt;&lt;span class="section-number-3"&gt;2.3&lt;/span&gt; 優れている点&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-3"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org96eeecb" class="outline-4"&gt;
&lt;h4 id="org96eeecb"&gt;&lt;span class="section-number-4"&gt;2.3.1&lt;/span&gt; 説明がわかりやすい&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-3-1"&gt;
&lt;p&gt;
私はこの本の他には&lt;a href="https://www.amazon.com/Introducing-Python-Modern-Computing-Packages/dp/1449359361"&gt;Introducing Python&lt;/a&gt;しか読んでいないので、他にもわかりやすいPython入門書はあるかもしれません。しかし、それにしてもCrash Courseの説明はとてもわかりやすかったです。
&lt;/p&gt;

&lt;p&gt;
説明が上手なことがありますが、説明すべき内容の絞り方もうまいです。枝葉のことがあまり書いて無い一方で、大事なことは繰り返し出てきます。この本はまず基本概念(例えば「リストとは」)を説明し、繰り返しのハンズオンで定着させるスタイルなので、最初のわかりやすさは特に重要です。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3dff634" class="outline-4"&gt;
&lt;h4 id="org3dff634"&gt;&lt;span class="section-number-4"&gt;2.3.2&lt;/span&gt; 豊富なハンズオン&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-3-2"&gt;
&lt;p&gt;
入門書を読んだばかりの初心者がいざコーディングしようとすると「forループはどうやって回すのだっけ」や「else ifだっけ、elifだっけ」、「":"は付ける? いらない?」といったことで悩みます(私だけ?)。そして、いざ動かしてみてエラーが出ると、エラーメッセージの意味もわからず、何がどう悪いのか見当もつきません。こうして、挫折してしまうパターンが意外と多いように思います。
&lt;/p&gt;

&lt;p&gt;
これを乗り越える(私が思うに)唯一の方法が、ハンズオンで体(手)に覚え込ませることです。本書の最も優れた特長は、ハンズオンが豊富にあるということで、上で挙げたようなことは、悩む前に体が覚えてしまいます。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0ec8804" class="outline-4"&gt;
&lt;h4 id="org0ec8804"&gt;&lt;span class="section-number-4"&gt;2.3.3&lt;/span&gt; 実践的なプロジェクト&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-3-3"&gt;
&lt;p&gt;
豊富なハンズオンと並んで本書のすぐれた特長であるのが、3つの実践的なプロジェクトです。プロジェクトを通じて、Pythonの基本だけでなく、ソフトウエア開発について総合的に学ぶことができます。
&lt;/p&gt;

&lt;p&gt;
入門書を終えたばかりのレベルと、実際にコーディングできるレベルの間には溝があると思いますが、ハンズオンプロジェクトがこの溝を埋めてくれます。500ページ以上と、少し構えてしまう長さの本ですが、一般的な入門書の範疇を超えた内容をカバーしているので決して長すぎないと思います。(日本語の本なら、上下巻に分かれるでしょうか)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgef1b5d1" class="outline-2"&gt;
&lt;h2 id="orgef1b5d1"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; 英語で技術書を読む&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
Python Crash Courseはとても優れたPython入門書ですが、なぜか日本語には翻訳されていませんね。(売れると思うのに。。)
&lt;/p&gt;

&lt;p&gt;
個人的に、英語の技術書を読むことはとてもお勧めです。技術書の英語は平易で、高校生以上の、英語アレルギーが無い人であれば読めると思います。(なお、上で挙げたIntroducing Pythonの英語は少しだけ難しいので、英語を読むのが初めてな人には勧めません。とてもよい本ですが、初心者向け入門書ではありません。)
&lt;/p&gt;

&lt;p&gt;
また、英語を読むことに慣れてくると、日本語よりもはるかに豊富なインターネット上の技術情報にアクセスできるようになります。
&lt;/p&gt;

&lt;p&gt;
Pythonに入門したいけどよい参考書は無いか、と探している方は、英語の勉強も兼ねて、Python Crash Courseを使って入門してみるのはいかがでしょうか。
&lt;/p&gt;

&lt;p&gt;
なお、2章まるまるこちらからダウンロードできます。
&lt;a href="https://nostarch.com/pythoncrashcourse2e"&gt;https://nostarch.com/pythoncrashcourse2e&lt;/a&gt;
画面写真はこの2章を使いました。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org37f2868" class="outline-2"&gt;
&lt;h2 id="org37f2868"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; 終わりに&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
私はPython Crash Courseを使って、ようやく挫折せずにPythonでプログラムが組めるようになりました。感謝の気持ちを込めて、この記事で紹介させていただきました。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Python"></category><category term="Python"></category></entry><entry><title>PDFファイルにページ番号を追加する方法(Pythonで)</title><link href="http://achiwa912.github.io/pdfpagenum.html" rel="alternate"></link><published>2020-08-02T00:00:00-04:00</published><updated>2020-08-02T00:00:00-04:00</updated><author><name>きょうす</name></author><id>tag:achiwa912.github.io,2020-08-02:/pdfpagenum.html</id><summary type="html">PDFファイルにページ番号を追加する方法(Pythonで)</summary><content type="html">&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orgf8068ae"&gt;1. はじめに&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org8216c5f"&gt;2. ReportLab PDFライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org63881ea"&gt;3. ReportLab + pdfrwを組み合わせる&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org547f904"&gt;4. 使用方法&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org14840a8"&gt;4.1. カスタマイズ方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#org2d56b01"&gt;5. 終わりに&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf8068ae" class="outline-2"&gt;
&lt;h2 id="orgf8068ae"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; はじめに&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
小学生の娘が算数で間違った問題を、スキャンしてまとめてPDF化しています。しかし、必要なページだけ印刷したつもりが、結構ページ番号がずれていて、何度もやりなおしたりしています。電子化したつもりが意外とアナログです。そこで、自動でPDFファイルにページ番号を付けたいと思いました。ヒューマンエラーによるページ番号のずれが防げる、またはずれてもすぐに気がつくので。
&lt;/p&gt;

&lt;p&gt;
しかし、PDFにページ番号を付けたいという単純なことなのに、意外にも良い実現方法が見つかりません。検索した結果、いくつかWebサービスを見つけて試してみましたが、あるものはページを入れる位置が気に入らない、またあるものは、たくさんページ番号を付けていると有料になる(しかも月極subscription)などでした。
&lt;/p&gt;

&lt;p&gt;
そこで、最近使えるようになって気を良くしているPythonで、PDFにページ番号が付けられないか調べてみたのですが、このユースケースに対応するPDFライブラリは無さそう(少なくとも単体では)、ということがわかりました。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org8216c5f" class="outline-2"&gt;
&lt;h2 id="org8216c5f"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; ReportLab PDFライブラリ&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
PythonでのPDFライブラリで有名なものは、PyPDF2, pdfrwあたりのようです。これらは、複数のPDFファイルをマージしたり、逆に分割したり、ページを入れ替えたりといったことが得意ですが、「既存PDFファイルにページ番号を付加する」というユースケースには対応していないようです。
&lt;/p&gt;

&lt;p&gt;
更に調べてみると、どうやらReportLabライブラリでページ番号を付けられそうだ、ということがわかりました。
&lt;a href="https://www.blog.pythonlibrary.org/2013/08/12/reportlab-how-to-add-page-numbers/"&gt;https://www.blog.pythonlibrary.org/2013/08/12/reportlab-how-to-add-page-numbers/&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
このWebページはとても期待させるタイトルなのですが、サンプルコードを見てみると疑問がわいてきます。そもそも、既存PDFファイルを読み込んでおらず、新規に作成したPDFのページにページ番号を付与しているようです。駄目じゃん。。。
&lt;/p&gt;

&lt;p&gt;
マニュアルにも一通り目を通してみます。
&lt;a href="https://www.reportlab.com/docs/reportlab-userguide.pdf"&gt;https://www.reportlab.com/docs/reportlab-userguide.pdf&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
ここでも、既存PDFファイルを読み込む説明はありませんでした。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org63881ea" class="outline-2"&gt;
&lt;h2 id="org63881ea"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; ReportLab + pdfrwを組み合わせる&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
それでも諦めずに検索を続けたところ、見つけました。
&lt;a href="https://stackoverflow.com/questions/28281108/reportlab-how-to-add-a-footer-to-a-pdf-file"&gt;https://stackoverflow.com/questions/28281108/reportlab-how-to-add-a-footer-to-a-pdf-file&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
さすがstackoverflow! 日本のqiitaと並んで大好きです。
どうやら、ReportLabとpdfrwを組み合わせるとできそうなことが書いてあります。
気になる記述もありますが。。。
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
DISCLAIMER: Tested on Linux using as input file a pdf file generated by Reportlab. It would probably not work in an arbitrary pdf file.
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
「ReportLabで作成したPDFファイルでテストしたけど、任意のPDFファイルだと動かないんじゃないかな」
&lt;/p&gt;

&lt;p&gt;
・・・えー!! でもこれしか頼れる物がありません。試してみましょう。
&lt;/p&gt;

&lt;p&gt;
stakoverflowのページに載っているサンプルコードを改変してみます。
&lt;/p&gt;
&lt;pre class="example"&gt;
from reportlab.pdfgen.canvas import Canvas
from pdfrw import PdfReader
from pdfrw.toreportlab import makerl
from pdfrw.buildxobj import pagexobj
import sys
import os

if len(sys.argv) != 2 or ".pdf" not in sys.argv[1].lower():
    print(f"Usage: python {sys.argv[0]} &amp;lt;pdf filename&amp;gt;")
    sys.exit()
input_file = sys.argv[1]
output_file = os.path.splitext(sys.argv[1])[0] + "_pgn.pdf"

reader = PdfReader(input_file)
pages = [pagexobj(p) for p in reader.pages]

canvas = Canvas(output_file)

for page_num, page in enumerate(pages, start=1):
    canvas.doForm(makerl(canvas, page))

    footer_text = f"{page_num}/{len(pages)}"
    canvas.saveState()
    canvas.setStrokeColorRGB(0, 0, 0)
    canvas.setFont('Times-Roman', 14)
    canvas.drawString(290, 10, footer_text)
    canvas.restoreState()
    canvas.showPage()

canvas.save()
&lt;/pre&gt;

&lt;p&gt;
そして実行すると、、、、
&lt;img src="./images/pdfpage.png" alt="pdfpage.png" /&gt;
あれ、さくっと動いてしまいました。念のため、ページの下に書いてある7/88というところが、今回入れたページ番号です。あのdisclaimerは何だったのか。。。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org547f904" class="outline-2"&gt;
&lt;h2 id="org547f904"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; 使用方法&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
f-stringを使っているので、python 3.6以降で使ってください。
&lt;/p&gt;

&lt;p&gt;
PDFライブラリインストール
&lt;/p&gt;
&lt;pre class="example"&gt;
pip install reportlab
pip install pdfrw
&lt;/pre&gt;


&lt;p&gt;
上記コードをaddpagenum.pyとしてセーブ。(ファイル名は好きに変えてください)
&lt;/p&gt;

&lt;p&gt;
実行
&lt;/p&gt;
&lt;pre class="example"&gt;
python addpagenum.py &amp;lt;pdf_filename&amp;gt;
&lt;/pre&gt;


&lt;p&gt;
ページ番号はA4でページ中央下に表示します。
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org14840a8" class="outline-3"&gt;
&lt;h3 id="org14840a8"&gt;&lt;span class="section-number-3"&gt;4.1&lt;/span&gt; カスタマイズ方法&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-4-1"&gt;
&lt;p&gt;
このあたりを適当に変えてください。
&lt;/p&gt;
&lt;pre class="example"&gt;
footer_text = f"{page_num}/{len(pages)}"
canvas.setFont('Times-Roman', 14)
canvas.drawString(290, 10, footer_text)
&lt;/pre&gt;


&lt;ul class="org-ul"&gt;
&lt;li&gt;表示内容を変える場合はfooter_textを変える&lt;/li&gt;
&lt;li&gt;ページ番号表示位置を変えたい場合は、x=290, y=10を変える&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
なお、ReportLabのcanvasにおいて、座標の(x=0, y=0)はページ左下になっています。
A4以外のLetter等にしたい場合は、canvasオブジェクトを作成する際に指定します。
詳しくはReportLabマニュアルを参照してください。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org2d56b01" class="outline-2"&gt;
&lt;h2 id="org2d56b01"&gt;&lt;span class="section-number-2"&gt;5&lt;/span&gt; 終わりに&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;p&gt;
このスクリプトはgithubにも載せました。
&lt;a href="https://github.com/achiwa912/pdfpagenum"&gt;https://github.com/achiwa912/pdfpagenum&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
上のコードをコピペした方が早いですが。。。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Python"></category><category term="Python"></category></entry><entry><title>昔のプログラマーがPython入門に失敗〜対戦テトリスが作れるようになるまで</title><link href="http://achiwa912.github.io/learn_python.html" rel="alternate"></link><published>2020-07-21T00:00:00-04:00</published><updated>2020-07-25T00:00:00-04:00</updated><author><name>きょうす</name></author><id>tag:achiwa912.github.io,2020-07-21:/learn_python.html</id><summary type="html">挫折の末のpython再入門</summary><content type="html">&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org7522deb"&gt;1. はじめに&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org5acbfe1"&gt;2. 自己紹介と挫折遍歴&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orgf06677a"&gt;2.1. 昔はプログラマーでした&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgf200d2d"&gt;2.2. 脱プログラマー&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgd05c665"&gt;2.3. 挫折遍歴&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org455d4e9"&gt;2.3.1. まずはJavaに挫折&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgc8a36f5"&gt;2.3.2. Pythonまで挫折&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgd982f37"&gt;3. Python再入門&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org1151568"&gt;3.1. 挫折の原因を分析してみる&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgf7ad2fc"&gt;3.2. フェーズ1 - Introducing Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org6a47320"&gt;3.3. フェーズ2 - Python Crash Course&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#org6dd08c3"&gt;4. 初めてのPythonプログラム自作&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orge1e4b6f"&gt;4.1. 何を作るか&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgd34a231"&gt;4.2. arcadeライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org4a7ee39"&gt;4.3. テトリスの実装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org99cd9ba"&gt;4.4. スプライトエディタ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgf2b1fed"&gt;4.5. ブロックを一つ表示する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org876361e"&gt;4.6. テトリスブロックの表示&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgbb1b957"&gt;4.7. 対戦テトリス化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org9478ab6"&gt;4.8. コズメティクス&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgce14842"&gt;5. 公開してみる&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orgef4e71b"&gt;5.1. githubに公開する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org1a977ba"&gt;5.2. プルリクエストに動揺する&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#org8807108"&gt;6. クロージング&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7522deb" class="outline-2"&gt;
&lt;h2 id="org7522deb"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; はじめに&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Pythonの勉強をしたのに、使えるようにならなかった、という経験はありませんか?
この記事では、自分の挫折経験を元に、そういう方のための道しるべを提示できれば
と思います。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5acbfe1" class="outline-2"&gt;
&lt;h2 id="org5acbfe1"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; 自己紹介と挫折遍歴&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgf06677a" class="outline-3"&gt;
&lt;h3 id="orgf06677a"&gt;&lt;span class="section-number-3"&gt;2.1&lt;/span&gt; 昔はプログラマーでした&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-1"&gt;
&lt;p&gt;
私は大学生時代、組み込み系プログラマーのアルバイトをしていました。
アセンブラーやC言語をを使って、人工心肺のステッピングモーターを制御するような
ニッチなプログラミングをしていました。
&lt;/p&gt;

&lt;p&gt;
私生活では、NECのPC-88やPC-98向けにゲームを作ることを夢見て、当時の有名ゲーム
から借用した高速スクロールルーチンをやはりアセンブラーで作ったり、ピクセル
エディターやマップエディターを作ったりしていました。更には、任天堂の
スーパーファミコン向けゲームの開発にヘルプ参加しました。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf200d2d" class="outline-3"&gt;
&lt;h3 id="orgf200d2d"&gt;&lt;span class="section-number-3"&gt;2.2&lt;/span&gt; 脱プログラマー&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-2"&gt;
&lt;p&gt;
その後、興味の中心は英語に移りました。業務で必要な本をあえて英語版で読んだり、
寝ても覚めて英語漬けの日が数年間続き、プログラミングからはすっかり遠ざかり
ました。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd05c665" class="outline-3"&gt;
&lt;h3 id="orgd05c665"&gt;&lt;span class="section-number-3"&gt;2.3&lt;/span&gt; 挫折遍歴&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-3"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org455d4e9" class="outline-4"&gt;
&lt;h4 id="org455d4e9"&gt;&lt;span class="section-number-4"&gt;2.3.1&lt;/span&gt; まずはJavaに挫折&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-3-1"&gt;
&lt;p&gt;
6年ほど前にエンジニアとして海外勤務する機会を得ました。日本と異なる、効率の
よい開発に驚くと共に、技術力の重要性を改めて痛感しました。当時、QAあるいは
Product Ownerとして開発チームに参加しており、プログラミングは必要ありません
でしたが、Javaの分厚い入門書(&lt;a href="https://www.amazon.com/Head-First-Java-Kathy-Sierra/dp/0596009208"&gt;Head First Java&lt;/a&gt;)を読みました。
&lt;/p&gt;

&lt;p&gt;
本人の期待に反して、Javaでプログラミングできるようにはなりませんでした。
JavaはCと似ているので、Javaのコードはある程度読めるようになりました。
しかし、自分でコーディングすることはできません。&lt;a href="https://www.amazon.com/Head-First-Design-Patterns-Brain-Friendly/dp/0596007124"&gt;Head First Design Patterns&lt;/a&gt;
や&lt;a href="https://www.amazon.com/Effective-Java-Joshua-Bloch/dp/0134685997"&gt;Effective Java&lt;/a&gt;にも手を出しましたが、読むそばから前に書かれたことを忘れて
いく上に、特に後者は難易度が高く、挫折しました。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgc8a36f5" class="outline-4"&gt;
&lt;h4 id="orgc8a36f5"&gt;&lt;span class="section-number-4"&gt;2.3.2&lt;/span&gt; Pythonまで挫折&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-3-2"&gt;
&lt;p&gt;
自分なりに挫折の原因を考えた結果、Javaは趣味の言語としては本格的すぎる
との結論に達しました。そこで、プログラミング入門者や子供にも大人気の
Pythonを学ぶことにしました。
&lt;/p&gt;

&lt;p&gt;
テキストとして、Webで評判の良かった&lt;a href="https://www.amazon.com/Introducing-Python-Modern-Computing-Packages/dp/1449359361"&gt;Introducing Python&lt;/a&gt;を選びました。
一通り制御構造について学んだ頃、何かが違うことに気がつきます。
前に読んだことをどんどん忘れていくのです。もう一度最初から読み始め
ました。しばらく進むと、前半を忘れていることがわかり、また最初から
読み直す、ということを2回ほど繰り返して、なんとPythonまで挫折してしまい
ました。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd982f37" class="outline-2"&gt;
&lt;h2 id="orgd982f37"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; Python再入門&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org1151568" class="outline-3"&gt;
&lt;h3 id="org1151568"&gt;&lt;span class="section-number-3"&gt;3.1&lt;/span&gt; 挫折の原因を分析してみる&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-3-1"&gt;
&lt;p&gt;
今年になって、COVID-19のおかげで自宅アパートに引きこもっていた時に、
またプログラミングできるようになりたいという意識が再燃しました。
今度はこれまでのような失敗は繰り返したくありません。自分なりに失敗の
原因を考えた結果、以下の結論に達しました。
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;テキストを読み進めると、前に書かれたことを忘れてしまう&lt;/li&gt;
&lt;li&gt;面倒くさがって演習をスキップしていた&lt;/li&gt;
&lt;li&gt;ハンズオンが足りなかった&lt;/li&gt;
&lt;li&gt;手が覚えなかった&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
ようは、手がプログラミングを覚えるまでのハンズオンが足りなかったという
ことです。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf7ad2fc" class="outline-3"&gt;
&lt;h3 id="orgf7ad2fc"&gt;&lt;span class="section-number-3"&gt;3.2&lt;/span&gt; フェーズ1 - Introducing Python&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-3-2"&gt;
&lt;p&gt;
テキストとして、以前使っていたIntroducing Pythonをまた使います。今回は
演習もきっちりやります。この本は、説明が簡潔で、多くの範囲をカバーして
おり、なかなかよい本です。
今回は途中のコードサンプルを「写経」(エディタで書き写すこと)しながら、
何とか最後まで読み進めました。
&lt;/p&gt;

&lt;p&gt;
一定の手応えは感じたものの、やはりプログラミングできるようにはなりま
せんでした。例えば、「for文でループする方法」や「else ifかelifか」と
いうことをいちいち見直したり、ネットで検索しないと書けないのです。
&lt;/p&gt;

&lt;p&gt;
この本はPythonの「入門」には向いていない、ということにようやく気がつき
ました。入門を終えた人が、頭の中を整理しながら読み進める本だったのです。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6a47320" class="outline-3"&gt;
&lt;h3 id="org6a47320"&gt;&lt;span class="section-number-3"&gt;3.3&lt;/span&gt; フェーズ2 - Python Crash Course&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-3-3"&gt;
&lt;p&gt;
2冊目として選んだのは、いかにも初心者向けな表紙の&lt;a href="https://www.amazon.com/Python-Crash-Course-Eric-Matthes-ebook/dp/B07J4521M3"&gt;Python Crash Course&lt;/a&gt;
です。この本はハンズオン中心です。本文に書かれたコードサンプルや演習まで
やると、実に多くの写経量です。
&lt;/p&gt;

&lt;p&gt;
この本のPart I: Basicsはよく書かれていますが、Part II: Projectsは
素晴らしいです。最初のプロジェクトはPygameライブラリを使って、インベーダー
ゲーム風のゲームを作ります。とりあえずPythonでゲームを作れるようになり
たかった私のニーズにぴったり一致しました。
&lt;/p&gt;

&lt;p&gt;
次のプロジェクトは、インターネットで集めてきたデータをグラフを使って
ビジュアル化するという、実に実践的な内容です。普段、Excelなどを使って
半ば手動でグラフを描いたりしているかもしれませんが、これをPythonで
自動で処理するやり方を学べます。
&lt;/p&gt;

&lt;p&gt;
最後のプロジェクトは野心的で、Djangoを使ってWebアプリケーションを
作ります。紙面の都合で説明のスペースが十分取れなかったためか、
いきなり難易度が上がります。しかし、しっかり腰を落ち着けて取り組み、
復習もしつつ演習のブログ的なWebアプリケーションまでこなすと、
非常に力が付くと思います。
&lt;/p&gt;

&lt;p&gt;
この本をこなして、ようやくPythonでプログラムが書ける自信が付きました。
やはり私のような初心者の段階で必要だったのは、手が覚えるようになるまでの
ハンズオンだったのです。
&lt;/p&gt;

&lt;p&gt;
中上級にはほど遠いとは思いますが、ここまで来ると、ネットで検索しながら
やりたいことをプログラムにしていけるようになると思います。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6dd08c3" class="outline-2"&gt;
&lt;h2 id="org6dd08c3"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; 初めてのPythonプログラム自作&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orge1e4b6f" class="outline-3"&gt;
&lt;h3 id="orge1e4b6f"&gt;&lt;span class="section-number-3"&gt;4.1&lt;/span&gt; 何を作るか&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-4-1"&gt;
&lt;p&gt;
私は最初からゲームが念頭にあったので、昔PC98向けにアセンブラーで
作った対戦テトリスを作ることにしました。やりたいことが決まっている人
はそれをやればいいと思いますが、最初から最後まで自分でデザインできる
ゲームを最初のプロジェクトとして選ぶことはお勧めです。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd34a231" class="outline-3"&gt;
&lt;h3 id="orgd34a231"&gt;&lt;span class="section-number-3"&gt;4.2&lt;/span&gt; arcadeライブラリ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-4-2"&gt;
&lt;p&gt;
ネットを調べるうちに、ちまたで人気のpygameライブラリよりも、大学の
先生が開発する&lt;a href="https://arcade.academy/"&gt;arcadeライブラリ&lt;/a&gt;の方がコンピューターサイエンス的に
エレガントと思い、arcadeライブラリを使うことにしました。
&lt;/p&gt;

&lt;p&gt;
arcadeライブラリのサイトには、チュートリアルやサンプルが多く載って
おり、まずはそれらを写経するところから始めます。Pythonの言語を学ぶ
以外に、使用するライブラリやフレームワークについて学ぶことは重要です。
&lt;/p&gt;

&lt;p&gt;
その際にも、初級者はチュートリアルやサンプルコードを写経するところ
から始めるのがよいと思います。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org4a7ee39" class="outline-3"&gt;
&lt;h3 id="org4a7ee39"&gt;&lt;span class="section-number-3"&gt;4.3&lt;/span&gt; テトリスの実装&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-4-3"&gt;
&lt;p&gt;
「Python」「Tetris」あたりのキーワードでネットを検索すると、実に多く
のサイトがテトリスの作り方を公開してくれています。見た目や細部に
こだわらなければ、150行くらいで済むようです。
&lt;/p&gt;

&lt;p&gt;
プレイする仮想画面(二次元配列)やテトリスの形のデータの持ち方は
先人の知恵を参考させていただきます。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org99cd9ba" class="outline-3"&gt;
&lt;h3 id="org99cd9ba"&gt;&lt;span class="section-number-3"&gt;4.4&lt;/span&gt; スプライトエディタ&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-4-4"&gt;
&lt;p&gt;
昔作った対戦テトリスは、ブロックが一列揃ったときのキラリと光る
アニメーションが売りでした。今回もそれをしたいのですが、そのよう
なアニメーションをするブロックのビットマップデータは見つかりません
でした。
&lt;/p&gt;

&lt;p&gt;
そこで、自分で用意することにします。スプライトエディタとして有名な
&lt;a href="https://www.aseprite.org/"&gt;aseprite&lt;/a&gt;を購入して、自分でブロックのピクセルアートを作成しました。
Pythonの勉強という意味では寄り道ですが、こういったことも楽しいもの
です。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf2b1fed" class="outline-3"&gt;
&lt;h3 id="orgf2b1fed"&gt;&lt;span class="section-number-3"&gt;4.5&lt;/span&gt; ブロックを一つ表示する&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-4-5"&gt;
&lt;p&gt;
いよいよコーディングです。arcadeライブラリサイトにあるチュートリアル
のコードをベースにします。まずは、画面にブロックを一つ表示するところ
からです。
&lt;/p&gt;

&lt;p&gt;
仮想画面上のx, y座標と色を指定すると、その位置に指定色のブロックを
スプライトとして表示するコードを書きました。簡単なデバッグの後、
ブロックが表示されます。これが最初の一歩です。
&lt;/p&gt;

&lt;p&gt;
ついで、ブロックのグレー色を使った画面の枠を描きます。ループを
組み合わせて、ブロック表示関数を呼ぶだけなので、あっと言う間に
完成します。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org876361e" class="outline-3"&gt;
&lt;h3 id="org876361e"&gt;&lt;span class="section-number-3"&gt;4.6&lt;/span&gt; テトリスブロックの表示&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-4-6"&gt;
&lt;p&gt;
いよいよ本番、落ちてくるテトリスブロックの表示です。ネットから
借りてきた情報を参考に、データ構造は考えてあります。キー入力や
スプライトの動きといった「足回り」は、arcadeのチュートリアルで
写経済みですので、本筋のロジックに思考を集中できます。
&lt;/p&gt;

&lt;p&gt;
テトリスブロックの登場、一定時間ごとの落下、底に着いた判定、
回転や横移動のキー入力を含んだ長いコードを書き殴ります。しばらく
苦労してデバッグした後で、リファクタリングして処理のまとまりを
関数として独立させ、見通しを良くしていきます。リファクタリングの
考え方、やり方はPython Crash Courseで学んでいます。
&lt;/p&gt;

&lt;p&gt;
一ライン揃った時のアニメーションとゲームオーバー判定を入れ、
とりあえずゲームとしての体裁が整います。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgbb1b957" class="outline-3"&gt;
&lt;h3 id="orgbb1b957"&gt;&lt;span class="section-number-3"&gt;4.7&lt;/span&gt; 対戦テトリス化&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-4-7"&gt;
&lt;p&gt;
とりあえず、普通のテトリスゲームはできましたが、これだけだと
初級者が作ってWeb公開した、無数にあるテトリスと何ら変わることが
ありません。プラスアルファとして、二人のプレイヤーで対戦する
要素を入れ込みます。
&lt;/p&gt;

&lt;p&gt;
画面を二分割し、左右で二人のプレイヤーが対戦するのですが、その
ためにPlayerクラスを定義し、プレイヤーごとに必要なアトリビュートや
メソッドをそちらに移動します。実質、一日半程度で対戦化が完了しま
した。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org9478ab6" class="outline-3"&gt;
&lt;h3 id="org9478ab6"&gt;&lt;span class="section-number-3"&gt;4.8&lt;/span&gt; コズメティクス&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-4-8"&gt;
&lt;p&gt;
この段階で、小学5年生になる娘に感想を求めます。しかし彼女は
全く興味を示しませんでした。なるほど、見た目がいかにも地味です。
そこで、タイトル画面を作り、ゲーム画面にきれいな一枚絵を表示する
ことにしました。「画像」「フリー」他のキーワードで、ゲームに
使用できそうな画像データを探します。今回は更に「曼荼羅」の
キーワードも指定しました(きれいなので)。
&lt;/p&gt;

&lt;p&gt;
単に一枚絵を背景に表示するだけでは芸が無いので、単純なエフェクトを
かけます。タイトルビューでは、拡大率と透過率を変えて、横に
スクロールさせます。ゲーム画面では、曼荼羅を少しずつ回転させて
ます。
&lt;/p&gt;


&lt;div id="org645bdd9" class="figure"&gt;
&lt;p&gt;&lt;img src="./images/zentetris.png" alt="zentetris.png" /&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
軽く効果音を入れて、完成です。また娘に見せると、今度は「ずいぶん
印象が変わったね」というお褒めの言葉をもらいました。相変わらず
プレイしてくれませんが。。。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgce14842" class="outline-2"&gt;
&lt;h2 id="orgce14842"&gt;&lt;span class="section-number-2"&gt;5&lt;/span&gt; 公開してみる&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgef4e71b" class="outline-3"&gt;
&lt;h3 id="orgef4e71b"&gt;&lt;span class="section-number-3"&gt;5.1&lt;/span&gt; githubに公開する&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-5-1"&gt;
&lt;p&gt;
Pythonで作ったゲームをインストーラー化せずに公開するにはgithubが
一番よさそうです。githubにアップロードするにはgitを使う必要があり、
泥縄でgitの用意をします。開発でgitを使うのはもちろん初めてです。
&lt;/p&gt;

&lt;p&gt;
qiita等の記事を見ながらgithubのアカウントを作り、何とかプッシュ
に成功します。&lt;a href="https://github.com/achiwa912/tet"&gt;https://github.com/achiwa912/tet&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
その勢いで、pygameのサイトにも載せてみます。&lt;a href="https://www.pygame.org/project/4904"&gt;https://www.pygame.org/project/4904&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1a977ba" class="outline-3"&gt;
&lt;h3 id="org1a977ba"&gt;&lt;span class="section-number-3"&gt;5.2&lt;/span&gt; プルリクエストに動揺する&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-5-2"&gt;
&lt;p&gt;
とりあえず世界中に向けて公開したわけですが、もちろん誰の目にも
止まりません。
&lt;/p&gt;

&lt;p&gt;
数日後、個人宛てに奇妙なメールが届きます。どうやら、公開した
ゲームに誰かがプルリクエストしてくれたようです。「プルリクエスト」
の意味さえ知らない私は動揺します。
&lt;/p&gt;

&lt;p&gt;
中身を読むと、その人は、私の書いたREADME.mdの英語を添削してくれて
いました。優しい人もいるものです。ありがたくマージさせていただき
ました。
&lt;/p&gt;

&lt;p&gt;
もう一つ、同じ方から、Fedoraで動かないという問題指摘もいただきま
した。virtualbox上のFedoraで見てみたところ、指摘と同じエラーメッセージ
が出ました。インストールされているOpenGLバージョンがarcadeライブラリ
のサポートするバージョンより古いというもので、その旨コメントを返しました。
&lt;/p&gt;

&lt;p&gt;
よくわかりませんが、OSS活動への入門をしてしまったということなので
しょうか。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org8807108" class="outline-2"&gt;
&lt;h2 id="org8807108"&gt;&lt;span class="section-number-2"&gt;6&lt;/span&gt; クロージング&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-6"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Pythonは比較的簡単で気軽に使え、その割に高度なことができるため、とりあえずプログラミングを学びたい人にお勧めの言語です&lt;/li&gt;
&lt;li&gt;入門はハンズオン(写経)に重点を置くとよいと思います。腕は頭より忘れないので&lt;/li&gt;
&lt;li&gt;1冊目としてPython Crash Courseはお勧めです。ハンズオン中心かつ実践的です&lt;/li&gt;
&lt;li&gt;2冊目としてIntroducing Pythonはお勧めです。頭の中が整理され、Pythonで何ができるかがわかります&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Python"></category><category term="python"></category><category term="game"></category></entry></feed>